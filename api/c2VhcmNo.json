[{"title":"JS模块化","date":"2022-01-24T10:49:33.000Z","date_formatted":{"ll":"2022年1月24日","L":"2022/01/24","MM-DD":"01-24"},"updated":"2022-02-01T01:24:26.640Z","content":"","plink":"http://blog.lipanpanx.com/post/2020/202010/JS模块化/"},{"title":"CSS intrinsic and extrinsic sizing","date":"2022-01-03T10:25:22.000Z","date_formatted":{"ll":"2022年1月3日","L":"2022/01/03","MM-DD":"01-03"},"updated":"2022-02-01T01:24:26.644Z","content":"参考文档:\nIntrinsic size\nCSS Box Sizing Level 3(WD-&gt;CR) Intrinsic Size Determination\nExtrinsic sizing 根据元素的上下文确定大小，而不考虑元素的内容。\nIntrinsic sizing 调整根据元素的内容确定大小，而不考虑其上下文。\n2 Terminology(相关术语)\nsize block-size inline-size:\n尺寸 就是我们常说的 width/height\n\ninner size: The content-box size of a box.\nouter size: The margin-box size of a box.\n\ndefinite size : 无需真实布局就能解析出来的大小\nindefinite size: 不确定的大小\navailable space: 表示放置box的空间的大小，由它参与的格式化上下文的规则决定。一个盒子的可用空间通常要么是它所包含的块的尺寸(如果box大小是确定的)，要么是一个无限的大小(如果box大小是不确定的)。可用空间既可以是min-content constraint，也可以是max-content constraint，这将迫使放置在其中的box 按照该约束进行布局。\n2.1. Auto Box Sizes\nCSS中有四种自动确定的size类型\n当你给定某个尺寸为auto的时候 可以根据这些size和上下文 确定 这个大小为auto的尺寸渲染到UI上的具体值\nstretch-fit size\nstretch-fit inline size\nstretch-fit block size\nmax-content size: 如果给定一个无限的可用空间 一个box 在给定轴上的 理想大小.\nmax-content inline size : 一个box 在 inline轴 上的理想大小\nmax-content block size : 一个box 在 block轴 上的理想大小\nmin-content size : 确保盒子中内容不会溢出的最小尺寸\nmin-content inline size: 在inline轴上确保盒子不会溢出的最小尺寸\nmin-content block size: 在 block轴上 确保盒子不会溢出的最小尺寸\nfit-content size: 如果 给定轴上的可用空间一定定义好了等于 clamp(min-content size, stretch-fit size, max-content size) 则盒子的大小比 min-content constraint 小的时候 fit-content size 等于 min-content size 否则 等于 max-content size.\nfit-content inline size:\nfit-content block size:\nintrinsic size\n内在尺寸 可以是 min-content size 也可以是 max-content size,就是指由内容大小产生的size\n这个术语的某些用法也可指主要从这两种大小之一派生出来的大小\nReplaced elements 通常从 natural dimensions 获得他们的 intrinsic size.\n2.2. Intrinsic Size Contributions\nmax-content contribution :\nmin-content contribution\nintrinsic size contribution\n2.3. Intrinsic Size Constraints\nmax-content constraint:\nmin-content constraint:\npreferred aspect ratio:\n5.1. Intrinsic Sizes\nThe min-content size of a box in each axis is the size it would have if it was a float given an auto size in that axis (and no minimum or maximum size in that axis) and if its containing block was zero-sized in that axis.\n(In other words, the minimum size it has when sized as “shrink-to-fit”.)\n一个 box的  min-content size\n5.2. Intrinsic Contributions\n","plink":"http://blog.lipanpanx.com/post/2021/202104/CSS-intrinsic-and-extrinsic-sizing-specification/"},{"title":"CSS Grid布局当中的grid-template-columns/rows/areas","date":"2022-01-02T10:11:10.000Z","date_formatted":{"ll":"2022年1月2日","L":"2022/01/02","MM-DD":"01-02"},"updated":"2022-02-01T01:24:26.644Z","content":"grid-template/\n","plink":"http://blog.lipanpanx.com/post/2021/202104/CSS-Grid布局当中的grid-template/"},{"title":"OBS 录制屏幕的指定区域","date":"2021-12-27T11:19:10.000Z","date_formatted":{"ll":"2021年12月27日","L":"2021/12/27","MM-DD":"12-27"},"updated":"2022-02-01T01:24:26.644Z","content":"OBS 默认情况下是 录制全屏的 其实它也是可以录制屏幕的指定区域的只是需要简单的设置而已:\n首先用鼠标点击 选中录屏的预览框  选中之后 录屏预览框周围会出现  红色的操作手柄, 然后按住alt 再通过鼠标 拖动周围的操作手柄 就能够控制 录制视频的区域了\n\n虽然这一波操作之后确实可以录制  屏幕的指定区域  但是有可能会让录制的视频出现非常大 的黑边\n这个时候可以通过 调整基础画布来解决这个问题\n\n一般情况下基础画布的分辨率为  1920*1080, 这个时候如果你选定的屏幕分辨率为 1080*1920 这个时候就会出现画布和录制区域的宽度和高度严重不匹配的情况 对于超出的高度可以通过压缩来解决  但是对于不足的底部宽度 只能填充黑边 这就是黑边产生的原因了  所以要去除黑边 我们可以 通过调整画布的分辨率 来实现, 如果录制的区域 宽度和高度为更接近16:9 我们就选择基础(画布)分辨率为 1920*1080 如果宽度和高度比更接近9:16 则我们选择 基础(画布)分辨率为 1080*1920, 只要宽高比是接近的 通过缩放操作 总能够去除黑边.\n一般情形下 基础(画布)分辨率就是我们的输出文件的分辨率, 但是我们仍然可以通过下面的哪个  输出(缩放)分辨率选择框 进一步调整输出文件的分辨率, 通过适当的缩放算法 对基础画布的内容进行缩放  可以实现控制文件大小的目的.\n此外OBS录屏的时候 视频格式尽量选择MKV格式, 这种格式可以进行意外恢复 也可以多音轨录制, 录制完成之后 OBS也提供快速的格式转换功能 可以快速把MKV转换成为MP4\n\n","plink":"http://blog.lipanpanx.com/post/2021/202112/OBS-录制屏幕的指定区域/"},{"title":"Grid template areas","date":"2021-12-24T10:07:13.000Z","date_formatted":{"ll":"2021年12月24日","L":"2021/12/24","MM-DD":"12-24"},"updated":"2022-02-01T01:24:26.644Z","content":"参考资料\n","plink":"http://blog.lipanpanx.com/post/2021/202104/Grid-template-areas/"},{"title":"Box alignment in CSS Grid Layout","date":"2021-12-22T10:23:46.000Z","date_formatted":{"ll":"2021年12月22日","L":"2021/12/22","MM-DD":"12-22"},"updated":"2022-02-01T01:24:26.644Z","content":"相关参考文档\n","plink":"http://blog.lipanpanx.com/post/2021/202104/Box-alignment-in-CSS-Grid-Layout/"},{"title":"Hexo+Inside+Github+(NetlifyCMS+Vercel+Cloudflare)构建全球可高速访问的静态站点","date":"2021-11-16T07:27:20.000Z","date_formatted":{"ll":"2021年11月16日","L":"2021/11/16","MM-DD":"11-16"},"updated":"2022-02-01T01:24:26.644Z","content":"0x10 前情提要\n我的博客一直以来都是静态的站点,静态的站点优点还是很多的,很多地方提供免费的托管服务,访问速度快,搜索引擎友好,等等. 但是有优点就有缺点,静态站点的缺点也很明显,无法承载过于复杂的功能,就个人博客而言,如果做成动态网站有管理后台的那种的话就可以随时随地写文章更新文章了,想对文章进行更改校对,任何一个有网的地方登陆后台就可以操作其实还是很爽的,所以我决定给我的静态站点添加一个后台管理系统就是netlifyCMS,这个netlifyCMS是netlify公司的产品, 这个东西可以让你方便的在线 管理 书写 发布你的文章,我尝试了一下效果还是不错的.\n\n0x20 在netlify中部署使用netlifyCMS\n0x21 静态站点部署到netlify\n因为 netlifyCMS是netlify公司的展品, 刚开始我不知道我还以为要想使用netlifyCMS就必须把站点放到netlify上面去才行,于是就开始折腾netlify,其实把站点放到netlify上还是比较简单的,我这里简单的讲一下:\n\n首先注册netlify账号 因为它可以使用第三方账号进行注册,我的项目都在githu上我就选择了直接用github账号进行注册\n然后就是选择git仓库创建网站,这里也很简单 按照它的提示一步步来就醒了 总共三步\n\n最后一步这里 你可以选择git仓库的分支, 可以设置安装依赖和运行构建命令的目录, 以及最后保存静态文件部署静态站点的文件夹,当然 这里也可以 设置环境变量 设置serverless 函数的文件夹 不过我们用不着 这两个也就不用管它了.\n\n\n这里有个非常蛋疼的点 就是这里可以选择一个目录 作为你安装依赖和运行构建命令的目录,但是如果我的项目当中 包含了一个子项目 需要多处安装依赖,然后需要多处运行构建命令呢? 我不知道针对套娃项目 如何在netlify中部署 至少我暂时没有看到设置的地方. 这一点我觉得vercel就做到很好,在vercel当中你可以自己去设置安装依赖和构建项目的命令,这样的话对于需要多处安装依赖的项目你直接可以把命令写在packge.json的scripts当中 然后提交给vercel一个运行script的命令就行了 比如你的script设置成为&quot;vercel_install&quot;: &quot;npm install &amp;&amp; cd themes/inside &amp;&amp; npm install&quot;,然后把 npm run vercel_install 提交给vercel就行了.\n\n\n最后选择 deploy site,就能把你的网站部署到netlify上面了,是不是很简单\n\n0x22 netlify当中使用netlifyCMS\n1, 首先进入到你的站点 然后点击 site setting进入到你的网站的设置页面,就可以看到一条长长的网站设置菜单\n\n\n2, 我们看到网站的设置页面有很多的选项可以设置,我们首先打开身份验证服务,选择identity然后点击enable identity即可\n\n开通身份验证服务之后 identity菜单会增加很多的可配置项, 在registration当中我们可以配置为仅仅我们邀请的注册用户才能访问netlifyCMS,在Services当中我们可以配置打开Git Gateway服务,这样一来netlifyCMS就有权读写我们的仓库了.\n\n3, 既然后端的验证服务有了我们就需要前端的身份验证页面,前端的验证页面也很简单\n对于hexo框架而言 首先在项目根目录的 /source文件夹下面创建admin文件夹 然后里面放上两个文件index.html 和 config.yml,其中index.html是前端验证页面的入口,config.yml是 netlifyCMS的配置文件,netlifyCMS可以根据这个配置文件来确定以怎样的方式去读取和操作你的文章\n我们直接在index.html 中添加下面的代码\n12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Content Manager&lt;/title&gt;    &lt;script src=&quot;https://identity.netlify.com/v1/netlify-identity-widget.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- Include the script that builds the page and powers Netlify CMS --&gt;    &lt;script src=&quot;https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n这段代码就是加载两个js文件,一个用来渲染CMS的页面一个用来进行身份验证\n因为我们最终需要 通过 lipanpanx.com/admin/ 去访问到CMS, 所以admin文件夹最终会被放到hexo所生成的网站的根目录当中,为了避免hexo对admin文件夹进行过多的操作,我们在hexo的配置文件的 skip_render字段当中添加- admin/**,确保hexo不对admin文件夹当中的内容进行渲染.\n4, 当我们完成前端验证页面入口的添加之后, 把站点部署到 netlify上面然后我们访问自己的站点后面加上/admin/也就是 xxx.com/admin/,就能通过netlify账户进行登陆了,但是这个netlify用户必须是自己邀请的用户(刚才在identity-&gt;registration哪里设置了仅邀请的用户才可以登陆),邀请用户其实也是非常简单的,只需要找到网站实例设置下的 identity页面 点击invite users按钮输入邮箱地址就行了.\n\n5, 登陆账户之后就能看到后台管理的页面了,但是目前的后台管理系统空空如也,需要合理的设置/source/admin/config.yml文件,才能够让自己的后台管理系统正常的工作:\n我在 netlifyCMS的官方文档当中找到了 官方的demo 和 官方demo的配置文件,这两个东西对于想要自己写配置文件的同学是非常重要的参考. 想要进一步学习如何配置netlifyCMS的同学可以看看下面的内容:\n关于 netlifyCMS的配置文件/source/admin/config.yml中各个配置项应该如何配置, 官方文档中的 configuring your site 章节进行了详细的讲解,这一章节又分为两个小节,其中 configuration options小节中包含了所有我们常用的配置, beta features小节的大部分功能一般用不到,但是也有一小部分是非常有用的. 我这里主要讲解一下 configuring your site小节当中的内容:\nconfig.yml 文件当中有12个根配置项,这12个根配置项目当中又有3个配置项是必须要有的,分别是: backend media_folder collections, config.yml文件当中至少要包含这三个配置,其他的配置项是可有可无的,这里我先给出一个配置的example,然后再结合代码注释讲解一下这几个配置的作用:\n12345678910111213141516171819202122232425backend: # 这个backend实际上就是个中间商它允许你的netlifyCMS和提供内容存储服务的第三方进行通信 这里按照netlifyCMS的文档要求设置即可 如果使用自定义的backend 按照backend要求配置即可  name: git-gateway # netlifyCMS的一个开源项目 允许你在netlifyCMS当中操作git仓库, 默认使用 netlify identity服务进行合法用户的认证  branch: master # 指定被操作的git仓库的分支 # local_backend: true  #解除这个注释运行npx netlify-cms-proxy-server 然后再运行hexo s 就能本地调试netlifyCMS media_folder: &#x27;source/images&#x27;  # netlifyCMS提供了上传文件的功能,可以把本地的文件上传到网站的根目录当中这个选项可以控制上传文件的路径# public_folder: &#x27;/images&#x27;  # 这里控制 网页中引用上传资源时候的路径# publish_mode: editorial_workflow  # 这里控制是否使用netlifyCMS 提供的工作流collections:  # collections下面可以有多个collection 每个collection都必须有一个name 且这个name不能够重复  - name: &quot;posts&quot;  # 必须存在的字段,名字任意 不能重复,这个name并不会显示在netlifyCMS的UI当中    label: &quot;2021&quot;  # 在 netlifyCMS当中collection 显示的名字     folder: &quot;source/_posts/2021&quot; # 你的文章所存储的路径     sortable_fields: [&#x27;date&#x27;]  # 控制那些字段用来给文章排序    create: true  # 是否允许在netlifyCMS中创建新的文章    editor:      preview: true # 在netlifyCMS中写文章和时候是否允许打开预览窗口     fields: # 每篇文章头部的 front-matter 都可以设置与其相对应的widget,在netlifyCMS就可以使用widget设置文章头部的front-matter      - &#123;label: &quot;Title&quot;, name: &quot;title&quot;, widget: &quot;string&quot;&#125;      - &#123;label: &quot;Publish Date&quot;, name: &quot;date&quot;, widget: &quot;datetime&quot;, format: &quot;YYYY-MM-DD HH:mm:ss&quot;, dateFormat: &quot;YYYY-MM-DD&quot;, timeFormat: &quot;HH:mm:ss&quot;, required: false&#125;      - &#123;label: &quot;Updeted Date&quot;, name: &quot;updated&quot;, widget: &quot;datetime&quot;, format: &quot;YYYY-MM-DD HH:mm:ss&quot;, required: false&#125;      - &#123;label: &quot;Tags&quot;, name: &quot;tags&quot;, widget: &quot;list&quot;, required: false&#125;      - &#123;label: &quot;Categories&quot;, name: &quot;categories&quot;, widget: &quot;list&quot;, required: false&#125;      - &#123;label: &quot;Body&quot;, name: &quot;body&quot;, widget: &quot;markdown&quot;, required: false&#125;\n其实 collections 又分为 folder collections 和 file collections 这两者的区别在官方文档的collections types进行了详细的说明,我这里就不在赘述, 因为我需要在一个collection中管理多篇格式相同的文章所以我使用folder collections,关于collection下面的各种widget的应该如何配置 查看官方文档可以得到更加详细的信息.\n这些内容全部做完之后,只要我们更新代码然后提交到github,就能触发netlify去构建我们的项目生成网站的静态文件并进行部署,我们通过netlify提供的临时域名就能够访问我们的站点了, 然后我们通过在域名后面添加 /admin/ 就能够访问netlifyCMS了,在netlifyCMS当中可以随意的添加删除文章.会自动同步到github仓库,如果此时我们还想要在本地写文章的话,在本地写之前可以先和remote仓库进行同步,把remote仓库中的内容拉下来之后可以继续写不会和netlifyCMS有所冲突. 这样看起来一切都挺好的,这篇文章已经可以结束了, 但是经过我的试用我发现把博客放在 netlify的速度奇慢无比, 甚至不如我之前放在 github pages 用cloudflare cdn 加速来的快, 加载一个网页需要 3-4秒钟, 这谁受得了啊, 于是我就开始在网上进行了一番搜索, 终于我找到了一篇神奇的文章, 文章的作者也是苦于netlify的速度非常的慢最后通过把博客部署在vercel上面加快了博客的访问速度,还给出了访问速度的对比结果:点击此处查看. 但是我是需要使用netlifyCMS的呀, 如果单纯的把博客部署在vercel上面对我来说并没有任何的意义, 所以我搜了一下结果发现 netlifyCMS还真的能够在 vercel上面使用,真的是太棒了 这样依赖既能够使用netlifyCMS又能增加博客的访问速度 何乐而不为呢.\n0x30 在Vercel上面部署和使用netlifyCMS\n0x31 netlifyCMS是如何运作的?\n要想在vercel上面使用netlifyCMS,就要搞清楚这东西是如何运作的,之前我们也提到了在我们访问xxx.com/admin/的时候 /source/admin/index.html会被加载,这个hmtl文件中的内容 就是引入两个JS文件,一个负责页面的渲染,一个负责用户认证, 所以netlifyCMS的最核心的功能其实就是这两个, 页面渲染靠前端的JS能够完成,而用户认证一般情况下需要靠后端配合来完成,那么netlifyCMS是如何在无后端的情况下实现的呢? 其实netlifyCMS之所以能够完成用户认证其实是使用了第三方的认证服务,一般情况下我们可以使用serverless函数和第三方的认证服务进行对接,对于serverless函数的指定是在 /source/admin/config.yml文件当中backend字段进行配置的,其实netlifyCMS的文档中也说的非常清楚了:A backend is JavaScript code that allows Netlify CMS to communicate with a service that stores content - typically a Git host,当我们在netlify中使用netlifyCMS的时候, 经过合适的配置之后netlify中的serverless函数会在用户请求登陆的时候加载然后和netlify的用户认证服务进行通信判断用户的合法性, 所以在vercel中使用netlifyCMS我们也可以使用serverless函数去 和第三方的认证服务去通信(比如github的oauth)进行用户合法性的认证. 那么接下来的问题就是 如何实现这些serverless函数并且在vercel当中进行调用呢,这其实是一个头疼的问题,不过好在我们有万能的github.\n其实netlifyCMS是一个开源的东西: github仓库地址,对于如何实现自己的的backend,虽然在netlifyCMS的官方文档中没有进行说明,不过在这个开源仓库当中的package文件夹当中 还是给出了大量可供参考的代码的,不过只读代码还是有点苦涩的.还好在国外有大佬已经实现了可以在vercel上部署的使用GitHub oauth 认证服务的demo了: 仓库地址, 简直太令人感动了.\n0x32 在Vercel中部署使用netlifyCMS\n把国外大佬的仓库clone到本地,对于还没有创建hexo项目的用户可以直接在这里仓库里面创建hexo项目,直接用就完了\n对于已经创建hexo项目的用户只需要 把demo当中的 /api 和 /lib 两个文件夹和 vercel.json 拷贝到字节的hexo项目的根目录,然后找到package.json文件当中的3个依赖合并到自己hexo项目的package.json文件当中去就行了.\n完成上面的操作之后 再去配置 /source/admin/config.yml文件当中的backend字段:\n123456backend:  name: github  repo: lipanpan-hub/xsite      # github仓库地址  branch: master                # 选择仓库分支  base_url: https://xsite-sage.vercel.app/  # 这个可以先留空等到vercel部署完成之后得到链接 再填写# config.yml 文件的其他配置 照旧填写 \n然后把你的项目部署到vercel上面 得到临时域名 把这个域名填写到backend-&gt;base_url处\n然后 打开 github的 develop setting 点击 oauth apps 再点击 new oauth app 进入下面的页面:\n\n这张表单有三个必填项: 第一个application name 随便填写, 第二个hompage URL填写为刚到得到的 vercel临时域名,第三个authorization callback URL填写为刚才的临时域名后面再添加/callback:vercel临时域名/callback 然后点击register application成功注册程序之后,拿到clinet ID 和 client secret, 其中client secret 需要你点击 generate a new clinet secret 按钮去生成.\n拿到 client ID 和 client secret 之后 进入vercel 你的网站项目 然后再项目主页点击 settings-&gt;enviroment variables 添加两个环境变量 分别是:OAUTH_GITHUB_CLIENT_ID 和 OAUTH_GITHUB_CLIENT_SECRET, 这两个环境变量的值就是刚才得到的client ID 和 client secret.\n然后在vercel上重新部署你的网站项目就可以了.重新部署完成之后打开vercel提供的临时域名你就可以访问自己的站点了,同时在这个域名后面加入/admin/ 你就能访问文章管理后台页面了 这个页面使用github进行登陆认证.\n然而有些同学会在这里遇到一个奇怪的问题,就是访问/admin/页面的时候会得到一个错误的提示:\n1234Error loading the CMS configurationConfig Errors:Error: Failed to load config.yml (404)Check your config.yml file.\n下面我说一下我的解决方法:\nU2FsdGVkX1/3/jj51HXoSTlGJzTWXjX79brDQdMlbAv24ghdnxyyVyNY2ff5PCQlIWKCErqLJMa6JRfA9RV8LkucAMQ5nYvYf0BjlQLogJfD8co6w9hNyNN34OBe2l5ldJWGvJT+K/y7dgvkCaBZH4PZXaZ6sQHI4sZGx6uu4EmAmZ5DOjLov1zHKiCe/O8Qvm3slQceGfZ4MmucERLUM6pC0cOMxMWI+YHFGq5jbQokCSklUjzKUbn1+zPqfUFMnMUKEW+MbxzVhGA8qesSeC7wBDeYYLxtZpH4o4dYKqmPoAJshFSGtIYVoheVRAZ6XykL2HScJtW0XuCAFOewuf8g8rvHksnXv4yfgkZ59AjmNXsYPlSUbgkVbnGXjFfDipGxGQuis2hgT/BXGyzg3h3J+jQ0iiJxLFhFUo6quw0zOSN/V1RzoIWy2/vXJPG9PxYepqEUkng9Unzw1Fgf0aUxS9IlCh2SIIQyy5WU6T7VvtuhDxukw4/3z3T9YBqQHy6jHWKBJIIJpr5M0A3MWIl/7rTDC8wL0RFYkz6Mwvve3R4NLv+bD8JtS9LIPLNo9SBgUk/1XRM5dsnn2iIUA5JcwfZyDDaPEPnaXYiR7xLyrlZrFePgC27dWvYvI3yKSKQFKqOk0agmpmLMd+j3c5Ekt0u02bSXP5BScnH4WC9/7ehm/NOl166OMnZWojWokWUMZbsG3LOxl8VufI8EFCkYetE8EbcSOWd2bw4eHgOQQuQvYrGHwgveSLpJwk2JFbx0AQdgW9JO6FibxFIH2KjjjTfX3ayRUqWkGYOAdp2inZc0WxGO5XAeWfRWIlagznU1/NSxJyAtxVC1XCf8udi5LrF7J7ab4VHiClW9S+Ogif8tZycsNG5YQkVc7orZ/oBVspVKE8tMXdoZHtiCXohrRldtP63idg92RNXoGx4QuAi/fcoSzNTu7EN5s9z99mFGk7862KM6kAYyWljYcF4yyMaymu0teP7GrrRlP8RBOWej+Big5bmLY6nu5YSU0gurUMzvNL6WwiSwc7unkJQtg4t+8KD7pWV9CkiJyCpPI/2uB1UdJ4o5Dg3UBkrrZ4j5hS9BLforvkGKTAtVDdjbmbj7Rn15L7w/vs6OxBi3bj/mo/kjeXiSx5sF4vP5s/UmvfziesbLhM9aQEXxyrPAKuHA3ybA9aK7xllmQpP8HhZCv5J4GGSmVeBj2gVmf92mDILh+gy1+ucNUlAeHYcwuVrlPbDekBTgCJ9RFTpZxGAah9ZZTbO2Z1YqvvEFYj/hxGWk2PUpb1zuOkWYjQAgJ4rGGmji6xCu/KZo7ypu97Fgj4K656fEBfasTsBILUAJiAGX6rwqW8PAN/2BNfLvo0X6EpJi7+YYvYQ+go8=自定义域名\n当我们的 在vercel上成功的部署项目之后,访问速度确实加快了,而且新添加的netlifyCMS也确实挺好用,但是访问的时候使用的是vercel的临时域名,这个域名非常的长太难记忆了而且都是乱码组成的根本拿不出手啊, 所以绑定一个专业的域名还是非常有必要的, 对于刚申请的域名直接把nameserver设置为vercel的nameserver然后绑定就能用了,但是我并不想要这么干,我只想把自己的域名放在cloudflare上面进行管理,然后配合vercel使用,原因有下面几个:\n\n首先我所有的域名都是放在cloudflare上面进行管理的 我不想要搞的东一个西一个很乱\n然后更改nameserver需要时间 我不想等\n之前vercel出现过在大陆访问不了的情况,对于这种情况如果以后再出现,就可以通过cloudflare代理访问,站点仍然可以正常部署在vercel\ncloudflare 提供的各种网站安全 网站加速的功能 想用随时可以用\n\n打开 vercel docs 在顶部导航栏的 support 中我们可以找到一篇文章How do I use a Cloudflare domain with Vercel? 这篇文章详细的介绍了如何将 cloudfalre和 vercel配合使用进行自定义域名.\n由于目前国内访问vercel的速度还是比较快的,所以我这里就讲一下不使用cloudflare代理的情况下如何为vercel项目绑定自定义域名:\n\n在上图当中我在project settings 当中为项目绑定了两个地址 lipanpanx.com 和 blog.lipanpanx.com 要想要这两个地址生效,只需要在 cloudflare的dns设置当中 添加2条cname记录指向cname.vercel-dns.com,并且proxy status 设置为 dns only 如下图所示:\n\n操作完cloudflare之后 回到vercel项目的project setting-&gt;domains 点击 add按钮 添加 lipanpanx.com 和 blog.lipanpanx.com就行了.\n","thumbnail":"https://search.pstatic.net/common/?src=https://i.imgur.com/USr2l3A.jpg","plink":"http://blog.lipanpanx.com/post/2021/202111/为博客添加内容管理系统/"},{"title":"netlify-cli安装E404错误(找不到依赖项)解决","date":"2021-11-09T10:46:46.000Z","date_formatted":{"ll":"2021年11月9日","L":"2021/11/09","MM-DD":"11-09"},"updated":"2022-02-01T01:24:26.644Z","content":"今天打算安装 netlify-cli\n于是打开 terminal 运行了一下\n1npm install netlify-cli -g \n结果 上来就是一顿错误\n1234567891011npm ERR! code E404npm ERR! 404 Not Found - GET https://oss.npmmirror.com/netlify/-/netlify-8.0.4.tgznpm ERR! 404npm ERR! 404  &#x27;netlify@https://registry.npm.taobao.org/netlify/-/netlify-8.0.4.tgz&#x27; is not in this registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     C:\\Users\\lipanpan\\AppData\\Local\\npm-cache\\_logs\\2021-11-09T02_43_45_128Z-debug.log\n报错信息显示 无法在registry 当中找到 netlify-8.0.4.tgz\n12345678lipanpan&gt; npm view netlify versions[ ...省略若干  &#x27;6.1.10&#x27;,       &#x27;6.1.11&#x27;,       &#x27;6.1.13&#x27;,       &#x27;6.1.14&#x27;,       &#x27;6.1.15&#x27;,  &#x27;6.1.16&#x27;,       &#x27;6.1.17&#x27;,       &#x27;6.1.18&#x27;,       &#x27;6.1.19&#x27;,       &#x27;6.1.20&#x27;,  &#x27;6.1.21&#x27;,       &#x27;6.1.22&#x27;,       &#x27;6.1.23&#x27;,       &#x27;6.1.24&#x27;,       &#x27;6.1.25&#x27;,  &#x27;6.1.26&#x27;,       &#x27;6.1.27&#x27;,       &#x27;6.1.28&#x27;,       &#x27;6.1.29&#x27;,       &#x27;7.0.0&#x27;,  &#x27;7.0.1&#x27;,        &#x27;8.0.0&#x27;,        &#x27;8.0.1&#x27;,        &#x27;8.0.2&#x27;,        &#x27;8.0.3&#x27;]\n我看了下确实没这个版本 最高版本就是8.0.3 但是这个包的最新版本(8.0.4)6天前已经在npm上面发布了\n\n因为我使用的是 淘宝的 npm镜像来加速安装\n12lipanpan&gt; npm config get registryhttps://registry.npm.taobao.org/\n所以导致安装失败的原因看起来 好像是淘宝npm镜像没有同步更新\n我打开了淘宝镜像的网站(https://npmmirror.com/) 然后发现 register 地址不知何时从 https://registry.npm.taobao.org/ 变成了 https://registry.npmmirror.com/ 然后我通过域名解析查询 发现这两个域名指向相同的A地址.所以应该仅仅是变了一下域名.\n淘宝npm镜像的说明是 如果第一次安装失败 它会在后台自动同步 在后续安装的时候确保成功\n我连续尝试了好几次都是安装失败  看来这个说明并不靠谱\n然后 还有个 手动同步npm包的操作 就是手动执行  $ cnpm sync xxxx 但是我没安装cnpm, 着实让我感觉到蛋疼\n最后我选择换回 官方的 registery地址\n123lipanpan&gt; npm config set registry https://registry.npmjs.orglipanpan&gt; npm config get registryhttps://registry.npmjs.org/\n通过官方的reigstry 是可以看到最新版本的 netlify(8.0.4)包的\n1234567lipanpan&gt; npm view netlify versions[ ...省略若干  &#x27;6.1.21&#x27;,       &#x27;6.1.22&#x27;,       &#x27;6.1.23&#x27;,       &#x27;6.1.24&#x27;,       &#x27;6.1.25&#x27;,  &#x27;6.1.26&#x27;,       &#x27;6.1.27&#x27;,       &#x27;6.1.28&#x27;,       &#x27;6.1.29&#x27;,       &#x27;7.0.0&#x27;,  &#x27;7.0.1&#x27;,        &#x27;8.0.0&#x27;,        &#x27;8.0.1&#x27;,        &#x27;8.0.2&#x27;,        &#x27;8.0.3&#x27;,  &#x27;8.0.4&#x27;]\n然后安装 netlify-cli 一次性成功\n12345lipanpan&gt; npm install netlify-cli -g ...lipanpan&gt; netlify versionnetlify-cli/6.14.18 win32-x64 node-v16.13.0lipanpan&gt;\n","plink":"http://blog.lipanpanx.com/post/2021/202111/netlify-cli安装教程/"},{"title":"关闭vscode烦人的Github登陆弹窗","date":"2021-11-07T08:34:08.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"updated":"2022-02-01T01:24:26.644Z","content":"\n这两天不知道怎么了每次我打开vscode就会有烦人的github登陆弹窗弹出来,即使不登陆也不影响向github的remote仓库提交代码,但是这个弹窗真的让人好心烦\n\n\n\n弹窗就是上面这个样子\n查了不少资料 最终我在stack overflow 上找到了一个比较有说服力的说法:\n\n首先当在你的电脑上安装git的时候 也会顺带的安装上git凭据管理器, 而且git允许有多个git凭据管理器,\n\n\n然后就是git还允许多级配置分别为 local配置 global配置 system配置  这三个配置都会生效 最后形成一个 effective配置\n因为三个配置都会生效  git 调用凭据管理器的时候 是按照顺序去寻找的 最先去 system配置当中寻找相应的凭据管理器.\n如果你的 system配置当中凭据管理器的相关设置是credential.helper=manager 他就会去调用这个manager, 但是这个manager当中很可能就没有我们需要的凭据 这个时候git就会去下一级配置中去寻找其他的凭据管理器, 最后在下级的配置文件中 使用的是store管理器,最后认证通过 正常提交代码, 但是manager的调用请求已经发出了 所以manager是肯定会被弹出的\n\n\n听起来 上面的说法头头是道, 我也确实在system配置当中找到了 credential.helper=manager 但是我没在local的配置当中找到credential.helper=store 但是我还是选择了相信,按照作者的说法 折腾了半天 就是不行 好坑爹 心好累\n\n最后我无意间 看到github cli的文档中有一篇 缓存凭据的文章 Caching your GitHub credentials in Git\n我就照着这篇文章搞了一下 虽然到最后还是失败了 但是github cli给了我一个重要的提示\n就是我的personal token权限太低 因为我只给了personal token访问repo的权限\n\n要进行在git当中缓存github的凭据我就需要再生成一个至少包括三个权限的凭据\n\nrepo\nread:org\nworkflow\n\n最后我在github上面生成了一个新的包含这三个权限的personal token,然后在命令行中运行 gh auth login 按照cli的提示一步步操作, 就能够顺利的将github的凭据缓存到了git\n\n然后我再打开 vscode 就不会出现烦人的弹窗了\n真妙呀\n","plink":"http://blog.lipanpanx.com/post/2021/202111/关闭vscode烦人的Github登陆弹窗/"},{"title":"checkboxland尝鲜","date":"2021-10-30T09:59:16.000Z","date_formatted":{"ll":"2021年10月30日","L":"2021/10/30","MM-DD":"10-30"},"updated":"2022-02-01T01:24:26.644Z","content":"checkboxland显示汉字的方法\n\n0x10 checkboxland\n前两天 在 github trending 上看到一个开源项目\ncheckboxland 这个项目是用 checkbox 去组成像素点可以在网页上表达图像的这么个工具 github地址:\nhttps://github.com/bryanbraun/checkboxland\n我感觉这个小东西 真的挺有意思\n用checkbox 不仅仅可以放图片 放动画 玩贪吃蛇\n甚至可以在网页上面用checkbox播放电影(就很离谱)\n所以我就抽空玩了一下 本来 想想用这个写一句话放在站点上 做滚动广告牌 类似于这样:\n\n但是一个很明显的事情 就是这个项目是一个比较新的项目,支持中文是不可能支持中文的, 但是我实在是手痒, 最后想想决定自己去做几个汉字的小字库\n由于我想要显示的内容是 李攀攀全宇宙最帅 所以我打算先做我的名字\n0x20 汉字取模\n做这种点阵的汉字字模 我还是有点经验的的\n首先 我找到了一个在线的取模工具 我是取模工具\n这个工具可以说是非常棒了, 把你需要取模的 汉字输进去 他会返回一串 16进制的数字串.\n比如我的姓氏 李, 我选择的字体是16x16的宋体, 我按照 从左到右从上到下 横向8点左高位的方式取模\n最后得到的字符串是:\n120x01,0x00,0x01,0x08,0x7F,0xFC,0x01,0x00,0x05,0x40,0x09,0x30,0x31,0x0E,0xC1,0x04,0x0F,0xE0,0x00,0x40,0x01,0x88,0x7F,0xFC,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00\n然后再通过js 把这些16进制的数字串中的每一个数字转换成为 8位的二进制字符就行了\n123456789101112131415161718192021function binary(num, Bits) &#123;  var resArry = [];  var xresArry = [];  i = 0;  for (; num &gt; 0;) &#123;    resArry.push(num % 2);    num = parseInt(num / 2);    i++;  &#125;  for (j = i - 1; j &gt;= 0; j--)    xresArry.push(resArry[j]);  if (Bits &lt; xresArry.length) &#123;    console.log(&quot;位数小于二进制位数&quot;)  &#125;  if (Bits) &#123;    for (var r = xresArry.length; r &lt; Bits; r++) &#123;      xresArry.unshift(0);    &#125;  &#125;  return xresArry.join().replace(/,/g, &#x27;&#x27;);&#125;\n每2个8位为一组拼接成为 16x16 的二进制矩阵, 然后就能在 checkboxland 里面进行显示了\n比如 李 和 攀 的矩阵就是:\n12345678910111213141516171819202122232425262728293031323334[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0],[1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],[1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0],[0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0],[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0],[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n0x30 checkbox显示汉字\n最后我决定先把我的名字搞上去 直接把这个二进制的矩阵传给 checkboxland的实例就能显示出来了\n显示效果是这样的:\n\n不过还有个蛋疼的问题 就是 作者说checkbox的数量最好不要超过1500个 不然就会遇到性能问题\n这…\n我显示这三个汉字 就用掉了八百多个checkbox\n这玩意的最终的使用场景可能也就是显示字了, 汉字这个东西实在比较耗费盒子😂\n但是我感觉 网友还是能玩出花来的 这东西有意思\n","thumbnail":"https://search.pstatic.net/common/?src=https://i.imgur.com/paR4JdB.png","plink":"http://blog.lipanpanx.com/post/2021/202110/checkboxland尝鲜/"},{"title":"utools插件重载问题","date":"2021-10-27T07:47:05.000Z","date_formatted":{"ll":"2021年10月27日","L":"2021/10/27","MM-DD":"10-27"},"updated":"2022-02-01T01:24:26.644Z","content":"utools插件开发 中 plugin.json 中的配置无法生效问题\n\n0x10 需求\n最近两天打算找个不限制流量, 不限制容量的 图床, 之前 我一直用阿里云的OSS, 太鸡儿贵了\n因为我看到国外的不少图床 都是免费的 并且不限制容量不限流量, 我太心动了\n所以我打算把我国内的图床 换成国外的图床 然后在国内访问\n想法有了之后 我就开始动手折腾了,把所有的图片上传到国外的图床, 然后通过代理服务器访问就好了\n这就需要转链, 把原本图片的链接 转换成为 通过代理服务器访问的链接,所以我就需要搞个 utools工具  来帮助我方便的转链\n0x20 开搞\n这么久没有玩 utools也从1.x 升级到 2.x 了\n不过插件的开发方式还是大同小异\n开发过程挺顺利 不过中途遇到了几个坑, 我再这里记录一下\n0x21 utools加载插件的方式变了\nutools 1.x 可以直接加载插件 但是2.x 明显行不通\n2.x 如果你想要加载插件 你就需要首先下载一个 开发者工具 插件 这是一个开发utools插件的 插件, 如下图:\n\n0x22 utools插件重载\n本次插件开发当中遇到的一个最为蛋疼的问题就是插件重载的问题\nutools 识别不同插件是通过 一个plugin.json的文件\n这个文件里面可以定义  在什么时候什么条件下去唤醒 utools\n我在里面写了个通过正则表达式去匹配链接的方式去唤醒我的插件\n也就是说当我把国外的图床上图片的链接粘贴到utools的时候,utools会用我写好的正则表达式去尝试匹配这个链接,如果匹配成功  则utools 会调用我的插件 对 这个链接进行转链\n但是中途发现一个问题 就是链接 怎么都无法匹配成功\n我一度怀疑是我的正则表达式有问题导致无法成功匹配\n最后调试来调试去 发现 我无论怎么改正则表达式 就是无法匹配, 我才开始怀疑utools\n\n我已经 图中① 处的开关打开了\n按理说每次我插件UI进入隐藏状态之后 插件就会完全退出 等我再次进入插件 插件的代码都会重载\n本来我以为所有的插件代码都会自动重载\n但是 其实 实际情况并不是我想想的那样 如果你改动的是插件的逻辑代码 当你打开 图中①处的开关时候,插件确实会重载 但是如果你改动的是plugin.json 当中的内容, plugin.json 是不会被自动重载的, utools开发工具的自动重载 仅仅重载你插件的逻辑代码 不会重载你的 plugin.json文件, 这个文件 属于你的插件的配置文件\n好鸡儿蛋疼, 每次更改plugin.json 都需要 手动去重载 这个文件, 就是手动去按图中② 处的更新按钮\n0x23 js正则表达式的坑\n还有个比较坑的问题就是js的 正则表达式的坑:\n1&quot;text string&quot;.match(/exp/flags)\n我们使用 正则表达式的时候 一般会使用 不同的flag\njs 的正则表达式 也有各种flag  有  g  i m u y s 等各种flag\n但是在使用 match 函数的 时候 如果你的正则表达式使用的flag中有 g 这个flag\n则match 函数返回的匹配数据当中 不包含正则表达式匹配到的group数据\nmdn 中的原文是这样的:\n12If the g flag is used, all results matching the complete regular expression will be returned, but capturing groups will not.if the g flag is not used, only the first complete match and its related capturing groups are returned. In this case, the returned item will have additional properties as described below.\n一旦你的正则表达式使用了这个g flag,\n则match 函数返回的就不是详细的匹配数据,而仅仅是一个匹配结果,这样的话不是很方便做细致的调试\n","plink":"http://blog.lipanpanx.com/post/2021/202110/utools插件重载/"},{"title":"Hyper-V安装lede软路由","date":"2021-07-31T11:40:02.000Z","date_formatted":{"ll":"2021年7月31日","L":"2021/07/31","MM-DD":"07-31"},"updated":"2022-02-01T01:24:26.644Z","content":"首先下载固件\n固件可以去L大lede仓库的 github actions 页面下载.\nOpenWrt_firmware\n固件下载下来之后我们打开压缩包可以看到 压缩包内有许多的文件:\n\n这里我们可以把img文件转换成为vhdx格式的硬盘映像文件,然后把映像文件挂在到hyper-v虚拟机 来实现 lede的安装.\n我们需要转换的文件就是: openwrt-x86-64-generic-squashfs-combined-efi.img. 因为是安装在x86平台 且efi文件系统能够与hyper-v 2代虚拟机适配.\n然后用转换工具将 img文件转换成vhdx文件\n镜像转换可以去网上下载 StarWind V2V Image Converter转换工具安装到电脑上,然后执行下面的操作就行了.\n\n\n\n\n\n\n点击转换就能在我们指定的目录当中 生成我们所需要的 vhdx文件了\n然后创建虚拟机\n使用刚才生成的 vhdx文件创建虚拟机,需要注意下面几点:\n1, 选择hyper-v的 第二代虚拟机\n2, 配置网络的时候选择 一个 和宿主机共享网口的 外部网络虚拟交换机(方便从宿主机登录lede后台)\n3, 虚拟硬盘选择我们刚才生成的vhdx文件\n4, 关闭 虚拟机的 安全启动选项\n然后就能成功创建好一个lede虚拟机了\n虚拟机创建完成之后 默认的ip地址是: 192.168.1.1 有时候这个地址不是我们所需要的, 我们可以在虚拟机当中执行下面的命令来完成网络地址的更改.\n12345vim  /etc/config/network # 把虚拟机默认网口的ip地址更改为 和宿主机同一网段的合法地址cat network # 查看更改是否成功service network restart # 重启网络服务ifconfig # 查看网口地址是否更改ping 192.168.31.1 # 查看是否能够ping通网关\n搞定上述操作之后就能在宿主机打开lede的登录界面了,默认密码是password.\n\n","plink":"http://blog.lipanpanx.com/post/2021/202107/Hyper-V安装lede软路由/"},{"title":"GithubActions编译lede固件","date":"2021-07-31T10:11:17.000Z","date_formatted":{"ll":"2021年7月31日","L":"2021/07/31","MM-DD":"07-31"},"updated":"2022-02-01T01:24:26.644Z","content":"这两天开源界不太平为了防止L大删库跑路,我决定把它的仓库fork到我自己的github账号下面用github actions自己编译固件.\nfork lede 仓库\nlede github仓库地址\n进入L大的仓库 直接点击fork即可\n我fork的仓库\n创建自己的分支 并允许 github actions\n仓库创建完成之后 可以在github dev 提供的在线编辑器当中快速的创建一个自己的分支(我新建了一个lpp_lede分支), 我们在自己的分支中处理自己的操作, 这样不会影响主分支, 当L大的仓库发生变化的时候 我们的主分支依然可以快速merge L大的提交.\n\n还有就是fork的仓库是默认不支持 github actions的, 需要我们手动enable. 打开自己fork过来的仓库的actions选项卡 点击i understand my workflows,go ahead and enable them就行了.\n更改自己分支的 ci文件, 开始编译\ngithub actions的ci文件就是 .github/workflows/ 目录下的yml文件, lede源仓库中 此目录下存在一个 opnewrt-ci.yml 的文件, 这个文件定义了 github actions的所有行为,我们打开这个文件 可以看到作者规定了2中触发github actions执行编译的条件 一个是定时编译, 一个是由 release事件触发的编译. 这两种编译我都不需要我要的是手动编译. 所以我可以在我的分支上改为由push事件触发编译.\n123456789on:  schedule:    - cron: 0 20 * * *  release:    types: [published]# 上面这两种方式不需要 改为下面这样on:  push:    branches: [ lpp_lede ]\n这里切记 一切的更改都是发生在 自己的新分支上的 而不是项目的master分支上面的\n\n当我们在自己的分支上面提交更改完成的 openwrt-ci.yml 文件之后就能看到项目的主页会提示 lpp_lede分支发生了更改, 而且 github actions的编译行为也在 lpp_lede分支成功触发.\n\n\n然后我们坐等丰收的果实就行了\n","plink":"http://blog.lipanpanx.com/post/2021/202107/GithubActions编译lede固件/"},{"title":"Hyper-V虚拟交换机","date":"2021-07-30T12:39:03.000Z","date_formatted":{"ll":"2021年7月30日","L":"2021/07/30","MM-DD":"07-30"},"updated":"2022-02-01T01:24:26.644Z","content":"hyper-v 管理器当中除了当我们新建一个虚拟机,默认情况下这个虚拟机会连接到hyper-v自带的 default switch 交换机.\n除了 default switch这个虚拟交换机之外, hyper-v 管理器当中还可以手动创建多种形式的虚拟交换机.分别是:\n1, 允许共享网络适配器的外部网络虚拟交换机\n2, 不允许共享网络适配器的外部网络虚拟交换机\n3, 内部网络虚拟交换机\n4, 专用网络虚拟交换机\n\n今天我就来讲下这几种不同虚拟交换机的特点:\n允许/不允许 共享网络适配器的外部网络虚拟交换机首先就是 外部网络虚拟交换机是允许访问互联网的,因此需要和网口进行绑定,在绑定网口的 时候有个非常重要的选项就是 是否允许管理操作系统共享此网络适配器 如果勾选这个选项则 连接此虚拟交换机的虚拟机可以和宿主机共享网口, 二者可以通过同一个网口连接网络. 如果没有勾选此选项则和虚拟交换机绑定的网口仅仅为虚拟机服务, 无法再为宿主机服务.\n内部网络虚拟交换机内部虚拟网络交换机 是不允许访问互联网的, 连接到此交换机上的虚拟机是可以和宿主机通讯的\n专用网络虚拟交换机专用网络虚拟交换机是 是没有连接到互联网的 连接到此虚拟交换机上的虚拟机是可以相互通信的 但是他们都不能与宿主机进行通信\n","plink":"http://blog.lipanpanx.com/post/2021/202107/Hyper-V虚拟交换机/"},{"title":"Hyper-V下的linux虚拟机访问宿主机文件","date":"2021-07-30T12:36:40.000Z","date_formatted":{"ll":"2021年7月30日","L":"2021/07/30","MM-DD":"07-30"},"updated":"2022-02-01T01:24:26.644Z","content":"","plink":"http://blog.lipanpanx.com/post/2021/202107/Hyper-V下的linux虚拟机访问宿主机文件/"},{"title":"Hyper-V下的Ubuntu虚拟机开启增强会话","date":"2021-07-30T12:35:53.000Z","date_formatted":{"ll":"2021年7月30日","L":"2021/07/30","MM-DD":"07-30"},"updated":"2022-02-01T01:24:26.644Z","content":"","plink":"http://blog.lipanpanx.com/post/2021/202107/Hyper-V下的Ubuntu虚拟机开启增强会话/"},{"title":"Hyerp-V虚拟机安装教程(ubuntu)","date":"2021-07-30T05:16:22.000Z","date_formatted":{"ll":"2021年7月30日","L":"2021/07/30","MM-DD":"07-30"},"updated":"2022-02-01T01:24:26.644Z","content":"为虚拟机选择系统\n\n从这张ubuntu releases cycle 图可以看出 LTS版本的声明周期相对其他版本要长的多,所以我们选择LTS版本作为我们的虚拟机系统的版本,比如: Ubuntu 20.04.3 LTS (Focal Fossa) 但是这个LTS版本依然有2个比较方便的可选项(还有其他选项):一个是带图形界面的 desktop版本 一个是不带图形界面的 server版本. 为了方便操作我们选择带图形界面的 desktop版本.\n\nHyper-V管理器当中新建虚拟机\n虚拟机系统安装步骤\n\n\n\n\n\n\n只需要等待一会就能安装完成了,然后重启一下就行了.\n\n重启完成之后会有一个系统设置引导界面,走完引导界面之后就能正式进入系统了\n\n同时虚拟机创建完成之后我们的电脑上存放虚拟机的文件夹当中会多处3个子文件夹,分别用来存放 虚拟机描述文件,虚拟硬盘文件,虚拟机快照文件.\n\n更改APT源 更新系统\n如果在系统安装的时候 时区设置成了shanghai 就不用更改软件安装源,ubuntu会自动选择中国的软件安装源,只需要在系统提示更新的时候手动点击按钮更新即可.\nubuntu系统科学上网\n","plink":"http://blog.lipanpanx.com/post/2021/202107/Hyerp-V虚拟机安装教程-ubuntu/"},{"title":"利用task调试VSCode配置文件当中的变量","date":"2021-06-20T16:57:58.000Z","date_formatted":{"ll":"2021年6月20日","L":"2021/06/20","MM-DD":"06-20"},"updated":"2022-02-01T01:24:26.644Z","content":"1234567891011121314151617181920212223242526272829303132333435&quot;tasks&quot;: &#123;  &quot;version&quot;: &quot;2.0.0&quot;,  &quot;tasks&quot;: [    &#123;      &quot;label&quot;: &quot;测试命令的名字&quot;,      &quot;type&quot;: &quot;shell&quot;,      &quot;command&quot;: &quot;echo&quot;,      &quot;args&quot;: [        &quot;$&#123;workspaceFolder&#125;&quot;, //其实就是 workspace文件 foler字段的第一个值        &quot;$&#123;workspaceFolderBasename&#125;&quot;,        &quot;&#x27;$&#123;file&#125;&#x27;&quot;, // 当前文件的绝对路径        // &quot;&#x27;$&#123;fileWorkspaceFolder&#125;&#x27;&quot;, //当前文件的 workspace foler        // &quot;$&#123;relativeFile&#125;&quot;, // 当前文件的相对路径  相对于 $&#123;wrokspaceFolder&#125;的路径        // &quot;$&#123;relativeFileDirname&#125;&quot;,        // &quot;$&#123;fileBasename&#125;&quot;, //当前文件的 文件名字        // &quot;$&#123;fileBasenameNoExtension&#125;&quot;,        // &quot;$&#123;fileDirname&#125;&quot;, //当前文件所在的文件夹的名字        // &quot;$&#123;fileExtname&#125;&quot;,        // &quot;$&#123;cwd&#125;&quot;,  // task runner 的当前工作目录 也就是 $&#123;workspaceFoler&#125;        &quot;$&#123;lineNumber&#125;&quot;,        // &quot;$&#123;selectedText&#125;&quot;, //被光标选中的内容        // &quot;$&#123;execPath&#125;&quot;,  //code.exe的 绝对路径        &quot;$&#123;defaultBuildTask&#125;&quot;, // 默认 build task的名字, 如果没有设置相应的值 task不会报错 但是task会拒绝执行        &quot;$&#123;pathSeparator&#125;&quot;,        ////////////////////////////////        &quot;$&#123;workspaceFolder:5675_node_child_process_module&#125;&quot;,        &quot;$&#123;env:USERNAME&#125;&quot;,        &quot;$&#123;config:editor.fontSize&#125;&quot;,        &quot;$&#123;&#125;&quot;      ],    &#125;  ],&#125;,\n","plink":"http://blog.lipanpanx.com/post/2021/202106/利用task调试VSCode配置文件当中的变量__/"},{"title":"VSCode的task系统","date":"2021-06-20T16:02:37.000Z","date_formatted":{"ll":"2021年6月20日","L":"2021/06/20","MM-DD":"06-20"},"updated":"2022-02-01T01:24:26.644Z","content":"vscode 的 task 系统可以让我们非常方便的调用外部的工具 可以说是非常强大了, 下面是常用的 task 相关的 vscode 指令:\n123456789101112131415161718Tasks: Run Task // 执行某个task(手动选择)Tasks: Run Build Task // 快捷执行 build task(需要事先配置好build task)Tasks: Run Test Task // 快捷执行 test task(需要视线配置好test task)Tasks: Rerun Last Tas // 快捷执行上次刚执行过的taskTasks: Configure Task // 对已经存在的task进行配置Tasks: Open User Tasks //打开 user目录下的 tasks.jsonTasks: Configure Default Test Task  // 手动配置 test taskTasks: Configure Default Build Task // 手动配置 build taskTasks: Manage Automatic Tasks in Folder  // 允许/禁止 automatic taskTasks: Restart Running Task // 重新运行正在执行taskTasks: Show Running Tasks // 展示正在执行的taskTasks: Terminate Task // 终止 taskTasks: Show Task Log // 显式 task 日志\n如果我们想要 使用 vscode 的 task 系统需要创建相应的 tasks.json 文件 在用户的 user 目录当中可以允许存在一个 tasks.json 文件这个文件中存放的 task 被称为用户 task, 同时在我们的 worksapce 当中也允许存在 tasks.json 文件这个文件当中的 task 可以被称为工作空间 task, 二者有一定区别但是区别很小, 学会使用 workspace task 则 user task 无师自通. 下面我主要讲解 workspace task.\n一般情况下 在我们的 worksapce 当中并不存在 tasks.json 这个文件,我们可以通过 vscode 提供的命令 Tasks: Configure Task 来随便配置一个 task,这样依赖 vscode 会为我们在 workspace 的.vscode 目录下面自动创建一个 tasks.json 文件,当然我们也可以自己手动在 workspace 的 .vscode 目录当中手动创建一个 tasks.json 文件. 文件创建完成之后按照下面的格式再创建 task 就行了:\n123456789101112131415&#123;  &quot;version&quot;: &quot;2.0.0&quot;,  &quot;tasks&quot;: [    &#123;      &quot;type&quot;: &quot;npm&quot;,      &quot;script&quot;: &quot;install&quot;,      &quot;problemMatcher&quot;: [],      &quot;label&quot;: &quot;npm: install&quot;,      &quot;detail&quot;: &quot;install dependencies from package&quot;    &#125;,    &#123;      // 其他的 task    &#125;  ]&#125;\n如上我们看到 tasks 列表当中可以有多个 task,每个 task 都用大括号包裹起来,每个大括号当中都是一个单独的 task,括号当中同时包含了这个 task 所有配置项.\ntask 的配置项多如牛毛,今天我就简单讲讲:\n","plink":"http://blog.lipanpanx.com/post/2021/202106/VSCode的task系统__/"},{"title":"VSCode中使用ESLint作为Vue文件的代码格式化工具","date":"2021-06-15T12:20:29.000Z","date_formatted":{"ll":"2021年6月15日","L":"2021/06/15","MM-DD":"06-15"},"updated":"2022-02-01T01:24:26.644Z","content":"很多前端项目都会使用eslint 去检查我们写的代码是否符合规范,但是这年头大家都很懒, 一般都会使用自动的代码格式化工具让自己的代码服务eslint的规范, 但我们使用自动的代码格式话工具免不了要配置, 针对不同的eslint配置要么是使用不同的formatter, 要么是使用同一formatter但是需要使用不同的配置去指定formatter的不同行为,说实话有点麻烦. 其实eslint 自己的 autofix 也很不错了, 可以再保存代码的时候让eslint自动执行autofix.\n下面我讲下 如何使用vscode中的 vscode-eslint插件在保存vue文件的时候自动格式化代码:\n其实非常简单,只需要在vscode的settings.json文件当中添加 如下几行就行了:\n123456&quot;[vue]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;,&#125;,&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true,&#125;\n当然这里也可以使用下面的配置,但是使用下面配置,如果你的项目当中还使用其他的formatter,需要先把其他的formatter 给disable掉,就比较霸道,不建议使用:\n1234&quot;eslint.format.enable&quot;: true,&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true,&#125;\n这里还有个需要注意的点就是,我们使用eslint作为格式化工具的时候,不能和 “editor.formatOnSave” 选项一起使用实现保存时自动格式化,只能和&quot;editor.codeActionsOnSave&quot;选项一起使用 才能实现保存的时候自动格式化.\n参考文档\n","plink":"http://blog.lipanpanx.com/post/2021/202106/VSCode中使用ESLint作为代码格式化工具/"},{"title":"VSCode 有趣的配置","date":"2021-06-15T09:57:15.000Z","date_formatted":{"ll":"2021年6月15日","L":"2021/06/15","MM-DD":"06-15"},"updated":"2022-02-01T01:24:26.644Z","content":"","plink":"http://blog.lipanpanx.com/post/2021/202106/VSCode-有趣的配置/"},{"title":"VSCode插件prettier-vscode使用说明","date":"2021-06-15T09:55:32.000Z","date_formatted":{"ll":"2021年6月15日","L":"2021/06/15","MM-DD":"06-15"},"updated":"2022-02-01T01:24:26.644Z","content":"参考文档\nprettier是一个不错的 代码格式化工具\nvscode 插件市场中提供了很多 prettier 相关的插件其中使用最多的莫过于官方开发prettier-vscode\n直接在vscode的插件市场中搜索 即可下载此插件\n插件是如何工作的\nprettier-vscode 想要工作 说到底最终还是需要调用 prettier的包, 这个prettier包可以是安装在你项目的 node_modules目录当中的本地依赖, 当然可以是全局安装的prettier包, 如果你既没有在项目中把prettier作为依赖安装也没有在全局安装prettier, 这个插件还有一个与它自身事先绑定好的某个特定的prettier版本.\n这里需要注意的是 如果想要此插件使用全局安装的 prettier 则需要 在vscode的 settings.json 当中设置 prettier.resolveGlobalModules 为true.\n另外使用项目本地依赖和全局prettier还有个好处就是可以使用 prettier plugins\n插件的配置\n在你安装插件的时候 你可以在插件的介绍页面的 feature contributions 选项卡当中可以看到这个插件 有一大堆的配置, 其实这些配置可以大致被分为2个部分: 一部分是插件自身配置(指定插件如何工作), 另外一部就是prettier的配置项(指定prettier如何格式化代码).\n其中插件自身配置选项有下面这些:\n123456789prettier.enable (default: true)prettier.requireConfig (default: false)prettier.ignorePath (default: .prettierignore)prettier.configPathprettier.prettierPathprettier.resolveGlobalModules (default: false)prettier.documentSelectorsprettier.useEditorConfig (default: true)prettier.withNodeModules (default: false)\nprettier的配置项有下面这些:\n123456789101112131415161718prettier.arrowParensprettier.bracketSpacingprettier.endOfLineprettier.htmlWhitespaceSensitivityprettier.insertPragmaprettier.jsxBracketSameLineprettier.jsxSingleQuoteprettier.printWidthprettier.proseWrapprettier.quotePropsprettier.requirePragmaprettier.semiprettier.singleQuoteprettier.tabWidthprettier.trailingCommaprettier.useTabsprettier.vueIndentScriptAndStyleprettier.embeddedLanguageFormatting\n\n这些配置项随时都会被改动 我列出的这些仅仅作为参考 更加准确的信息需要到 当前插件的 feature contributions 去查看(不过有时候这个也不准 还需结合插件文档声明进行查看的🤣)\n\n从上面的信息我们能够看出 在vscode的settings.json文件当中就能够设置所属有的 prettier选项了, 其实不仅仅可以在这里设置 prettier选项  可以在你项目当中放一个专门的prettier 配置文件去配置prettier选项,你也可以在.editorconfig 文件当中去配置prettier选项, 一旦你的项目当中拥有了本地的配置文件 vscode的settings.json当中 相关的prettier配置就会失效, vscoe的settings.json当中的prettier 配置一般情况下是作为备胎使用的, 只有在你的项目当中没有专门的prettier配置文件的时候这个备胎才能发挥作用.\n\n虽然项目的prettier配置可以放在很多地方 但是还是建议将prettier的配置保存在一个专门的prettier配置文件当中去, 因为只有在这种情况下才能保证一次配置多处使用, 如果你项目的prettier配置保存成一个单独的配置文件 你在vscode当中可以使用这个配置, 你可以在CLI当中使用这个配置, 你也可以在任何其他的支持prettier的IDE当中使用这个配置.\n\n这里还有个应用场景我需要说明一下就是: 如果你从网上clone了很多的项目, 每个项目当中都有自己的专门的prettier配置文件,但是这些配置文件当中的配置你不喜欢, 你想要应用自己的prettier配置, 但是很显然项目目录当中的配置文件拥有更高的优先级, 要想应用自己的配置好像也只能删改别人项目当中的配置文件, 但是如果项目比较多的情况下 一个个删改可真够难受的, 这里prettier-vscode插件为我们提供了一个贴心设置项 prettier.configPath 在vscode的settings.json当中可以通过\n这个配置项 指定一个默认的配置文件,指定完毕之后prettier0-vscode插件会优先使用这个配置文件, 就连项目目录当中的配置文件也要靠边站.\n插件的使用\n一系列配置完成之后就可以方便的使用这个插件了\n在vscode当中我们直接右键格式化代码的时候选择本插件作为格式化工具\n也可以打开命名面板 调用prettier相关命令使用该插件\n也可以 给这些命令 绑定一些快捷键使用\n也可以 配合 vscode 的保存时自动格式化 使用这个插件\n123456789&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,// 所有语言默认使用 prettier-vscode进行格式化&quot;[javascript]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;&lt;another formatter&gt;&quot;    // 这里排除js语言 设置js使用其他的格式化工具&#125;&quot;editor.formatOnSave&quot;: true,// 保存代码自动调用格式化工具\n1234567&quot;editor.defaultFormatter&quot;: &quot;&lt;another formatter&gt;&quot;,&quot;[javascript]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;    // 也可以配置成仅仅js语言使用 prettier-vscode 进行格式化&#125;,&quot;editor.formatOnSave&quot;: true,// 保存代码自动调用格式化工具\n","plink":"http://blog.lipanpanx.com/post/2021/202106/VSCode插件-prettier-vscode-使用说明/"},{"title":"在VSCode中为VueCLI创建的项目选择代码格式化工具","date":"2021-06-14T11:56:53.000Z","date_formatted":{"ll":"2021年6月14日","L":"2021/06/14","MM-DD":"06-14"},"updated":"2022-02-01T01:24:26.644Z","content":"\nvue cli几种格式化方案创建项目的区别\n选择不同的选项 会生成不同的 eslint配置  和 不同格式的代码\n在vscode当中  通过  formatOnSave 在保存代码的时候调用格式化器\n如果格式化器 格式化的结果和  当初选择的配置不同结果就会报错\n\n\n\n\n刚刚生成的代码是肯定能通过eslint检查的 一旦通过vscode进行格式化之后就不一定能通过检查了\n目前我已经知道的vue 文件代码格式化器 有3个\n\n其中vetur 和  prettier 其实是同一个, 可以很好的格式化 (eslint+prettier) 项目\nvetur 默认调用了 prettier,当然可以手动更改\n\n12345&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, //格式化.vue中html&quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, //让vue中的js按编辑器自带的ts格式进行格式化\nvolar 是另外一个  这个格式化工具\n可以很好的格式化 (eslint+standard config) 和 (eslint+airbnb config )的项目\n至于 (eslint with error prevention only) 项目 要求比较宽松 应该是几个格式化器都能够使用\nvue cli 创建项目几种格式化方案的蛋疼点\neslint+standard config\n123456const router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  base: process.env.BASE_URL,  routes&#125;)// 强制单引号, routes后面不允许有逗号, 最后一个小括号后面不允许有分号, 看起来有点蛋疼\neslint+prettier\n12345678910&lt;li&gt;  &lt;a    href=&quot;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-router&quot;    target=&quot;_blank&quot;    rel=&quot;noopener&quot;  &gt;    router  &lt;/a&gt;&lt;/li&gt;// &lt;a&gt;的所有属性必须分行显示, 太鸡儿蛋疼了\neslint+airbnb\n感觉就 airbnb的方案还算靠谱点\n","plink":"http://blog.lipanpanx.com/post/2021/202106/在VSCode中为VueCLI创建的项目选择代码格式化工具/"},{"title":"VSCode 控制Markdown文件软换行","date":"2021-06-12T12:05:55.000Z","date_formatted":{"ll":"2021年6月12日","L":"2021/06/12","MM-DD":"06-12"},"updated":"2022-02-01T01:24:26.644Z","content":"在vscode当中 我们在为代码设置软换行的时候一般会在 settings.json 当中设置下面2个配置项\n\n12&quot;editor.wordWrap&quot;: &quot;wordWrapColumn&quot;,&quot;editor.wordWrapColumn&quot;: 90,\n如上所示我们设置了这2个配置项之后 编辑器当中的代码确实能够在 第90个字符位置软换行, 但是markdown文件中的文字却不能在这个位置 进行软换行 解决方法如下:\n1234&quot;[markdown]&quot;:&#123;    &quot;editor.wordWrap&quot;: &quot;wordWrapColumn&quot;,    &quot;editor.wordWrapColumn&quot;: 90,&#125;,\n我们把这2个设配置项写到 针对markdown语言的专门配置里面就好了\n因为 vscode 针对不同的语言会有不同的默认配置,如果我们仅仅把这些配置写为一般配置的话, 这个一般配置会被vscode  针对  markdown的 一些默认配置给覆盖, 但是我们如果针对markdown语言做了专门配置的话,这个专门配置拥有更高的优先级 会把 vscode 的默认配置覆盖掉 从而达到我们的指定需求.\n","plink":"http://blog.lipanpanx.com/post/2021/202106/VSCode-控制Markdown文件软换行/"},{"title":"webpack-cli init 命令","date":"2021-05-26T10:11:28.000Z","date_formatted":{"ll":"2021年5月26日","L":"2021/05/26","MM-DD":"05-26"},"updated":"2022-02-01T01:24:26.644Z","content":"webpack-cli init\nwebpack-cli 是webpack的命令行工具, 如果你安装了webpack-cli 就可以通过webpack-cli init 命令快速的初始化一个包含指定webpack配置的项目.\n要想使用首先安装:\n1npm install --save-dev webpack webpack-cli @webpack-cli/generators\n安装完成之后可以通过 npx 运行\n12345npx webpack-cli init [generation-path] [options]// options:-t, --template (string = &#x27;default&#x27;)  // 指定模板 一般使用默认模板-f, --force (boolean) // 所有命令行选项使用默认值 \n如果不添加任何参数 直接在命令行执行webpack-cli 则进入手动配置模式, webpack-cli会给出一些问题,我们通过简单的键盘操作回答问题, 然后webpack-cli会根据我们的答案 解析出我们想要使用的webpack配置, 然后根据这个webpack配置初始化项目. 下面在手动模式下我们需要去回答的问题(问题的数量会根据我们的不同选择有所增减):\n12345678// 消极选配? Which of the following JS solutions do you want to use? none? Do you want to use webpack-dev-server? No? Do you want to simplify the creation of HTML files for your bundle? No? Do you want to add PWA support? No? Which of the following CSS solutions do you want to use? none? Do you like to install prettier to format generated configuration? No? Pick a package manager: npm\n1234567891011//积极选配? Which of the following JS solutions do you want to use? ES6? Do you want to use webpack-dev-server? Yes? Do you want to simplify the creation of HTML files for your bundle? Yes? Do you want to add PWA support? Yes? Which of the following CSS solutions do you want to use? SASS       ? Will you be using CSS styles along with SASS in your project? Yes? Will you be using PostCSS in your project? Yes? Do you want to extract CSS for every file? Yes? Do you like to install prettier to format generated configuration? Yes? Pick a package manager: npm\n","plink":"http://blog.lipanpanx.com/post/2021/202105/webpack-cli-init/"},{"title":"webpack5 初体验","date":"2021-05-20T07:29:21.000Z","date_formatted":{"ll":"2021年5月20日","L":"2021/05/20","MM-DD":"05-20"},"updated":"2022-02-01T01:24:26.644Z","content":"webpack official site\n0x10 为什么需要webpack\n在我们开发前端项目的时候会使用各种技术, 这些技术对于项目的开发,调试,维护 都至关重要. 在写css的时候会用到各种 css preprocessor:比如 sass scss less stylus. 在写js的时候会用到 es6语法 和 ts 还有对于commonjs 和 es module 两种模块化方案. 但是这些代码, 是无法被浏览器所识别的, 或者说无法被所有的浏览器所识别,这是个重要的问题.在项目上线之前必须对代码进行处理达到上线要求,当然有很多的小工具可以解决问题. 但是Webpack是个大而全的工具,他会尽可能的解决你所有的问题,实现程序员舒爽的开发体验\n0x20 webpack安装和基本使用\nwebpack安装\nwebpack全局安装和局部安装如果是全局安装 可以使用命令:\n1npm install webpack -g \n如果是局部安装则可以在项目的根目录执行:\n1npm install webpack \n全局安装和局部安装各有各的好处,但是在项目中我还是建议进行局部安装.因为如果你使用的是全局安装的方式,你打包也使用全局的webpack进行打包, 当你的同事clone你的项目的时候,他并不确定你的webpack版本是什么版本,有时候就会造成麻烦,但是如果你是局部安装的化 同事打开你的项目 执行 npm install 之后, 只需要 执行 npx webpack 就可以使用与这个项目相关联的版本进行打包操作, 确保团队内部所有成员的 webpack版本都是一致的\nwebpack配置文件\nwebpack默认配置文件名称和位置在webpack安装完成之后, 我们就可以在项目当中创建一个webpack配置文件来指导 webpack的打包行为了:\n本来从 webpack4 开始所有的 配置都可以在执行webpack命令的时候以参数的形式传递, 但是很显然 使用配置文件更加的高效. 在我们执行webpack命令的时候如果后面没有跟任何参数, CLI会按照下面的顺序寻找默认配置文件(优先级递增):\n1.webpack/webpackfile.js &gt; .webpack/webpack.config.js &gt; webpack.config.js\n从上我们可以看出CLI会首先去根目录下的 .webpack目录下寻找配置文件然后才去到根目录下面寻找配置文件, 但是他们的优先级递增,也就是说如果项目根目录下面如果存在默认配置文件(webpack.config.js),则项目根目录中的默认配置文件的优先级在所有默认配置文件当中是最高的.\n当然除了使用默认配置文件之外webpack 也可以通过--config 选项强行指定一个配置文件.\nwebpack配置文件是一般情况下是js文件(也可以是ts或coffee等文件类型), 我们可以手动写成如下格式(当然也可以使用webpack init生成):\n12345/**@type &#123;import(&#x27;webpack&#x27;).Configuration&#125; */const config = &#123;    // webpack 配置项&#125;module.exports = config;\n在webpack的配置文件当中我们可以进行一系列的配置,并通过module.exports进行导出,下面我会讲下webpack的一些常见配置项.\nwebpack打包中的几个基本概念\nchunk and bundlebundle: 由多个不同的module生成, bundle中包含了已经经过loading和compilation处理的最终源文件.bundle文件就是最终部署到服务器上的文件.\nchunk: chunk 在webpack打包过程中处理文件捆绑过程, webpack中的bundle就是由chunk组成的 ,通常情况下 chunk和bundle是1:1对应的,但是在某些特定配置下却不是这样的,比如当你为了方便调试通过特定的设置为源文件生成单独的map文件时,这个时候chunk和bundle的关系就是1:2.\ndependency graph: 在我们的项目中一个文件会依赖另外一个文件或者多个文件,这种依赖关系需要被系统的描述从而确保webpack能够有效的包含所有你的程序需要的module/asset.这种系统的依赖关系描述就是依赖图.\nentry point: webpack为你的程序构建依赖图需要一个起始点,这个起始点就是entry point.一般情况下就是一个文件也叫做入口文件.\ncode splitting: 把你的代码分割称为多个 bundle/chunk 然后就可以按需加载了而不需加载包含很多内容的一整个单独的bundle.\nbundle splitting: 优化构建,bundle分割允许webpack为单个程序生成多个bundle, 并且他们的关系是相对独立的,相互之间不会有太多的影响, 分成多个相互独立的文件可以增加并行加载的速度, 而且需要重新发布的时候可以只更新需要更新的文件充分的利用浏览器的缓存减少客户端的下载量.\n一篇不错的相关文章\nwebpack配置文件中的详细配置项\nwebpack configuration\nwebpack配置选项 entry 和 context在webpack配置文件当中我们需要通过配置项entry去指定一个webpack打包的入口文件,这个入口文件 就是webpack构建bundle 的起始点.\nentry选项可以被赋予的合法值有4中类型:\n\nstring\n[string]\nobject = {\n string |\n[string] |\nobject = { import string | [string], dependOn string | [string], filename string, layer string }\n}\nfunction() =&gt; string |\n[string] |\nobject = {  string | [string] } |\nobject = { import string | [string], dependOn string | [string], filename string }\n\n如果给定的值是一个表示文件路径的字符串, webpack会找到该文件并且作为入口文件\n如果给定的值是一个包含多个路径字符串的数组,webpack会同时将这多个文件作为入口文件,但是位于数组内的文件会被打包到一起形成同一个bundle\n如果给定的值是一个对象就可以生成多个bundle,对象的key对应的是生成的bundle的名字,对象的value的值 可以是字符串,字符串数组 或者是一个descriptor对象. descriptor对象提供了更多的可选项用来配置入口文件,更加详细的内容可以参考官方的文档.\n如果给定的值是一个函数,则这个函数可以返回 如上的 字符串 字符串列表和对象\n在我们配置entry选项指定入口文件的时候一般情况下使用的是相对路径,这个相对路径是使用当前工作目录作为根路径进行解析的, 其实我们有可以通过 context 选项去人为的指定一个根路径, 此时解析 入口文件的相对路径就是从context指定的路径开始解析的.\nwebpack配置选项 outputoutput配置项是webpack配置当中的一个顶级key,它的值是一个对象,这个对象当中又包含了很多的选项,这些选项决定了, 你如何输出 bundles, assets,以及其他你的项目当中需要打包或者加载的内容.\noutput下面的配置项挺多的 我简单讲几个常用的配置项:\noutput.filename: 它的值是一个字符串或者返回字符串的函数用来指定输出的bundle的名字\noutput.path: 它的值是一个绝对路径用来指定输出的目录\noutput.publicPath:\noutput.chunkFilename:\noutput.library:\noutput.libraryTarget:\nwebpack配置选项 modulewebpack的 module选项是一个相当复杂的选项,它也是一个顶级key,它的值是一个对象这个对象当中包含了很多的子选项,这些子选项一起配置了webpack在遇到不同的文件的时候使用什么样的loader 去对文件执行预处理操作.\n这里的loader就是文件的预处理工具.\nwebpack配置选项 resolvewebpack配置选项 devServer当我们在开发一个项目的时候 往往需要多次编译我们的代码, 如果每次都是手动操作会让人感觉很烦, 所以webpack就提供了多种方式帮助开发者在文件发生变动的时候自动取编译代码,直接展示代码更改的结果,  使用 webpack-dev-server就是这其中的一种方式.要想使用 webpack-dev-server需要先安装相应的包:\n1npm install --save-dev webpack-dev-server\n然后再webpack的配置文件中添加 devServer 配置项,这个配置项的值是一个对象,对象当中包含了很多子配置项,通过这些子配置项我们就能方便的配置 webpack-dev-server的各种行为了,下面会详细讲.\n然后通过CLI命令就能让 webpack-dev-server 运行起来:\n1npx webpack serve\ndevServer的子配置项众多,我这里就讲几个常用的配置项:\nwebpack配置选项 optimization","plink":"http://blog.lipanpanx.com/post/2021/202105/webpack5初体验/"},{"title":"codesandbox为创建好的项目增加terminal","date":"2021-05-12T09:38:42.000Z","date_formatted":{"ll":"2021年5月12日","L":"2021/05/12","MM-DD":"05-12"},"updated":"2022-02-01T01:24:26.644Z","content":"一般情况 下 我们在 codesandbox 中创建的项目是不带 terminal的\n比如我们通过官方的 vue2模板创建的项目 就是不带terminal 的\n但是当我们项目创建完成之后 又想要terminal 怎么办呢?\n其实有个不错的方法就是 通过 sandbox.config.json 文件去控制\n假如 我们已经有个创建好的 vue项目了  那么我们在这个vue项目当中添加一个 sandbox.config.json 文件 并且在文件当中加入下面一行:\n123&#123;    &quot;template&quot;: &quot;node&quot;&#125;\n然后把 把更改提交到 自己的github仓库\n然后我们再重新 创建创建一个新的容器  从刚才的github仓库fork代码/导入代码  就行了\n这样创建出来的vue项目就是带terminal\n但是有些人在创建的时候会出现报错 比如: 502: Bad Gateway\n一般情况下  按照报错提示修改下配置文件之类的 重新搞下就能成功了, 我第一次弄就报错了 然后我修改了下 babelrc文件重新弄就成功了 效果如下:\n\n我们刚进入的时候仅仅又一个可读的terminal 我们点击右侧的加号 增加一个自己可读写的terminal 就行了\n可以在这里面使用 linux命令(其环境就是一个ubuntu容器) 安装卸载依赖等等…\n另外 项目左侧的导航栏 也会增加一个新的选项卡:\n\n","plink":"http://blog.lipanpanx.com/post/2021/202105/codesandbox创建带terminal项目/"},{"title":"codesandbox编辑器自动回车bug","date":"2021-05-11T09:05:37.000Z","date_formatted":{"ll":"2021年5月11日","L":"2021/05/11","MM-DD":"05-11"},"updated":"2022-02-01T01:24:26.644Z","content":"codesandbox 的编辑器中默认情况下是手动保存代码的\n本来也没什么 但是 用的时间长了之后 发现手动保存还是挺烦的\n因为 是基于 vscode 的 编辑器 所以可以在 settings.json 当中设置自动保存代码\n1234&#123;  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,  &quot;files.autoSaveDelay&quot;: 500&#125;\n但是我设置完成自动保存代码之后 却出现了一个非常蛋疼的问题\n就是 你如果在编辑器当中输入空白字符之后如果没有立即输入非空白字符 编辑器在自动保存的时候会认为这些空白字符无用而删除这些空白字符 光标自动回车到行首,就像下面这样:\n\n用google 查了半天 就是没发现 有人去解决这个问题 实在是很苦恼\n正在我苦恼的时候突然想起来 codesandbox 是基于vscode的在线编辑器\n这个可能是vscode 某个版本的一个bug  然后 codesandbox 用来这个版本的vscode 所以我可以从vscode 去下手\n果不其然 经过搜素我发现 vscode 在2018年11月的时候出现过一个bug 就是自动保存设置为 afterDelay 的时候会出现上述bug\n然后只要把 files.autoSave的值改成其他的值 就可以避免这个bug出现了\n12345&#123;    // &quot;files.autoSave&quot;: &quot;afterDelay&quot;, // 不能用这个选项 afterdelay 会让editor出现bug    // &quot;files.autoSaveDelay&quot;: 500,    &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,&#125;\n真没想到 vscode 18年的一个bug codesandbox 到现在还有\n除了这个bug之外 我还发现 codesandbox 还有其他的各种乱七八遭的小 bug 不会太影响使用 但是着实有点蛋疼\n","plink":"http://blog.lipanpanx.com/post/2021/202105/codesandbox编辑器自动回车bug/"},{"title":"Vue CLI 使用","date":"2021-03-12T11:22:09.000Z","date_formatted":{"ll":"2021年3月12日","L":"2021/03/12","MM-DD":"03-12"},"updated":"2022-02-01T01:24:26.644Z","content":"vue cli 是创建vue项目比较常用 工具本文主要记录下 通过 vue create 命令和 vue ui命令创建项目 的过程和他们之间的不同:\n通过 vue create 命令创建项目(手动配置)\n\n\n\n\n\n\n\n\n\n\n通过 vue ui命令创建项目(手动配置)\n首先开启服务\n\n\n服务开启后默认浏览器会自动打开这个页面\n\n我们点击中间的创建 按钮就可以创建项目了\n\n\n\n\n\n按照上面的 创建手动配置项目的 流程 等待项目创建完成之后 浏览器会自动跳转到 项目主页, 在这里可以查看cli插件 项目依赖, 配置VueCLI ESLint 和 执行相关的 npm命令\n\n从上面的流程我们可以看出 使用 vue create 创建项目和使用 vue ui创建项目的流程几乎一摸一样, 使用vue create 虽然快捷方便 但是用vue ui 似乎同样是一个不错的选择.\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vue-CLI-使用/"},{"title":"VueRouter的路径匹配引擎介绍","date":"2021-03-08T16:45:53.000Z","date_formatted":{"ll":"2021年3月8日","L":"2021/03/08","MM-DD":"03-08"},"updated":"2022-02-01T01:24:26.644Z","content":"今天闲的蛋疼 打算讲讲 VueRouter的路径匹配引擎\n这玩意是 github的一个开源项目 github 仓库地址\n\n","plink":"http://blog.lipanpanx.com/post/2021/202103/VueRouter路径匹配引擎/"},{"title":"VueRouter基本使用","date":"2021-03-05T18:35:48.000Z","date_formatted":{"ll":"2021年3月5日","L":"2021/03/05","MM-DD":"03-05"},"updated":"2022-02-01T01:24:26.644Z","content":"VueRouter基本使用步骤\n\n导入Vue Router (VueRoute.js的导入语句要放在Vue.js导入语句的下面)\n写好需要被路由的组件 并且成功注册组件\n使用new VueRouter(&#123;&#125;)创建路由对象的实例,并且在路由对象的routes选项当中添加路由规则\n将路由对象挂载到Vue实例中\n&lt;router-view&gt;&lt;router-view&gt;在页面当中占坑,被路径匹配到的组件会被渲染到这个坑位当中.\n&lt;router-link&gt;&lt;/router-link&gt;会被渲染成为导航链接, 导航到指定组件.\n\nVueRouter的下载和引入\nVueRouter 3.x github仓库地址\nVueRouter 4.x github仓库地址\nVueRouter 3.x 英文文档\nVueRouter 4.x 英文文档\nVueRouter 3.x 中文文档\nVueRouter 4.x 中文文档\n在项目当中使用VueRouter的方式有很多种,我讲一下最简单的一种:\n到github仓库的release页面下载相应的版本然后找到dist目录找到对应的源文件复制到自己的工作目录然后在自己的项目当中引用即可,需要注意的是在引入 vue-router.js之前需要先引入 vue.js\n组件准备\n在创建VueRouter实例之前需要创建好需要的组件,如果在创建VurRouter实例之后创建组件会导致创建VueRouter实例的时候无法找到路由规则相关的组件而报错,如果是局部组件还需要在对应的Vue实例当中注册组件.\nVueRouter实例的创建\n我写了一个快速创建VueRouter实例的vscode snippet:\n123456789101112&quot;newVueRouter&quot;:&#123;    &quot;prefix&quot;: &quot;newVueRouter&quot;,    &quot;body&quot;: [        &quot;const router = new VueRouter(&#123;&quot;,        &quot;    routes:[&quot;,        &quot;        $0&quot;,        &quot;    ],&quot;,        &quot;    linkActiveClass:&#x27;actived-link&#x27;,&quot;,        &quot;&#125;);&quot;,    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n这个snippet 不仅仅可以快速的创建VueRouter实例 并且已经指定好了默认的linkActiveClass的名字, 这个所谓的linkActiveClass就是当组件被选中的时候这个组件上会被添加一个类名, 我们可以通过这个类名控制当前被选中组件的的一些样式之类的. 然后你还可以在创建完成 VueRouter实例之后直接在 routes 当中填写路由规则,简直不要太方便.\n&lt;router-view&gt;和&lt;router-link&gt;\n&lt;router-view&gt; 也是一个组件 这个组件会被渲染成 路径匹配到的组件.\n比如路径 http://127.0.0.1:5500/5565_test/5576_VueRouter.html#/User/44 如果你在VueRouter的路由规则当中添加了一套匹配User的规则 &#123;path: '/User/:id', component: User,&#125; 那么这条路径就会被匹配, User组件就会被渲染到页面的指定位置, 这个位置是由&lt;router-view&gt;决定, 这个东西和插槽非常的像.\n就像插槽有匿名插槽和具名插槽之分 &lt;router-view&gt; 也分有名字和无名子的&lt;router-view&gt;, 名字通过name属性去定义&lt;router-view name='xxx'&gt;&lt;/router-view&gt;同时 name属性也是 &lt;router-view&gt;组件唯一的自带属性. 通过为&lt;router-view&gt;添加name属性我们就可以在网页中添加名字各异的多个&lt;router-view&gt;了,然后配合路由规则就可以把不同名字的&lt;router-view&gt;渲染成为不同的组件.\n&lt;router-view&gt; 还有个比较棒的特性就是嵌套, 当我们把页面当中的某个&lt;router-view&gt;渲染成某个组件之后,这个组件当中仍然可以存在新的&lt;router-view&gt;,这个新的&lt;router-view&gt;可以渲染为当前组件的子组件.\n\n我们可以直接把组件写在页面当中,也可以用&lt;router-view&gt;显示组件,然后通过路径地址导航到我们的组件, 我们可以直接在浏览器的网址栏当中输入这个地址,我们也可以网页当中添加链接或者按钮导航到这个地址, 这个时候就需要使用 &lt;router-link&gt;了. 相关文档\n&lt;router-link&gt; 同样是一个组件, 这个组件在页面当中导航用的,通过 to 属性指定目标地址,在页面当中默认渲染成带有正确链接的 &lt;a&gt; 标签. &lt;router-link&gt; 除了to属性之外还有很多的属性可以设置:相关文档地址\n&lt;router-link&gt;的首要任务当然是导航, 但是在导航的时候它也可以提供query参数和 params参数\n12&lt;router-link to=&quot;/one?name=lnj&amp;age=33&quot; tag=&quot;button&quot;&gt;导航到路径/one &lt;/router-link&gt;&lt;router-link to=&quot;/two/zs/66&quot; tag=&quot;button&quot;&gt;导航到路径/two/zs/66 &lt;/router-link&gt;\n路径当中提供的参数 会被存储到$route当中 我们可以在被匹配到的组件内通过  拿到相关的数据. 更多关于$route的文档\n\n添加各种形式的组件路由规则\n&lt;router-view&gt; 可以被渲染成为组件,&lt;router-link&gt;可以被渲染成为链接导航到指定的组件, 而VueRouter的路由规则就是这二者之间的桥梁, 路由规则规定了什么样的链接导航到什么样的组件.\n在我们创建VueRouter实例的时候,有很多可选的构建选项:见文档,而这些构建选项当中的routes选项就是我们指定路由规则的地方, routes选项的值是一个数组,这个数组当中存放着 &lt;RouteConfig&gt;类型的路由规则.\n&lt;RouteConfig&gt;的类型定义如下:\n12345678910111213141516interface RouteConfig = &#123;  path: string,     //相对路径  component?: Component,    //和路径对应的组件  name?: string,    // 命名路由  components?: &#123; [name: string]: Component &#125;, // 命名视图组件  redirect?: string | Location | Function,  //重定向路由  props?: boolean | Object | Function,      //解耦  alias?: string | Array&lt;string&gt;,           //路由别名  children?: Array&lt;RouteConfig&gt;,            //嵌套路由  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void,  meta?: any,  // 2.6.0+  caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false)  pathToRegexpOptions?: Object // 编译正则的选项&#125;\n对于各种形式的路由为了方便理解 下面有一些简单的例子:\n一般路由\n1234567const router = new VueRouter(&#123;    routes: [        &#123;path:&#x27;/one&#x27;,component:one,&#125;,        &#123;path:&#x27;/two&#x27;,component:two,&#125;,    ],&#125;);// 只需要填写路径和对应的组件,访问路径就能显示对应的组件\n动态路由\n1234567const router = new VueRouter(&#123;    routes: [        &#123; path: &#x27;/User/:id&#x27;, component: User, &#125;,    ],&#125;);// 通过动态路径参数, 可以允许不同的用户都能够匹配到 /User/:id 然后都使用User组件// 然后这个id的值是可以在会被存储在路由对象当中  在组件模板中可以使用 this.$route.params.id 获取 \n命名路由\n12345678const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/user/:userId&#x27;, name: &#x27;user&#x27;, component: User &#125;    // 通过 name字段可以为路由添加名字 然后我们可以通过这个名字来使用这个路由    // &lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;    // 上面这个 &lt;router-link&gt; 默认情况下会被渲染成为&lt;a&gt; 链接 指向  /user/123     ]&#125;)\n重定向路由\n1234567891011121314151617181920212223242526const router = new VueRouter(&#123;    routes: [      &#123;path:&#x27;/&#x27;,redirect:&#x27;/one&#x27;&#125;  // 访问根地址 的时候URL重定向到 /one 然后显示one组件       &#123;path:&#x27;/one&#x27;,component:one,&#125;,      &#123;path:&#x27;/two&#x27;,component:two,&#125;,    ],&#125;);const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/foo&#x27;,name:&#x27;foo&#x27;,component:foo&#125;    &#123; path: &#x27;/a&#x27;, redirect: &#123; name: &#x27;foo&#x27; &#125;&#125;     // 重定向的目标也可以是一个命名的路由,     // 当你访问/a的时候  URL会被重定向到/foo 然后显示foo组件    // 当你访问/foo的时候 正常显示   ]&#125;)// redirect 也可以接收一个函数const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, redirect: to =&gt; &#123;      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    &#125;&#125;  ]&#125;)\n路由别名\n123456789const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, component: A, alias: &#x27;/b&#x27; &#125;    // 为路径/a 创建别名 /b,     // 就是说当你访问/a的时候 正常显示    // 当你访问/b的时候 URL会保持不变 但是路由会匹配到 /a相关的路由  ]&#125;)// 重定向的时候URL发生改变然后按照新URL匹配路由  路由别名URL不会发生变化按照相关联的别名匹配路由  \n嵌套路由\n1234567891011121314const router = new VueRouter(&#123;    routes: [      &#123;        path: &#x27;/User/:id&#x27;, component: User,        // 访问 /User/:id 显示User组件 并且User组件当中会显示它的子组件         children: [          // 访问 /User/:id/UserProfile 会在User组件当中 显示User的子组件 UserProfile           &#123; path: &#x27;UserProfile&#x27;, component: User.components.UserProfile, &#125;,          &#123; path: &#x27;UserPosts&#x27;, component: User.components.UserPosts, &#125;,          // 访问 /User/:id/UserPosts 会在User组件当中显示 User的子组件UserPosts        ],      &#125;,    ],&#125;);\n命名视图相关的路由\n12345678910111213141516const router = new VueRouter(&#123;    routes: [        &#123;            path: &#x27;/xxx&#x27;,            components: &#123;                default: test,                first: one,                second: two,            &#125;,            //某个目录/xxx 下一共三个 &lt;router-view&gt;            // 第一个没有name属性 显示为 test组件, default 为匿名&lt;router-view&gt; 指定组件            // 第二个 name为 first 显示组件one            // 第三个 name为 second 显示组件two         &#125;,    ],&#125;);\n","plink":"http://blog.lipanpanx.com/post/2021/202103/VueRouter基本使用/"},{"title":"Vue生命周期钩子","date":"2021-03-05T11:03:32.000Z","date_formatted":{"ll":"2021年3月5日","L":"2021/03/05","MM-DD":"03-05"},"updated":"2022-02-01T01:24:26.644Z","content":"Vue生命周期钩子是Vue开发者为Vue使用者预留的接口,使用这些接口我们能够在Vue生命周期的各个阶段做一些灵活的数据控制,来达到一些不可告人的目的.\n生命周期钩子的使用\n在我们创建Vue实例的时候,需要提供一个对象,这个对象包括创建Vue实例的各种Options, Vue生命周期钩子是这些Options的一部分, 他们的值都是函数,当Vue实例到达某个生命周期后,就会尝试去调用这些生命周期对应的钩子函数. 对于Vue2.x而言目前已知的钩子函数包括下面11个:\n12345678910111213141516&lt;script&gt;    let vue = new Vue(&#123;        el: &#x27;#app&#x27;,        beforeCreate() &#123; &#125;,        created() &#123; &#125;,        beforeMount() &#123; &#125;,        mounted() &#123; &#125;,        beforeUpdate() &#123; &#125;,        updated() &#123; &#125;,        activated() &#123; &#125;,        deactivated() &#123; &#125;,        beforeDestroy() &#123; &#125;,        destroyed() &#123; &#125;,        errorCaptured() &#123; &#125;,    &#125;);&lt;/script&gt;\nbeforeCreate\n\n在调用beforeCreate的时候, 仅仅表示Vue实例刚刚被创建出来, 此时此刻还没有初始化好Vue实例中的数据和方法, 所以此时此刻还不能访问Vue实例中保存的数据和方法\n\ncreated\n\n在调用created的时候, 是我们最早能够访问Vue实例中保存的数据和方法的地方\n\nbeforeMount\n\n在调用beforeMount的时候, 表示Vue已经编译好了最终模板, 但是还没有将最终的模板渲染到界面上\n\nmounted\n\n在调用mounted的时候, 表示Vue已经完成了模板的渲染, 表示我们已经可以拿到界面上渲染之后的内容了\n\nbeforeUpdate\n\n在调用beforeUpdate的时候, 表示Vue实例中保存的数据被修改了\n注意点: 只有保存的数据被修改了才会调用beforeUpdate, 否则不会调用\n注意点: 在调用beforeUpdate的时候, 数据已经更新了, 但是界面还没有更新\n\nupdated\n\n在调用updated的时候, 表示Vue实例中保存的数据被修改了, 并且界面也同步了修改的数据了\n也就是说: 数据和界面都同步更新之后就会调用updated\n\nactivated\n\nkeep-alive 缓存的组件激活时会调用activated\n\ndeactivated\n\nkeep-alive 缓存的组件停用时会调用deactivated\n\nbeforeDestroy\n\n在调用beforeDestroy的时候, 表示当前组件即将被销毁了\n注意点: 只要组件不被销毁, 那么beforeDestroy就不会调用,beforeDestroy函数是我们最后能够访问到组件数据和方法的函数\n\ndestroyed\n\n在调用destroyed的时候, 表示当前组件已经被销毁了\n注意点: 只要组件不被销毁, 那么destroyed就不会调用, 不要在这个生命周期方法中再去操作组件中数据和方法\n\nerrorCaptured\n\n捕获一个来自子孙组件的错误时会调用errorCaptured\n\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vue生命周期/"},{"title":"Vuex基本使用","date":"2021-03-04T18:36:59.000Z","date_formatted":{"ll":"2021年3月4日","L":"2021/03/04","MM-DD":"03-04"},"updated":"2022-02-01T01:24:26.644Z","content":"0x10 Vue子组件之间数据传递\n在vue当中 同一个父组件下的子组件之间进行数据传递是非常蛋疼的,子组件之间并不能够直接传递数据,想要传递数据就需要首先将一方的数据通过函数传递给父组件, 然后在父组件中再把这个数据传递给另一方,如果组件的层级比较深,这样的操作可以说是非常麻烦了.\n0x20 Vuex的基本使用\nvuex官方github仓库地址    // vuex的3.x版本和4.x版本是在同一个仓库当中release的\nvuex 3.x 英文文档地址\nvuex 3.x 中文文档地址\nvuex 4.x 英文文档地址\nvuex 4.x 中文文档地址\n要想使用vuex 首先下载和引入vuex, 在官方github的release页面可以下载对应版本的vuex,下载好压缩包并解压之后,打开dist目录就能找到我们需要的vuex.js,把这个vuex.js引入到我们的项目当中就行了,不过需要注意的是 在引入vuex.js之前一定要先引入vue.js.\n上面我也说到了, vue的子组件之间传递数据还是非常蛋疼的,显然 vuex就是来解决这个问题的,那么如何使用vuex在子组件之间传递数据呢,其实也非常的简单:\n首先通过new Vuex.Store(&#123;&#125;)创建一个Store实例 并传递一个包含所需options的对象,这个对象中有个state字段里面包含了需要在子组件当中传递的数据,比如:\n12345const store = new Vuex.Store(&#123;    state: &#123;        count:0    &#125;,&#125;)\n然后我们把实例 store 挂在到父组件当中的store字段\n最后就能够在子组件当中操作count了,操作的方式也非常简单 直接通过this.$store.state.count就能操作这个count的值了\n但是这样直接操作的方式还是存在问题的,如果多个组件都去操作这个变量的时候,如果这个变量的值出现了问题你很难去判定到底是哪个组件的错误操作导致的,所以对于store.state当中的数据的公共操作可以提取出来,在创建Store实例时提供给 mutations 选项.具体代码如下:\n12345678910111213const store = new Vuex.Store(&#123;    state: &#123;        count:0    &#125;,    mutations: &#123;        add(state)&#123;            state.count++;        &#125;,        sub(state)&#123;            state.count--;        &#125;    &#125;,&#125;)\n在上述代码当中我们可以看到,在mutations当中我们低通了对count进行自增和自减的函数,我们想要在子组件中调用这个函数的时候只需要通过this.$store.commit(&quot;函数名字&quot;) 就行了,当然我们在调用函数的时候还可以传递参数,这个参数就是mutation的载荷(payload) this.$store.commit(&quot;函数名字&quot;,payload) 这个payload参数可以就是一般的参数也可以是一个对象,当然我们在mutation的对应函数里面接收这个payload就能正常使用了.\n除了使用this.$store.commit(&quot;函数名字&quot;) 的方式调用mutations当中的函数外还可以通过下面的方式调用:\n1234567891011this.$store.commit(&#123;    type:&quot;函数名字&quot;,    xxx:xxx,&#125;),------------------------------------------------------------------//  当commit接收到是一个对象的时候,mutation中对应的函数操作保持不变mutations: &#123;  函数名字 (state, payload) &#123;    state.count += payload.xxx  &#125;&#125;\n另外store也是支持计算属性的,这个计算属性和computed是差不多的,在创建Store实例的时候在提供的对象当中提供getters选项,这个getters选项当中的函数的返回值会被缓存起来,且只有当它的依赖值发生了改变才会被重新计算。\n1234567891011const store = new Vuex.Store(&#123;    state: &#123;        msg:&quot;lipanpanx.com&quot;,    &#125;,    getters: &#123;        test(state) &#123;            console.log(&quot;调用getter当中的test函数&quot;);            return state.msg+&quot;真不错&quot;;        &#125;    &#125;,&#125;)\n在getters当中提供了计算属性之后,访问这个属性也非常的简单,首先将store绑定到组件是必须的,然后在组件当中使用this.$store.getters.test 就能访问你的计算属性了\n当然如果你也可以让getters中的函数返回另外一个方法,这样以来就方便传参, 但是你返回的这另一个方法会被缓存起来, 方法毕竟不是一个固定的值,所以这个方法每次都会被重新调用来获取结果:\n123456789101112131415161718const store = new Vuex.Store(&#123;    state: &#123;        msg: &quot;lipanpanx.com&quot;,        xlist: [&quot;x&quot;,&quot;xx&quot;,&quot;xxx&quot;,&quot;xxxx&quot;],    &#125;,    getters: &#123;        test(state) &#123;            console.log(&quot;调用getter当中的test函数&quot;);            return state.msg + &quot;真不错&quot;;        &#125;,        testf(state)&#123;            return (id) =&gt; &#123;                console.log(&quot;这个方法每次都会被重新调用&quot;);                return state.xlist[id]            &#125;        &#125;    &#125;,&#125;)\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vuex基本使用/"},{"title":"Vue2组件化","date":"2021-03-03T10:56:47.000Z","date_formatted":{"ll":"2021年3月3日","L":"2021/03/03","MM-DD":"03-03"},"updated":"2022-02-01T01:24:26.644Z","content":"组件化的意义\n自定义组件\n自定义一个组件方法有很多,但是背后的创建逻辑却大同小异,有三个核心要素是必须的:\n1&gt;组件构造(传递给构造器的组件模板只能有一个根元素)\n2&gt;组件注册\n3&gt;组件使用\n基于上面的三个核心要素诞生了好多创建组件的方式,下面我简单介绍一下我使用vscode snippets创建组件的过程:\n创建全局组件\n1234567891011&quot;Vue.component&quot;: &#123;    &quot;prefix&quot;: &quot;Vue.component&quot;,    &quot;body&quot;: [        &quot;Vue.component(&#x27;$&#123;1:组件名称&#125;&#x27;, &#123;&quot;,        &quot;    template:&#x27;#$&#123;1:组件模板id&#125;&#x27;, //$&#123;0:&lt;template id=&#x27;$&#123;1:组件模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:组件根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,components:&#123;&#125;,&quot;,        &quot;&#125;);&quot;,    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n全局组件注册需要用到Vue.component(id,[definition])函数,我们可以向这个函数提供 组件名称和组件对象来 注册组件\n当我们传递组件对象的时候 Vue.component()会自动帮助我们使用Vue.extend()构造组件\n上面的这段代码能够帮助用户迅速的注册一个全局组件,在用户输入组件名称之后,snippets会根据输入的名称自动生成用于构造组件的组件对象和组件模板(第5行注释就是模板),然后用户只需要剪切模板到合适的位置就行了, 注册组件和组件模板 都搞定之后  用户只需要在合适的位置使用 &lt;组件名&gt;&lt;/组件名&gt; 就能使用组件啦\n创建局部组件\n1234567891011&quot;const-component&quot;:&#123;    &quot;prefix&quot;: &quot;const-component&quot;,    &quot;body&quot;: [        &quot;const $&#123;1:组件引用名&#125;=&#123;&quot;,        &quot;    template:&#x27;#$&#123;1:组件模板id&#125;&#x27;,&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,components:&#123;&#125;,&quot;,        &quot;&#125;; //$&#123;0:&lt;template id=&#x27;$&#123;1:组件模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:模板根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n这段创建局部组件的snippets和上面的 创建全局组件的snippets基本大同小异, 只是局部组件的注册和全局组件的注册有所不同\n局部组件 需要在vue实例的 components字段当中传递组件对象的引用或者直接传递组件对象 代码如下:\n12345678910111213141516let vue = new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;&#125;,    methods: &#123;&#125;,    computed: &#123;&#125;,    watch: &#123;&#125;,    filters: &#123;&#125;,    components: &#123;        &quot;组件名称&quot;:组件引用名        &#x27;组件名称&#x27;:&#123;            template:&#x27;#组件模板id&#x27;,            data:function()&#123;return&#123;&#125;&#125;,            methods:&#123;&#125;,props:[],components:&#123;&#125;,        &#125;,     &#125;,&#125;);\n如果直接在vue实例的components字段当中使用直接传递组件对象的方式 去注册局部组件 可以使用下面的snippets:\n1234567891011&quot;sub-component&quot;:&#123;    &quot;prefix&quot;: &quot;sub-component&quot;,    &quot;body&quot;: [        &quot;&#x27;$&#123;1:组件名称&#125;&#x27;:&#123;&quot;,        &quot;    template:&#x27;#$&#123;1:模板id&#125;&#x27;,&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,props:[],components:&#123;&#125;,&quot;,        &quot;&#125;, //$&#123;0:&lt;template id=&#x27;$&#123;1:模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:模板根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n局部组件之所以叫局部组件,那就是他的使用范围是被限定的,如果某个Vue实例注册了局部组件,那么这个局部组件就只能在这个实例中使用,全局组件则可以在多个Vue实例当中共用\n自定义组件中的data和methods\n从上方自定义组件的snippets我们也可以看出来 自定义组件时候也可以传递 data 和 methods属性\n因为在自定义组件的模板中 我们也会使用到自定义的函数 也会使用自定义的数据 所以就像Vue实例一样我们也需要这两个属性\n123456&lt;template id=&#x27;test&#x27;&gt;    &lt;div class=&#x27;test&#x27;&gt;        &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;按钮&lt;/button&gt;        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;\n在创建Vue实例所使用 对象 当中 data 和 methods 属性的值都是 一个对象\n自定义组件的 methods属性和 Vue实例创建时候提供的methods属性使用方式几乎相同 都是一个包含若干函数的对象\n但是 自定义组件当中的 data属性却是一个函数 这个和Vue实例创建的时候提供的data属性是完全不同的\n1234567891011Vue.component(&#x27;test&#x27;, &#123;    template: &#x27;#test&#x27;, //    data: function () &#123; return &#123;        msg:&quot;hehe&quot;,    &#125; &#125;,    methods: &#123;        clickHandler(x)&#123;            console.log(x);        &#125;    &#125;, components: &#123;&#125;,&#125;);\n为什么创建自定义组件所传递的组件对象当中的 data属性是一个函数呢,其实原因也很简单,假如我们有一个组件X, 这个组件X我们可能在网页当中使用很多次, 这就是组件的复用, 但是组件复用的前提是每个组件是不完全相同的, 即使都是组件X,每个组件应该显示不同的数据, 如何确保每个组件显示的数据是不同的呢, 这就需要 每个组件和自己的数据绑定而不是和公用的数据绑定, 所以自定义组件的data属性就是一个返回对象的函数, 这个函数会针对每个组件X返回一个对象, 这个对象会和每个组件X进行绑定, 这样以来每个组件X就会有自己独享的数据对象了.\n组件切换与动态组件\n有时候我们需要在不同的组件之间进行切换, 对于一般的组件切换我们可以使用 v-if来实现,v-if虽然也不错 但是官方提供了更加有趣的方案 那就是动态组件, 而且 通过 &lt;keep-alive&gt; 标签 我们可以实现保存组件切换前后的状态\n假设我们有两个组件 分别是 组件aaa 和组件bbb  如果想要通过动态组件实现2个组件之间的切换就比较简单\n123456&lt;div id=&#x27;app&#x27;&gt;    &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;按钮&lt;/button&gt;    &lt;keep-alive&gt;        &lt;component :is=&#x27;componentx&#x27;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;/div&gt;\n如上 我们为&lt;component&gt;标签的is属性绑定一个变量 componentx, 用这个变量我们久能控制需要被显示的组件是哪个组件\n然后 通过按钮的点击事件就可以去改变 变量 componentx的值 也就可以切换当前显示的组件了,而且由于&lt;component&gt;标签是被放在 &lt;keep-alive&gt;标签里面的所以组件切换前后 组件的状态能够被很好的保存, 假如组件aaa中有个checkbox是check的状态, 那么切换到组件bbb再切换回组件aaa 这个checkbox依然会保持check的状态\n父子组件\n组件和Vue实例一样都能使用components属性,也就是说每个组件都能通过components属性定义自己的局部组件,也就是每个组将都能有自己的子组件\n就像上文中的局部组件只能在相应的Vue实例当中使用一样  子组件也是只能在父组件当中使用\n如果我们定义了一个父组件father, 并且在father组件对象当中的components属性中又定义了一个组件son, 那么 &lt;son&gt;&lt;\\/son&gt; 就只能在father组件的模板当中使用\n父子组件这样的父子关系,让他们之间的数据交换比其他组件之间更加容易 更加灵活\n子组件使用父组件的数据\n子组件使用父组件中数据的2个步骤:\n1&gt; prop是你可以在组件上注册的一些自定义attribute,我们在创建子组件的时候通过提供props来声明我们的子组件定义了那些prop, 也就是 我们创建子组件的时候想要注册的一些自定义 attribute 写道 props当中去,如下son组件当中声明了2个自定义的 attribute 分别是 xxx和yyy .\n1234567891011121314151617components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;            age:28,            name:&quot;lipanpan&quot;        &#125; &#125;,        methods: &#123;&#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;&#125;, props: [&quot;xxx&quot;,&quot;yyy&quot;], components: &#123;&#125;,            &#125;,        &#125;,    &#125;,&#125;,\n2&gt; 然后我们在父组件的模板当中使用子组件的时候 就可以将自己的数据绑定到子组件的属性上面,由于刚才我们为子组件定义了2个属性 xxx和yyy, 我们将父组件的 age 和name 绑定到这2个属性上,然后我们在子组件的模板当中 使用自己的属性就相当于使用父组件的数据.\n1234567891011121314&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son :xxx=&quot;age&quot; :yyy=&quot;name&quot;&gt;在父组件当中使用子组件&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;div&gt;来自父组件的数据xxx:&#123;&#123;xxx&#125;&#125;&lt;/div&gt;        &lt;div&gt;来自父组件的数据yyy:&#123;&#123;yyy&#125;&#125;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n子组件使用父组件的方法\n子组件使用父组件当中方法的2个步骤:\n1&gt; 首先在父组件中通过v-on 绑定事件监听器\n123456&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son @father-func=&#x27;fatherSay&#x27;&gt;在父组件当中使用子组件&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\n2&gt; 然后在子组件的某个函数当中 通过$emit()触发事件 调用事件处理函数(这里是父组件当中的方法)\n123456&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;button @click.prevent=&#x27;sonFunc($event)&#x27;&gt;按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;\n123456789101112131415161718192021222324components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;&#125; &#125;,        methods: &#123;            fatherSay()&#123;                alert(&quot;我是father组件的方法&quot;);            &#125;        &#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;                    sonFunc()&#123;                        this.$emit(&quot;father-func&quot;)                        // 使用 $emit 触发事件                         // 传递给$emit的方法名字是一个字符串                    &#125;                &#125;, props: [], components: &#123;&#125;,            &#125;,         &#125;,    &#125;, &#125;,\n子组件将数据传递给父组件\n子组件传递数据给父组件可以通过 调用父组件的方法来实现\n12345678910111213141516171819202122232425components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;            input_msg:undefined,        &#125; &#125;,        methods: &#123;            fatherSay(data)&#123;                console.log(&quot;我是father组件的方法&quot;);                this.input_msg=data            &#125;        &#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;                    sonFunc()&#123;                        this.$emit(&quot;father-func&quot;,Math.random())                    &#125;                &#125;, props: [], components: &#123;&#125;,            &#125;, //        &#125;,    &#125;, //&#125;,\n由上面的代码可以看到 子组件在传递数据给父组件的时候,只需要在使用vm.$emit(&quot;xxx&quot;,[...args])调用父组件的方法的时候把需要传递的数据当作参数传递过去就行了,然后在父组件的方法中接收和使用子组件当中传递过来的参数\n多级组件数据传递\n由上文我们可以知道 子组件可以使用父组件的数据, 子组件可以调用父组件的方法并且将数据传递给父组件, 但是如果组件的层级比较多, 比如子组件使用爷爷组件的数据和方法应该如何做: 这里只是简单介绍一种相对容易理解但是挺麻烦的做法那就是一层层的传递, 儿子组件想要使用爷爷组件的数据和方法首先把想要使用的数据和方法从爷爷组件传递给父组件,然后再从父组件传递给儿子组件就行了.\n组件中的命名注意点\n组件名子的命名\n\n注册组建的时候如果组件的名字使用了驼峰命名法, 那么html中使用组件的时候需要使用短横线命名法去使用这个组件. 例如: 注册时: myFather -&gt; 使用时: &lt;my-father&gt;&lt;/my-father&gt;\n\n12345Vue.component(&#x27;myFather&#x27;, &#123;    template: &#x27;#myFather&#x27;, //    data: function () &#123; return &#123;&#125; &#125;,    methods: &#123;&#125;, components: &#123;&#125;,&#125;);\n1234567891011&lt;body&gt;    &lt;div id=&#x27;app&#x27;&gt;        &lt;!-- &lt;myFather&gt;&lt;/myFather&gt; 注册组件的时候使用驼峰命名 使用组件的时候不能使用驼峰命名 --&gt;         &lt;my-father&gt;&lt;/my-father&gt;    &lt;/div&gt;&lt;/body&gt;&lt;template id=&#x27;myFather&#x27;&gt;    &lt;div class=&#x27;myFather&#x27;&gt;        &lt;div&gt;我是组件myFather&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n组件传入变量命名\n\n父组件传递数据给子组件的时候, 传入的变量名如果使用短横线命名方式,子组件得到的变量会被转换称为驼峰命名方式的变量. 例如: 传递时: parent-name=“name” -&gt; 接收时: props: [“parentName”]\n\n123456789101112131415&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;!-- &lt;son :parentName=&#x27;names&#x27;&gt;&lt;/son&gt; 父组件中使用驼峰命名法传递给子组件的变量名会被全部转换成为小写--&gt;        &lt;son :parent-name=&#x27;names&#x27;&gt;&lt;/son&gt;         &lt;!-- 使用短横线命名法传递给子组件的变量名 会被转换成为驼峰命名法 --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;div&gt;来自父组件的数据:&#123;&#123;parentName&#125;&#125;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n12345678910111213Vue.component(&#x27;father&#x27;, &#123;    template: &#x27;#father&#x27;, //    data: function () &#123; return &#123;        names:[&quot;zhangsan&quot;,&quot;lisi&quot;]    &#125; &#125;,    methods: &#123;&#125;, components: &#123;        &#x27;son&#x27;: &#123;            template: &#x27;#son&#x27;,            data: function () &#123; return &#123;&#125; &#125;,            methods: &#123;&#125;, props: [&quot;parentName&quot;], components: &#123;&#125;,        &#125;, //    &#125;,&#125;);\n组件传入的方法命名\n\n父组件将自己的方法传递给子组件的时候, 传入的方法名字如果使用驼峰命名法, 这个传入的方法名会被转换成为全部小写的形式,因为html属性是大小写不敏感的, 所以我们用v-on绑定的事件名称即使有大写字母也会全部被转换成为小写.\n例如: 传递时: @parent-say=“say” -&gt; 触发时: this.$emit(“parent-say”);\n\n12345678910111213&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son @fatherFunc=&#x27;say&#x27;&gt;&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;触发器按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;\n12345678910111213141516171819202122Vue.component(&#x27;father&#x27;, &#123;    template: &#x27;#father&#x27;,    data: function () &#123; return &#123;        names:[&quot;zhangsan&quot;,&quot;lisi&quot;]    &#125; &#125;,    methods: &#123;        say()&#123;            console.log(&quot;我是父组件的方法&quot;);        &#125;    &#125;,     components: &#123;        &#x27;son&#x27;: &#123;            template: &#x27;#son&#x27;,            data: function () &#123; return &#123;&#125; &#125;,            methods: &#123;                clickHandler($event)&#123;                    this.$emit(&quot;fatherfunc&quot;)                &#125;            &#125;, props: [], components: &#123;&#125;,        &#125;,    &#125;,&#125;);\n组件中的插槽是什么?\n默认情况下使用子组件时在子组件中编写的元素是不会被渲染的,如果子组件中有部分内容是使用时才确定的, 那么我们就可以使用插槽. 插槽就是在子组件中放一个&quot;坑&quot;, 以后由父组件来&quot;填&quot;\n123456&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;如果没有插槽 这句话是不会被渲染到页面上的 只会渲染son组件模板当中的内容 &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是匿名插槽?\n匿名插槽是子组件根元素当中的 &lt;slot&gt;可以有默认值&lt;/slot&gt;标签, 这些标签所在的位置就是预留的坑位,当我们在父组件当中使用子组件时如果往子组件的标签对当中写入了内容这些被写入的内容就会把  &lt;slot&gt;&lt;/slot&gt;标签以及其包裹的内容替换掉,如果子组件当中有多出&lt;slot&gt;&lt;/slot&gt;则替换多次\n1234567891011121314&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;我会替换掉slot标签以及被slot标签包裹的内容&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;slot&gt;插槽默认内容 我在网页当中会直接被渲染成字符串&lt;/slot&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot&gt;插槽默认内容 我在网页当中会直接被渲染成字符串&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是具名插槽?\n具名插槽和匿名插槽所差无几,只不过具名插槽的&lt;slot&gt;标签 有个name属性,这个属性就是插槽的名字, 在父组件中向子组件标签对中插入内容时候 可以通过slot=name属性控制插入到对应 name的插槽当中去\n12345678910111213141516171819&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;div slot=&quot;one&quot;&gt;往插槽名字为one的插槽中插入内容1&lt;/div&gt;            &lt;div slot=&quot;two&quot;&gt;往插槽名字为two的插槽当中插入内容&lt;/div&gt;            &lt;div slot=&quot;one&quot;&gt;往插槽名字为one的插槽中插入内容2&lt;/div&gt;            &lt;div slot=&quot;two&quot;&gt;往插槽名字为two的插槽当中插入内容&lt;/div&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;slot name=&#x27;one&#x27;&gt;插槽默认内容&lt;/slot&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot name=&#x27;two&#x27;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是作用域插槽?\n作用域插槽就是可以传递数据的插槽 子组件当中的数据通过&lt;slot v-bind:'xxx'='xxx'&gt;&lt;/slot&gt; 的形式传递给父组件,然后父组件通过 &lt;template slot-scope='obj'&gt;&lt;template&gt;的形式来使用子组件当中的数据\n12345678910111213141516171819202122&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot :names=&quot;names&quot; :test=&quot;test&quot;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;template slot-scope=&quot;obj&quot;&gt;                &lt;hr&gt;                &lt;div v-for=&quot;name in obj.names&quot; :key=&quot;name.id&quot;&gt;                    &#123;&#123; name &#125;&#125;                &lt;/div&gt;                &lt;hr&gt;                &#123;&#123;obj&#125;&#125;            &lt;/template&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\nv-slot指令怎么使用?\nv-slot指令是 Vue2.6 之后引入的指令,v-slot指令 使得在父组件当中书写插入到子组件当中的内容时更加的方便, 我写了2个snippets来快速使用这个指令:\n12345678910111213141516&quot;slot&quot;:&#123;    &quot;prefix&quot;: &quot;slot&quot;,    &quot;body&quot;: [        &quot;&lt;slot $&#123;1:name=&#x27;$&#123;2:slot-name&#125;&#x27;&#125;$&#123;0&#125;&gt;插槽默认内容&lt;/slot&gt;&quot;    ],    &quot;scope&quot;: &quot;html&quot;,&#125;,&quot;vslot&quot;:&#123;    &quot;prefix&quot;: &quot;vslot&quot;,    &quot;body&quot;: [        &quot;&lt;template #$&#123;1:default&#125;=&#x27;obj&#x27;&gt;$&#123;0:需要被插入的内容&#125;&lt;/template&gt;&quot;    ],    &quot;scope&quot;: &quot;html&quot;,&#125;,\n首先就是创建插槽的 slot代码段,这个代码段在子组件当中使用 可以快速创建匿名插槽和具名插槽, 在写完插槽的名字之后 你就可以进行随意的数据绑定把子组件的数据传递给父组件的使用者\n然后就是vslot代码段, 这个代码段在父组件当中使用,  可以快速的创建 带v-slot(#)属性的 template标签, 这个标签对应的默认插槽是匿名插槽(#default), 这个标签同时又一个默认对象obj,这个对象能够接收 子组件的插槽通过v-bind传递过来的数据\n123456789101112131415161718&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;template #one=&#x27;obj&#x27;&gt;                &#123;&#123;obj&#125;&#125;                 &lt;hr&gt;            &lt;/template&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot name=&#x27;one&#x27; :names=&quot;names&quot; :test=&quot;test&quot;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vue2组件化/"},{"title":"Linux常用操作记录","date":"2021-03-02T09:57:41.000Z","date_formatted":{"ll":"2021年3月2日","L":"2021/03/02","MM-DD":"03-02"},"updated":"2022-02-01T01:24:26.644Z","content":"文件解压与压缩\n[*.tar] [*.gz] [*.tar.gz/*.tgz] [*.bz2] [*.tar.bz2] [*.bz] [*.tar.bz] [*.Z] [*.tar.Z] [*.zip] [*.rar]1234*.tar 解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）\n1234*.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName\n123*.tar.gz 和 *.tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName\n1234*.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName\n123*.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName\n123*.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz\n12*.tar.bz解压：tar jxvf FileName.tar.bz\n123*.Z解压：uncompress FileName.Z压缩：compress FileName\n123*.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName\n123*.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName\n123*.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName\n","plink":"http://blog.lipanpanx.com/post/2021/202102/Linux常用操作记录__/"},{"title":"常用npm命令","date":"2021-02-26T10:41:54.000Z","date_formatted":{"ll":"2021年2月26日","L":"2021/02/26","MM-DD":"02-26"},"updated":"2022-02-01T01:24:26.644Z","content":"npm list\n","plink":"http://blog.lipanpanx.com/post/2021/202102/常用npm命令__/"},{"title":"ShareX截图自动添加水印","date":"2021-02-16T09:18:01.000Z","date_formatted":{"ll":"2021年2月16日","L":"2021/02/16","MM-DD":"02-16"},"updated":"2022-02-01T01:24:26.644Z","content":"\nsharex 截图之后是可以自动添加水印的  就像上面这样鼠标右键点击桌面底部任务栏中的sharex的小图标 设置即可\n但是这个添加水印效果是需要你实现设置好的  当你有添加水印的效果之后才能使用它\n如何在sharex中添加水印的效果呢?\n\n\n首先在桌面任务栏中的sharex小图标上右击鼠标 打开sharex菜单 然后按照上图步骤操作, 然后按照下图 添加水印效果即可\n\n\nSharex水印常用的配置项:\nSharex能对水印进行的操作还是比较全面的 我翻译一下常用的配置项\n\nText: 水印的内容\nPlacement: 水印的大概位置\nOffset: 水印相对于大概位置的偏移量\nTextFont: 水印的字体\nTextColor: 水印的颜色\n还有 水印阴影 水印渐变 等等各种乱七八遭的设置 感觉没多大用\n\n然后就是设置水印会出现的矛盾点:\n如果你的水印字体设置过大 那么就会出现 有些图片比较小 水印显示不全\n如果你的水印字体设置较小 就会出现 别人看不清的情况\n如果你的水印字体设置的 不大不小 就会出现 影响图片观感 看起来图片怪怪的\n还有就是黑色图片不能很好的显示黑色水印\n白色图片不能很好的显示白色水印\n图片设置水印矛盾点的解决办法:\n一个不错的解决方法 就是在一个预设中设置多个大小不同 颜色不同的水印 用来达到最好的效果:\n\n\n这样的话 无论大图小图 黑图白图 都能搞定\n","plink":"http://blog.lipanpanx.com/post/2021/202102/ShareX截图自动添加水印/"},{"title":"CSS box-shadow样式生成器","date":"2021-01-21T11:42:22.000Z","date_formatted":{"ll":"2021年1月21日","L":"2021/01/21","MM-DD":"01-21"},"updated":"2022-02-01T01:24:26.640Z","content":"box-shadow是CSS当中的一个非常棒的特性, 通过这个属性我们设置阴影就很简单了. 根据mdn css doc 中的 box-shadow文档 这个属性可以接收多组值(每组值用逗号隔开),设置多个阴影.\n每一组值表示一个阴影又包含下面的几项(通过这几项我们可以控制阴影的存在形式(inset),偏移量(offset-x/y),模糊半径(blur-radius),扩散半径(spread-radius),和颜色(color)):\n\n最少2个最多4个 &lt;length&gt; 类型的值.(2个值表示offset-x/y,第3个值是blur-radius,第4个值是spread-radius)\n一个可选的 inset 关键字\n一个可选的 &lt;color&gt; 类型的值\n\n虽然css 的box-shadow 已经方便我们进行阴影设计了,我们从上文中可以看出设置阴影的时候需要控制的变量还是挺多的,如果想要设置复杂的阴影调试起来还是很累的,如果又工具能够帮助我们进行CSS 阴影代码调试那就再好不过了.\n\n所以今天介绍两个非常棒的box-shadow样式生成器\n这两个都是在线的工具 使用非常方便\nMDN box-shadow generator\nMDN CSS DOC 当中的工具\nMake a smooth shadow,friend.\n国外热心网友@brumm写的工具\n","plink":"http://blog.lipanpanx.com/post/2021/202101/BoxShadow样式生成器/"},{"title":"CSS Grid Layout 用法","date":"2021-01-16T12:18:01.000Z","date_formatted":{"ll":"2021年1月16日","L":"2021/01/16","MM-DD":"01-16"},"updated":"2022-02-01T01:24:26.640Z","content":"相关参考文档:CSS Grid Layout\ngrid layout 相关概念\n和 felxbox布局一样 在使用grid布局之前 同样需要先了解一下相关的概念,这些概念在 Basic Concepts of grid layout一文当中有相对详细的解释:\nGrid: 一种二维布局模型\nExplicit Grid:\nImplicit Grid:\nGrid Container: 当你把一个元素的display属性设置为 grid/inline-grid 则这个元素就会变成 grid contianer\nGrid Item: grid container 的直接子元素就会变成 grid item\nGrid Lines:\nGrid Tracks: 网格轨道 是 位于2个相邻的 grid line 之间的空间.\nGrid Cell: grid cell 是 css grid 当中的最小单元,他是4个 grid line 相交组成的空间,在概念上 和table 当中的 table cell 很相似.\nGrid Areas: grid area 是一个或多个 grid cell 构成的举行区域,当你 在grid container当中通过 line-based placement 方式放置 grid item的时候  grid area 会被创建, 或者 你也可以通过 grid-template-areas 直接创建 grid area.\nGutters: gutters表示grid tracks 之间的距离, 可以通过 column-gap,row-gap,gap进行控制, 当然也可以通过margin padding 等进行控制.\nGrid Axis:\nGrid row: 水平的grid track 就是 grid row\nGrid column: 垂直的 grid track 就是grid column\n\n\n在讲解下面的属性之前 我先讲一下 grid item 是如何在 grid container当中被放置的:\n\ngrid container 相关CSS属性\ngrid-template-columns:\ngrid-template-rows:\n更多相关细节🥱 You got me !\ngrid-template-areas:\n更多相关细节🥱 You got me !\ngrid-template: CSS简写属性用来定义 grid columns, grid rows 和 grid areas.\n更多相关细节🥱 You got me !\n\ngrid-auto-columns:\ngrid-auto-rows:\ngrid-auto-flow:\n\ncolumn-gap(grid-row-gap): 同 flexbox layout column-gap\nrow-gap(grid-column-gap): 同 flexbox layout row-gap\ngap(grid-gap): 同 flexbox layout gap\ngrid: CSS简写属性 可以同时设置所有的 隐式grid 和显示grid 的grid 属性\n\njustify-items:\nalign-items:\nplace-items:\njustify-content:\nalign-content:\nplace-content:\ngrid item 相关CSS属性\ngrid-column-start:\ngrid-column-end:\ngrid-column: CSS简写属性 最多可以接收2个值, 第1个给grid-column-start 第2个给grid-column-end用/分开.\ngrid-row-start:\ngrid-row-end:\ngrid-row: CSS简写属性 最多可以接收2个值,第1个给grid-row-start,第2个给grid-row-end,用/分开.\ngrid-area:\n\njustify-self\nalign-self\nplace-self\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS-Grid-Layout/"},{"title":"CSS Flexible Box Layout用法","date":"2021-01-13T10:16:36.000Z","date_formatted":{"ll":"2021年1月13日","L":"2021/01/13","MM-DD":"01-13"},"updated":"2022-02-01T01:24:26.640Z","content":"相关参考文档:CSS Flexible Box Layout\nflexbox 布局基本概念\n要想使用flexbox布局 首先要了解几个概念:\n\nFlexbox: 一种在单一方向上显示项目的布局模型\nFlex Container: 当我们为某个元素的CSS中设置了display为 flex或者inline-flex,则当前元素都会变成 flex container\nFlex Item: 被flex container 包裹的直接子元素(direct children)就是flex item,此外被flex container直接包裹的连续文本也是 flex item.\nMain Axis: 主轴是用户定义的一个方向,如上图所示的主轴方向是从左向右 当然也可也从右往左 也可以从上向下 也可以从下向上\nCross Axis: 侧轴 永远和主轴垂直的一条周轴 如果主轴横向则侧轴纵向 如果主轴是纵向则侧轴横向\n当我们使用flexbox 布局的时候其实就是先找到一个父元素 添加 display:flex 让这个父元素变成flex container ,然后这个父元素的所有子元素就都变成了flex item, 然后我们分别为 flex container 和 flex item 添加我们所需要的属性就OK了.\nflex container 相关CSS属性\n其中 flex container 中可以被使用的flex相关的属性如下:\nflex-direction: 控制flex container 中主轴的方向\nflex-wrap: 如果flex item在主轴方向上的宽度总和比flex container的主轴宽度还宽的时候 flex-wrap 可以控制采用收缩flex item宽度的方式 还是采用换行的方式 来确保flex contianer 能够容下所有flex item\nflex-flow: 这个是CSS的简写属性 它一次性接收2个值, 第一个值给flex-direction 第二个值给flex-wrap.\n\n下面几个flex container的CSS属性 是用来对齐 flex container内部的flex items用的:\nalign-items: 控制flex items 在侧轴方向上的对齐方式,本来flex item可以通过作用于自己的CSS 属性 align-self 控制自己在侧轴方向上的对齐方式, 而 align-items 的作用就是进行批量的设置所有flex items 的align-self的值.\njustify-items: 这是属性和align-items相似是批量控制flex items的 justify-self属性的值用的 但是因为justify-slef在flexbox 当中不会生效,所以这个属性的值也就没有任何作用了,MDN参考文档中的原话:In flexbox layouts, this property is ignored.\nplace-items: 这个是CSS的简写属性,它接收2个值,第一个值给align-items 第二个值给 justify-items\n\n在设置content对齐相关的属性之前我们需要了解在flexbox布局当中什么是content:其实也非常的简单在flexbox布局当中 所有flex item构成的统一整体就是flexbox布局的content, 所以说content相关的CSS属性其实就是操作这个统一整体的属性.\njustify-content: 控制主轴方向上content的对齐方式\nalign-content: 控制侧轴方向上的 content的对齐方式\nplace-content: 这个是CSS的简写属性,它接收2个值,第一个给align-content,第二个给 justify-content.\n\nrow-gap: 控制多行之间的间距,但是有个需要注意的点就是,在我们允许flex-wrap的情况下,如果flex item多行排列,这个时候align-content属性就会生效,因为 align-content的默认值为 stretch, 也就是说默认flex item 在垂直方向是是拉伸显示,多行flex item的渲染高度就是平分 flex container的高度, 看起来 flex item 多行之间就会有一个比较大的间距, 其实这个间距我们可以通过把 align-content设置成一个不是默认值stretch的值 进行消除/或者变成其他形式, 如果我们把align-conteng设置成为 start/center/end 这个看起来很大的间距就会直接消失, 这个时候我们就可以通过 row-gap自由的控制行间距了.\ncolumn-gap: 控制多列之间的间距\ngap: 这个是CSS的简写属性 它最多接收2个值,第1个值给row-gap,第2个值给column-gap.\nflex item 相关CSS属性\n我们可以再每一个 flex item设置他自己的 flex相关属性,允许被设置的相关属性如下:\norder: 这个CSS属性可以用来控制item在flex/grid container内部的摆放顺序,container内部的items 首先会按照 他们的order值升序排列,然后才会按照他们在html源码当中的位置进行排列.\nflex-grow: 如果flex items设置了flex-grow属性, 如果flex items就会在主轴方向上强制占满整个flex contaienr的大小,在flex container的大小比flex items的size之和还大的时候(单行显示),就会有一块明显的剩余空间需要被分配, 当flex container的大小没有 flex items的size之和大的时候(多行显示),其实在主轴的边缘还有有可能出现剩余空间的,那就是在felx item的size确定的情况下,如果第一行的末尾剩余的空间刚刚比第二行的第一个元素的size小一点点,刚好容不下导致元素换行的时候这个时候第一行就会出现一个小的剩余空间, 这些剩余空间的合理分配就是通过 flexg-grow设置的权重来实现的.\nflex-basis: 这个CSS属性控制flex item在主轴方向上的初始大小, 这个值比flex item的height/width拥有更高的优先级\nflex-shrink: 这个值控制在flex item的大小设置过大在主轴方向上超过flex container的大小的时候 如何进行合理的收缩自身的大小来确保 flex item不会溢出到 flex container的外面导致不美观.\n关于flex-shrink导致flex item自身收缩大小的计算方法,在W3C CSS WG 发布的规范文档CSS Flexible Box Layout Module Level 1的第9.7章节9.7. Resolving Flexible Lengths 有说明,但是规范文档的内容还是比较苦涩难懂,已经有人写了简单易懂的文章:flex-shrink calculation\n所谓收缩其实就是flex item 根据自身的 felx-shrink权重把自己剪掉一部分大小,这个被剪掉的大小的计算方式如下:\n\n\n首先把 flex container把所有的flex item的flex-basis减掉 得到 negative free space 的宽度, 也就是本来要超出容器的宽度\n然后 计算总权重  Σ(flex-basis x flex shrink)\n每个 flex item各自的权重比 就是自己的(fex-basis x flex-shrink)/Σ(flex-basis x flex shrink)\n每个 flex item需要减掉的 部分就是 negative free space * 各自的权重比\n每个 flex item 计算出自己需要剪掉的部分之后就能得出 自己在主轴方向的最终大小了\n\n\nflex: 这个是CSS的简写属性, 它接收3个值,第一个给flex-grow,第二个给flex-shrink,第三个给 flex-basis.\n\nalign-self: flex item通过这个属性可以控制自己在侧轴方向上的对齐方式.\njustify-self: 在 flexbox布局当中 这个属性的值会被忽略,MDN参考文档中的原话:In flexbox layouts, this property is ignored.\nplace-self: CSS简写属性 最多可以接收2个值 第1个值给align-self,第2个值给justify-self\n\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS-Flexible-Box-Layout/"},{"title":"JSFiddle 功能介绍","date":"2021-01-12T09:32:46.000Z","date_formatted":{"ll":"2021年1月12日","L":"2021/01/12","MM-DD":"01-12"},"updated":"2022-02-01T01:24:26.640Z","content":"set as base\n\nJSFiddle 用了 这么久 一直不知道 set as base 这个功能到底干啥用的, 今天翻了一下 JSFiddle 的文档 看了一下\n文档中关于 这个功能的说明 如下:\nThis action is available for logged in users only.\nIf you’re working a fiddle and updating it, the version number will increase, sometimes if you’re satisfied with the code you have it’s good to save it so that the version numbers are hidden, and the version you’ve set as base is the default one.\nFor example if you have a fiddle jsfiddle.net/oskar/aba321/23 setting as base will make the 23 version accessible at jsfiddle.net/oskar/aba321\nWhen you save a new title or description for the fiddle, saving it will not result in any change on your dashboard, you need to set the fiddle as Base for the new title and description to appear.\n这玩意 还真的挺棒:\n首先 这个功能 登陆了才能用\n然后 我说下这个功能的作用 假设你在 某个项目上工作 jsfiddle.net/cisco_li/o42rhfsj/ 你每次的保存都会生成一个新的版本 jsfiddle.net/cisco_li/o42rhfsj/版本号  如果你对某个版本比较满意 你就可以 使用  set as base 把他保存成为默认版本  每次你打开 jsfiddle.net/cisco_li/o42rhfsj/ 显示的就是这个默认版本 这可真的 太爽了  你把你的项目链接分享出去之后  然后你对这个链接 分享的内容  仍然保有控制权  棒不棒\n还有就是 当你 保存 你的 title 和 description的时候 默认情况下  这些新保存的内容是不会显示在  你的 dashboard当中的 如果此时你使用了 set as base 按钮 那么你的 fiddle dashboard 就能显示最新的 title 和 description了\ncollaborate\n这个合作功能也很棒  点击之后 直接进入结对编程 模式\n你只需要 把链接分享给 其他人 别人打开链接 都不需要登陆 就可以和你一起 编程了\n但是对网速 有一定要求  要不然体验 不好\n","plink":"http://blog.lipanpanx.com/post/2021/202101/JSFiddle功能介绍/"},{"title":"CSS BFC的应用场景","date":"2021-01-11T10:50:04.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2022-02-01T01:24:26.640Z","content":"今天讲一下CSS BFC的几个应用场景:\ncontain internal floats\n看下下面这个例子:\n\n在这个例子当中我们可以看到 在外层div包含了一个div和一个p,其中内层div是浮动的, 很遗憾的是这个浮动的div超出了外层div的包裹范围,这并不美观而且大多数情况下也不是我们想要的结果, 此时我们就可以打开 CSS中 display:flow-root; 这句的注释,打开外部div的这句注释之后, 就能看到内部浮动的盒子原本溢出的部分被重新包含到了 外部div的border当中了, 这是因为 当我们为外部div当中添加 display:flow-root; 之后, 这个元素和它的子元素就会构成一个新的BFC, 因为BFC构成了一个隔离的独立容器, 容器里面的子元素不会影响到外部的元素, 外部的元素也不会影响到里面的元素, 而且计算BFC高度的时候 浮动元素也需要参与其中, 所以我们不要去手动指定外部div的高度, 这个高度会自动计算直到成功的把float的元素给包裹住. 我们的问题就这么解决了.\nexclude external floats\n\n在这个例子当中我们可以看到 &lt;section&gt; 内部有2个div,其中一个div浮动另外div一个显示在浮动的下方并且其内部的内容围绕着浮动显示,此时如果我们想要实现双列布局应该怎么做呢? 其实只要只要为为第二个非浮动的子div添加 display:flow-root;就行了, 因为如此以来 第二个非浮动的div 他自己就构成了一个新的BFC,而BFC是独立渲染的区域不会与周围的元素相互影响也不能与周围的浮动盒子产生重叠,所以非浮动div和浮动div构成的盒子就分开了,这样双列布局就形成了.\nmargin collapsing\n\n在这里例子当中, 因为 三个div 同属于同一个BFC的缘故 我们可以看到 首先 我们为.red-outer设置的 margin-top不会起作用, 然后我们为.red-inner设置的margin-top 也不会起作用, 这2个margin都会被折叠起来, 因为同一个BFC内的垂直方向上的 margin会折叠,这是BFC内的布局规则, 但是当我们打开CSS当中 .red-out的 display:flow-root 这句注释的时候情况会有所不同, 首先.red-outer的margin-top还是不会起作用,然后.red-inner的margin-top却起作用了, 这是因为 当我们为.red-outer添加 display:flow-root 这句注释的时候, .red-outer和它的子元素.red-inner就会构建成为一个新的BFC.在这个新BFC内部的元素独立渲染 margin不会和原来的BFC的margin产生重叠,所以生效是必然的.\n\n在上面的3个例子当中 我们可以看到构建一个新的 BFC,我向相关的CSS 当中添加了 display:flow-root,其实还有其他的多种方法来构建一个新的BFC,但是这种方式是MDN的教程中比较推荐的一种方式,因为这种方式所造成的副作用最小.\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS-BFC的应用场景/"},{"title":"CSS visual formatting model","date":"2021-01-06T16:50:02.000Z","date_formatted":{"ll":"2021年1月6日","L":"2021/01/06","MM-DD":"01-06"},"updated":"2022-02-01T01:24:26.640Z","content":"今天准备抽时间仔细学习下CSS 的VFM 感觉这个东西还是非常重要的,CSS 的FC BFC IFC GFC FFC都和VFM有非常大的关系,所以我打算翻译一下 W3C CSS WG发布的Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification(REC-&gt;REC)中的第9章的内容9 Visual formatting model 喜欢最新内容的朋友可以看看 CSS WG关于 CSS Level2(CSS 2.2)的最新草稿Latest editor’s draft, 或者看看CSS WG最新一年度的工作日志CSS Snapshot 2020,下面就是我关于第9章的一些简单翻译:\nintroduction to  visual formatting model(9.1)\n文档树当中的每个元素会在VFM中生成0个或者多个box, 这些box的位置由下面几个东西决定:\n\nbox dimensions and type.\npositioning scheme (normal flow, float, and absolute positioning).\nrelationships between elements in the document tree.\nexternal information (e.g., viewport size, intrinsic dimensions of images, etc.)\n\n在CSS 2中，许多盒子的位置和大小都是根据一个叫被做 containing block 的矩形盒子的边缘来计算的。\n一般来说，生成的盒子充当包含后代盒子的块;我们说一个box 为它的后代建立了 containing block.\n“ a box’s containing block ” 意思是 “盒子所在的包含块”，而不是它生成的那个.\ncontrolling box generation(9.2)\nbox的类型 会影响 box在VFM当中的行为,用display属性可以控制 box 的类型.\n下面描述了可以被CSS2生成的 box 类型:\n\nblock boxes\nanonymous block boxes\ninline boxes\nanonymous inline boxes\nrun-in boxes\n\n\n通过display属性可以控制一个元素是否是block level element,\n一个block level element会生成 一个 principal block level box(包含子代盒子和生成的内容)\nblock level box 是块级格式上下文(BFC)的参与者.\n一般情况下 block level box 也是一个 block container box(除了table box和 replaced element).\nblock container box 要么只包含 block level box 要么只包含inline level box(建立在IFC中)\n但是并不是所有的 block container box 都是block level box: non-replaced inline blocks and non-replaced table cells都是 block container 但是他们不是 block-level box.\n对于那些 同时是block container 的 block level box我们称之为  block box.\n因为大多数的 block level box都是 block container 因此大多数的block level box可以被称为 block box.\nblock level box 和 block container box和 block box 我们可以统称为 block.\n匿名block box 例子:\n1234&lt;DIV&gt;  Some text  &lt;P&gt;More text&lt;/DIV&gt;\n这段代码当中假设 DIV和P的display属性都是block,\nDIV当中同时出现了 inline content(Some text) 和 block content(More text),\n但是DIV是一个 block container box, 如果一个 block container box当中存在一个box level box, VFM就会强制让内部的所有元素变成 block level box, 因为P是block level box 所以 Some text 会被套上一个 匿名的block box 来确保DIV内部所有的box都是block level box.\n当一个 inline box 包含一个 in-flow block level box, 这个inline box 将会被 block level box打破, 这个 inline box 将会被分成2个box, 分别在 block level box的两边. 被打断之前的部分和被打断之后的部分被封装在匿名 block box内. block level box 变成了 这些匿名 block box的兄弟盒子.\n如果这个 inline box 受到相对定位的影响 任何结果的转变也会反映到 inline box所包含的block level box上面.\n123456789101112131415&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;HEAD&gt;  &lt;TITLE&gt;Anonymous text interrupted by a block&lt;/TITLE&gt;  &lt;STYLE&gt;    p    &#123; display: inline &#125;    span &#123; display: block &#125;  &lt;/STYLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;  &lt;P&gt;  This is anonymous text before the SPAN.  &lt;SPAN&gt;This is the content of SPAN.&lt;/SPAN&gt;  This is anonymous text after the SPAN.  &lt;/P&gt;&lt;/BODY&gt;\n上面的内容我们可以看到 P元素包含了 一个匿名文本(C1)然后跟着一个block level element 然后再跟着一段匿名文本(C2), 这块内容的渲染结果就是 首先是BODY这个 block box,这个box包含了一个匿名block box(这个box包含C1),然后跟着SPAN这个block box,然后是另外一个匿名block box(这个box包含着C2).\n匿名box的属性可以继承来自封闭的非匿名盒子,\n对于非继承的属性可以有一个初始值,\n比如 匿名box的字体继承自父盒子 但是它的margin是一个初始值0.\n在导致生成 匿名 block box的 element上设置的属性 让然可以被引用到这个 element的box和内容上面.\n如果你为上面的P元素设置边框, 那么这个边框 围绕着 C1和C2绘制(半开形式).\n\n通过display属性可以控制一个元素是否是 inline level element\ninline level element 生成 inline level box , inline level box 是内联格式上下文(IFC)的参与者\n并不是所有的inline level box 都是 inline box\n对于那些不是inline box的 inline level box可以称之为 atomic inline level box,\n因为 他们 会 作为一个单独的不透明的盒子 参与到IFC当中去.\n任何直接包含 在一个 block container element(而不是被包含在inline element)的文本 必须被当作匿名的 inline element对待.\n看下面这个例子:\n12345&lt;p&gt;  Some   &lt;em&gt;emphasized&lt;/em&gt;   text&lt;/p&gt;\n这个例子当中P生成了一个包含 inline box的 block box.\n毫无疑问 EM是 inline element 它生成了 inline box,\n但是 “Some” 和 “text” 是被 block level element§所生成的匿名inline box包裹\n之所以被叫做匿名 inline box 因为他们没有一个相关联的 inline level element\n一些匿名 inline box 从他们的 block parent box继承了一些允许被继承的属性\n那些不允许被继承的属性 可以有一个初始值\n在上面的例子当中 匿名 inline box的 color继承自P 但是他们的背景确实透明的.\n随后根据White-space属性被折叠的空白内容不会生成任何匿名的inline box。\npostioning schemes(9.3)\n在 CSS2当中一个 box 可以有三种定位方案:\n\nnormal flow\nfloats\nabsolute positioning\n\n在CSS2当中normal flow 包括BFC(block formatting context) 和 IFC(inline formatting context)还有 block level box和 inline level box之间的 relative positioning.\n在float模型当中,首先按照 normal flow 放置box,然后再从flow中取出box尽可能的向左右两边放置, content(一般指父盒子当中的内容)会沿着float box的一边流动.\n在绝对定位模型当中, 会把box从normal flow当中彻底的删除(和其他的兄弟box之间再没有任何的关系和影响), 然后会赋予一个位置,这个位置是相对于 这个box的 containing block的.\nout of flow:  如果一个元素使用了 浮动,绝对定位,或者它是根元素 则这个元素被称为 out of flow\nin flow: 如果一个元素不是 out of flow 那么就是 in flow\nflow of an element A: 这是一个集合 这个集合包含A和A下面的所有子代元素\nCSS中通过 position 和 float 这两个属性控制 使用什么样的位置算法去计算box的位置.\nnormal flow(9.4)\nnormal flow 当中的 box 是属于FC(formatting context)的, 一个box可以属于BFC 也可以属于IFC 但是不能同时属于BFC和IFC,  block level box 会参与BFC,而inline level box 会参与IFC.\nBFC(block formatting context)\n什么情况下会创建BFC?\n\n对于浮动,绝对定位的元素,\n对于那些不是block box的block containers(比如:inline-blocks, table-cells, and table-captions),\n对于那些虽然是block box但是 他的overflow 属性却不是 visible的box(除非这个值已经传播到viewport).\n\n\n对于上面这几种情况,VFM会创建一个BFC 去包裹他们的内容.\n\nBFC内部的布局规则:\n\nBFC内部的Box会 从containing block 的顶部开始 在垂直方向一个接一个地放置.\n在BFC当中 两个兄弟Box在垂直方向的距离由margin决定, 属于同一个BFC的两个相邻Box的margin会发生重叠.\n在BFC当中 每个box的左边缘 会触碰到 containg block的左边缘(对于从右向左的formatting是右边缘),即使这个box使用了浮动, 除非这个box构建了一个新的BFC(这种情况下box可能会因为浮动而变的更窄)\n\n\n关于BFC,其实MDN上有一篇更加详细的文章:Block formatting context 这篇文章中同时讲到 GFC(grid formatting context) 和 FFC(flex formatting context) 他们和 BFC很相似 ,只是flex/grid container 内部不允许出现浮动的子元素. 但是外部的浮动用来抑制margin重叠依然能够正常工作.\n\n\n关于GFC更详细的内容参考W3C相关标准:CSS Grid Layout Module Level 2(CRD-&gt;CR)\n官运FFC更详细的内容同样参W3C的相关标准:CSS Flexible Box Layout Module Level 1(CR-&gt;PR),不过FFC内容不多标准当中也没详细讲 三言两语就带过了😂\n\nIFC(inline formatting context)\nIFC内部的布局规则:\n\n在IFC当中 box从 containing block的顶部开始一个接着一个水平的排列\nbox之间 水平方向上的 margins borders 和 padding 得到保留\n这些box 能够以各种不同的方式 进行垂直对齐: 他们的顶部或者底部能够被对齐, 或者根据他们当中的文本的 baseline 进行对齐\n\n\n包含这些box 的 长方形区域 在水平方向上形成了 一条line 我们称为  line box.\nline box的宽度 是根据 containing blcok 和是否存在浮动所决定的. 高度 是根据第10.8章中的行高计算规则进行计算得出的.\n\n\nline box 的高度总是能够容纳它所包含的所有box, 然而，它可能比它所包含的最高的box还要高(for example,boxes are aligned so that baselines line up).假设存在一个box B, 当 box B的高度小于包含它的line box 的高度时，line box 中B的垂直对齐方式由vertical-align属性决定. 当几个inline level box无法水平地容纳在单个line box 中时，它们被分布在两个或多个垂直堆叠的line box 中。因此，paragraph 是line box的垂直堆栈。line box 没有垂直分隔(除非在其他地方指定)，并且它们从不重叠。\n\n\n一般来说，line box 的左边缘接触其containing block的左边缘，而右边缘接触其containing block的右边缘。然而,浮动的box 可能位于containing block边缘和 line box 边缘之间。因此，尽管在同一个IFC中的inline box 通常具有相同的宽度(一般就是 containing box的宽度)，但如果由于浮动而减少可用的水平空间，它们的宽度可能会变化。同一IFC中的line box 通常在高度上有所不同(例如，某一行可能包含一个很高图像，而其他的行可能只包含文本)。\n\n\n当一行之中的inline box 的总宽度小于包含它们的line box的宽度时，它们在line box 中的水平分布由 text-align 属性决定。如果 text-align的值是 justify, 则浏览器可能 会 拉伸 inline box内部的 spaces 和 words.(inline-table 和 inline-block box 除外)\n\n\n当一个inline box 超过 line box 的宽度时，它会被分成几个box ，这些box分布在几个line box当中。如果一个内联框不能拆分(eg:如果inline box 包含单个字符，或者特定语言的单词打破规则禁止在内联框内被分开，或者对于内联框受到nowrap或pre空白值的影响的情况),inline box 会溢出 line box.\n\n\n当一个inline box 被拆分时，margins borders and padding 在拆分时不会渲染出来.\n由于 bidirectional text processing ，inline box 也可能在同一个line box 内被分割成好几个 box。\n\n看看下面这个例子:\n1234567&lt;P&gt;  Several   &lt;EM&gt;emphasized words&lt;/EM&gt;   appear  &lt;STRONG&gt;in this&lt;/STRONG&gt;   sentence, dear.&lt;/P&gt;\n在这个例子当中 P元素生成了一个 block box 包含了5个 inline box, 其中三个是匿名的:\n\nAnonymous: “Several”\nEM: “emphasized words”\nAnonymous: “appear”\nSTRONG: “in this”\nAnonymous: “sentence, dear.”\n\n为了格式化段落，浏览器将这五个方框转换为行方框。\n在本例中，为P元素生成的box 为line box 建立了containing block 。如果包含块足够宽，所有的inline box 将适合一个line box:\n1Several emphasized words appear in this sentence, dear.\n如果不是，inline box 将被分割并分布在几个line box 中。前一段可分为以下几段:\n12Several emphasized words appearin this sentence, dear.\n或者下面这样:\n123Several emphasizedwords appear in thissentence, dear.\n在这里 如果我们故意把viewport设置的比较窄, 则可以让原有的EM box 被分成两个EM box(称它们为“split1”和“split2”)。\n虽然 EM box由一个变成2个, 但是如果我们对EM设置了margins, borders, padding, or text decorations,这些属性的效果是不会在split1之后或split2之前展现出来的, 2个分分开的盒子看起来仍然还像是同一个整体. 通过下面这个例子可以更加详细的展示出来:\n123456789101112131415161718&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;HTML&gt;  &lt;HEAD&gt;    &lt;TITLE&gt;Example of inline flow on several lines&lt;/TITLE&gt;    &lt;STYLE type=&quot;text/css&quot;&gt;      EM &#123;        padding: 2px;        margin: 1em;        border-width: medium;        border-style: dashed;        line-height: 2.4em;      &#125;    &lt;/STYLE&gt;  &lt;/HEAD&gt;  &lt;BODY&gt;    &lt;P&gt;Several &lt;EM&gt;emphasized words&lt;/EM&gt; appear here.&lt;/P&gt;  &lt;/BODY&gt;&lt;/HTML&gt;\n在P的宽度有限的情况下 效果如下 EM将会被分割称为2个box:\n\n\nThe margin is inserted before “emphasized” and after “words”.\nThe padding is inserted before, above, and below “emphasized” and after, above, and below “words”.\nA dashed border is rendered on three sides in each case.\n\nfloats(9.5)\n这一章有空再翻译\nabsolute positioning(9.6)\n在绝对定位模型中，一个盒子相对于它的包含块显式地偏移。它完全从normal flow 中被删除(它对后面的兄弟节点没有影响)。\n绝对定位的盒子为normal flow 的子代和绝对(但不是固定的)位置的子代建立一个新的包含块。\n但是，绝对位置元素当中的内容不会围绕着其他任何box进行排版。它们可能掩盖另一个盒子的内容(或本身被掩盖)，这取决于重叠盒子的堆栈级别。\n本规范中的 absolutely positioned element 意味着这个元素的position属性的值为 absolute or fixed .\n固定定位是绝对定位的一个子类. 仅有的不同是 对于固定定位的盒子, containing block 是被viewport 所构建的. 对于 连续媒体 当 文档 滚动的时候 固定定位的盒子不会发生移动. 在这方便 他们类似于固定的背景图像. 对于分页媒体 固定定位的 box 在每一个page上重复. 这对于在每个page的底部放置签名就很有用了. 使用固定定位的盒子 他们大于页面区域的位置将会被裁剪掉. 在初始包含块中不可见的固定位置框的部分将不会打印。\nrelationships between display position and float(9.7)\n这三个属性会影响 box 的 生成和布局 – display  position 和 float之间的交互关系如下:\n\n如果display 为none, 当 position and float 不进行设置的时候, 则对应的元素不会生成box\n否则, 如果 position 的值为 absolute or fixed,box使用绝对定位, float的computed value为none,display按照下表进行设置, 此时box的位置由 top right bottom left 的值 这个box的 containing box决定.\n否则, 如果 float的值不是 none, 则这个被浮动的box的display属性按照下表进行设置.\n否则, 如果 当前元素是 根元素, 则display的值按照下表进行设置(除非你指定了一个在CSS2.1当中未定义的值)\n否则, display的值就是你手动指定的值\n\n\n123下面这几章内容有空再翻译## comparison of normal flow floats and absolute positioning(9.8) ## layered presentation(9.9)\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS-VFM/"},{"title":"CSS实现各种奇形怪状","date":"2021-01-05T17:22:39.000Z","date_formatted":{"ll":"2021年1月5日","L":"2021/01/05","MM-DD":"01-05"},"updated":"2022-02-01T01:24:26.640Z","content":"利用border\n\n可以按F12看下上面这个盒子的源码 样式我写成了嵌入式的:其实原理非常简单就是一个div正方形盒子他的上下左右的border设置的很大等于这个正方形的边长的一半然后颜色设置为不同就行了,然后我们从这样一形状得到三角形就很简单了,把一部分设置成为透明就行了.\n如下可以实现各种由等边三角形组成的形状:\n\n    \n    \n    \n    \n    \n\n\n对于正方形盒子border宽度设置为边长的1/2如上,如果border宽度设置成为边长的1/4如下就可以搞出梯形了:\n\n如果border宽度随意设置就可以搞出各种其他的各种奇怪的形状,简直不堪入目😂:\n\n    \n    \n    \n    \n    \n\n\n如果加上border-radius并且把它的值设置正方形边长的1/2或者1/4就得到了下面两个图形:\n\n\n然后稍加改造 又可以造出鬼畜的形状:\n\n其实通过border-radius可以搞出来的奇形怪状可不少,可以使用mdn的生成工具慢慢调试Border-radius generator\n然后通过把部分border设置为透明或者把border-radius设置的更加离谱一些又可以得到其他的形状:\n\n\n\n利用伪元素\n如果配合伪元素::before和::after 则能够玩出更多的花样来,其实利用伪元素::before和::after无非就是盒子本身弄成一个形状然后这2个伪元素再弄成2个形状,最后三个形状拼接成某个特殊的形状我们以太极为例:\n可以先搞一个盒子搞成分开的半圆如下:\n\n然后再利用::before和::after画两个内外反色的圆环放在左右2处即可:\n\n\n\n\n结果如下图所示:\n\n利用box-shadow\n下面这个月亮其实就是一个圆形盒子的红色阴影\n\n总结\nCSS生成的各种奇奇怪怪的形状其实就是先用css的特性造出来一些基础形状,然后再对这些基础形状再进行旋转变换遮罩拼接形成更加复杂的形状.\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS实现各种奇形怪状/"},{"title":"GithubActions初体验","date":"2021-01-04T07:32:19.000Z","date_formatted":{"ll":"2021年1月4日","L":"2021/01/04","MM-DD":"01-04"},"updated":"2022-02-01T01:24:26.640Z","content":"https://docs.github.com/en/actions\n","plink":"http://blog.lipanpanx.com/post/2021/202101/GithubActions初体验/"},{"title":"搭建Hexo博客","date":"2021-01-01T17:22:48.000Z","date_formatted":{"ll":"2021年1月1日","L":"2021/01/01","MM-DD":"01-01"},"updated":"2022-02-01T01:24:26.644Z","content":"重新搭个博客, 这里做一下记录\n\n0x10 前情提要\n最近决定重新搞个博客,申请个域名,搞的大气一些\n之前的 xxx.gitee.com 确实有点拿不出手了\n0x20 博客方案\n搭建博客 现在有很多的方案,由于是个人博客,平常就是发一些自己写的技术文,访问速度够快就行\n所以就搞成静态博客就行了,但是静态博客也有很多方案可以选择 hexo hugo vuepress 等等\n最终我还是选择了 hexo, hexo是js写的没有hugo(go语言写的)快,但是hexo相对比较成熟,主题的可选择项又多,而且我知道有比较厉害的博客是用hexo+next实现的, 比如cuiqingcai.com, 而且我之前的博客也是基于Hexo搭建的,不想再折腾其他框架了.至于主题,我选择的是一个非常非常非常小众的主题inside,我感觉不错所以就用了,由于是小众主题我已经做好了踩坑的准备了\n0x30 着手开始搭建\n既然方案都想好了那就开始搭建\n0x31 域名购买\n这个比较简单 阿里云腾讯云都可以买,我在腾讯云上面买下了 lipanpanx.com 年费是61\n直接下单就行了,非常简单,不过如果是第一次买的话, 他会要求你进行实名认证, 你需要填写一个信息模板,然后等待审核,认证成功后才能购买,我的过往经验告诉我在腾讯云买域名要比在阿里云买更快,但是腾讯云的域名数据库貌似要比阿里云更新的慢,有些域名在阿里能搜到在腾讯搜不到\n0x32 域名解析服务\n域名解析我用的 cloudflare, 免备案,免费的全球CDN,DNS刷新速度快,域名保护,代码压缩,还有酸爽的开发者模式,还要啥自行车,闭着眼选\n0x33 代码仓库的架构\n源码仓库结构是大仓库套小仓库的形式,把博客的仓库和主题的仓库分割开来,把主题仓库放到博客的仓库里面,通过submodule 进行管理,这个嵌套的源码仓库是私有的仓库,同时还会有个公共的仓库,用来放置最后生成的静态文件:\n我解释下为啥要这么做:\n首先源码仓库进行套娃的原因是确保主题仓库的稳定性,毕竟主题不是自己维护的,所以稳定性非常的重要,万一那天我喝多了对主题瞎改一通,或者在代码有大量更新的时候不小心删除了某个非常重要的主题文件,结果在提交代码的时候正好眼瞎没看到更改, 全部提交, 后面排错真的是瞅瞎眼,或者是主题的作者对主题做了重要的更新,也能很容易的进行同步,如果你直接把主题代码纳入到你的源码仓库,而不是分而治之,那你在更新主题的时候还需要去删掉之前所有的主题文件,然后重新添加新的主题文件,那样的话主题就完全不受版本控制了,而且你自己的更改也无法保留,这非常的蛋疼, 所以源码仓库中的博客仓库和主题仓库非常两个仓库是非常有必要的\n同时还有个问题就是我使用github pages部署我的静态站点, github pages可以很方便的绑定自己的域名,但是github pages仅仅支持公共仓库,对于私有的仓库github pages不提供服务, 为了保护我的源码仓库,我把源码仓库搞成私有的,然后使用github actions在我每次提交代码的时候自动执行生成静态站点文件的指令, 然后把生成的静态站点文件自动部署到我设置好的公开仓库当中.\n有人会觉得把主题当作仓库clone到项目当中是不合理的,很多主题都提供了npm包,为啥不直接安装主题包呢,把主题仓库clone到自己的源码仓库岂不是很麻烦,确实在绝大多数情况下主题包可以很好的满足人们的需求,但是一些定制化的需求是需要去更改主题源码的,这个时候主题包就无法完成需求了.\n0x34 github绑定多域名的问题\n因为我之前做了一个静态的营销网站quenmaimai.com 这个网站使用的仓库是 lipanpan-hub.github.io 这个仓库是github pages的专用仓库, 我在这个仓库里面放了cname文件, 把quenmaimai.com 绑定到了我的github,这样一来我所有的新项目仓库 如果开通 github pages 就会被定向到 quenmaimai.com/仓库名称 这个地址, 但是我申请了新的域名 lipanpanx.com, 我希望某个特定的仓库可以和 lipanpanx.com 进行绑定,然后其他的仓库仍旧和 quenmaimai.com进行绑定, 这个操作确实有点骚气了, 我找了网上的各路大神发的帖子,一顿操作猛如虎,然后一看二百五,没一个能用的,最后通过google找到一篇国外老铁发的文章, 他遇到的问题和我相同, 给出的解决方案也很清晰,亲测完美解决我的问题, 方案如下:\n\n在你的域名服务商网站 找到你的域名设置DNS的地方 添加5条DNS解析记录\n“A Record” with host “@” and value “185.199.108.153”\n“A Record” with host “@” and value “185.199.109.153”\n“A Record” with host “@” and value “185.199.110.153”\n“A Record” with host “@” and value “185.199.111.153”\n“CNAME Record” with host “www” and value “githubUsername.github.io”\n\n前四条A记录 指向 github的IP地址, 最后一条cname记录指向 github pages 的专用仓库地址 github用户名.github.io\n同时在仓库的GitHub pages设置页面也要进行域名绑定  最后就能成功访问 lipanpanx.com 啦\n0x35 github actions的安全问题\ngithub actions一般是在 github的虚拟机里面执行的(也有在其他地方执行的比如容器,比如自己的主机), 可以执行的操作有非常多, 有时候为了方面我们会用到github官方的一些 actions 或者一些第三方的 actions,无论这些actions本身是否是安全的,一定要确定你使用这些actions的方式是安全的.如果阅读了github actions的官方文档就会发现 GitHub actions的文档几乎在任何地方都会提醒你要确保安全, 因为一些actions会操作仓库,所以会需要你提供 personal token给它, 但是personal token的权限实在是太大, 向我这种私有的源码仓库还好, 有些共有的源码仓库如果你直接把person token 填写到actions里面 就非常的危险, 因为这意味着任何访问到你仓库的人都能拿到你的personal token, 所以可以把把你的personal token搞成变量以变量的形式提供给actions,如下图所示:\n\n在途中3号点位处 点击 添加新的 repo secret 就能添加变量了,添加完成变量就能在actions当中访问了\n比如你添加了一个  PERSONAL_TOKEN 的变量, 那么在actions当中你就能通过$&#123;&#123;secrets.PERSONAL_TOKEN&#125;&#125;去访问\n0x37 主题配置文件\nhexo项目当中 对主题进行配置主要使用下面的几种方式:\n\n直接在网站的配置文件(网站根目录的config.json)当中的 theme_config下面添加主题配置\n在网站根目录中添加 _config.[theme].yml 对主题进行配置\n在/source/_data/[theme].yml 当中进行配置\n在 themes/theme 文件夹下面的 主题源码当中找到 config.yml 进行配置\n\n上面的几种方法各有利弊吧, 但是最终我选择了第二种方法 在网站的根目录下面创建了一个 _config.inside.yml 文件配置主题\n我简单说下不选择其他几种方法的原因:\n\n首先是第一种方法 网站的配置和主题的配置放在 一起, 首先会导致这个配置文件内容过长, 读取速度缓慢,而且文件内容过长的时候可读性就会变差, 你找个配置可能要找半天, 还有就是两个既然都放在一起了 只能一起做版本管理 无法单独做版本管理  这就有点蛋疼了\n然后就是第三种方法, 这种古老的方法 几乎已经被抛弃, 主题的配置文件放到 网站的内容目录里面 感觉怪怪的 现如今已经很少人用了\n最后 就是第四种方法, 这种方法就是相当于去修改主题的源码, 对于一般人来说动源码风险还是比较大的 万一改错了 又不知道怎么改回来 那就相当蛋疼,只能重新clone仓库\n\n然后我说一下选择第二种方法的原因:\n首先 在网站的根目录下面创建新的 _config.[theme].yml 能够很好的把网站配置和主题配置分割开来, 两个配置文件单独的做版本控制,单独做版本控制是比较重要的 如果出现问题就比较容易进行方便的代码回滚,就容易排错, 然后还有最妙的一点 就是在Hexo5中上面的 方法1和方法2 和方法4 中的配置文件是同时生效的, 其中方法1的优先级最高, 方法2的优先级居中, 最后是方法4, 如果我们采用第二种配置方法 首先能够确保 themes/theme文件夹下面有个最基本的准确配置(这个配置是主题的作者写的默认配置),然后我们在上层怎么配置都行 大不了配置错了改改就行了 反正有最可靠的基本配置在 怎么改_config.[theme].yml都不怕.关于多处主题配置是如何协同工作的 hexo 官方文档中有比较详细的说明:点击此处查看\n0x36 Inside主题代码注入\n主题的能力是有限的, 别人花精力写的东西我们直接拿过来白嫖那就肯定不能做到十全十美满足你的所有需求, 这个时候就需要代码注入来满足你的需求.\nU2FsdGVkX19E3DDsPX6OtS13/+ii96JnlC3HbU8Cv0tIyy9cs3C/rbkNmBfZm8xJCmHTY4rk5P/BvvbzhzTlMGnBMuRTbRdYzPj5Wuhgp8alrESOjYwv7SXMCg1F1jdrg05/co3KUABvvEz2GWg3nKa3NpYF69kZbFPxNKZ6M5ZIQ2ndtMZG1qe7HSxPt9x/dz91pEOI5j1PB6CVKDoFEYjV0qPOg/pWcBU4MvC7OnxtXNkwfz8tk6NJw8zSaPS1nMaJApji52BfITOfBKltV6tCa2BslbZ+yi6lUuX2lyICPMN/jtgu5bjQqxZ3TqTguJe85OV87dBzsnZb+g/lnbhUbHGTuD+NhkdeqswUvpasgiHVQZebTAbJCBzz86+GYmhbtYUvy5wej78mjwF+ezhdnMVbrV5t508LSBA9hhRBXfdVt3V4A4SuM0qQdkgSkiqpSC++UCUB08s9SFbvt20laAoSDcV2W4gLfWri+7wDyahmSsV1AkPkYZ1Ac/NcLXW5Pu03lMOvIyfNZ4fNLcPLut4BofZllp2TL3uYzbicJMwuG8otNNZgDbLOeB2ucx8IFtQmtXpZ2vEFgjQL46ujsDnaePH0tXPBsTR6CozpocCK/gb5/HorvMn4qAQRllCjh6iiFuWEnvaRn7/yW5MWL8MauafUYX3r8aHdVypqtcMy9ZE+sY5s7XEUPbZ0k3IubexJHhUonknqD7P4euycACj9D/gxWQjgtzLS6RzSQsUFUblyLcYdHpyM8vpQ0vK5XUapAnfNgXy/tXvLNo369fJId1/Afs49lI8EloMoIS3i6L78updh4tOWFZnwtm0cmCFLxjmlWEj4+7IJOu9JiKeFsslAQi/AmzozV9yomo7rzNnbeOkujnypWBrQq9qYt2UpschxAuhv3oUAktpruKXwRa+21kt74RXCxojVAJitku3JiH+8uPzcst9AufHgI8/DUqkOTv/utQt9WrolQi1HEswK14ucitZfbcCmLJkSsuBe/mXi2i0nDJLyycZyjLcuJg/TqP1/ri3MN7+G23RUifgPdeWqPkaROSsBkp6X+nx3Iy++zkl/ljD/L4HaXYhxBhOrG+V2YwTDmFrhZgGX+LaHeDCFVlU18JkSs4xJesqt8Rs32jWJTHJLq+Ci8ficDFQavBMbmB+aIvHmWDQwKnutZN6fSxksfc4idJIEtK08kB5prHx0hwvTwhssAmg1D3fyAgXCcXDguYr01G6QqvM6V0hJoPlJDPu1/+KVvBzwXj1vX0edsm18sRFt4GGvOJAsAF1Sod1H/A6FXdHKMdtNSmKt/fwYQWRgqGnLnJZZ1RjSBnLTD/l6Irgn1x1R9raWEmZkARKCIs9AF7N17D4cD15YAJFV8cyM1R3OfBaEuFM/zCIisWE86oVDO8Zcqu7+0/goznNHZVL49LNV+fs4M03IdrwIv+jGdyHDB73TTDF6ZHwF9/By2GWV+ppsLKDcS8vbC8nhpT/GS1SHaVLvaG+LbhTGziT9g36pzCWYdzjZ4OiR8YLObBrfZidAfm/po929hsOFYHKPuwbNAB2JXKW7jHJvCUmxsiY1BytoAv3eX5BdfuyNeKKGtTUcJrg4QwvqL/guzwVFJXjACatGLdh9BbCNhf323pVQDuUa6GroZkqN4k8jA80Emvoq3w8w07drgKThbwY+95HFnEHto65U+iVEKCCJZC10kKcXtzb/lLhz+8SH7xVDKfhBMyLPVw721DaT0mEWEdi5WT/0fhxh3S0XzUmu35U2IF4Q2sTV9WMzDX06bl6WrdR7dZJVo7CTlda3l+Xrilzkc74fdgu5nJE6tMxZST0FzIkqeC1TdyOAmYXZHJlvA96/Jm8D9g7ywHPssGiu00/KjialEQnc5eIelauQJKLD8KiyvCFW8u2qGKmge1sQfkltenwTjrWX15kCDLBkp71c3cvnXuat5zcNVSMxP6vIxtg/b6V46ngxixEMVXoK7srEZmPpMTOXj302W7nr4reT4sKHM7VkcPDHGNaNMUCcO38VH2w3h/FYBMaKmtp1LgQv6U2SV5DYU/dCYYFmMRobuc5lznWYHGJT8hXMx5vAsVLudjz/5DasLhxML4nCBhhN6cqbgUzlkj3Bir7Fel5MvYg4KYhDyfc/5pP9YOqh2ulB6u/FPCn09ZCM9fYiIfjSrfT1+Cnq5TSs4yXr/j3Fc0yGkO2SmKtX1l/ENqQWJoi3TgfvcVuWQk50lfoR+dnSA9LpCO4VrEdNnU12EJZSfteYh0pHh68L/jHhDV17dNsbQyQDBQ0Szg7ydom2tKc75INvxjripghnXZZkOdb7/T7HJaw63G7uN1eZiZoacuXK636Pg7sUll1PEf1HMq7PvkZewaWuyhIE0kQGzS0ttIaW4oqjTbRJ3caB3F95fOesXf2tzRj5NdISuGqlRcZLPZZjFV0EWqsrKfA7+tNN3Zo3Tf/gG/996zM4OnOdj+cbrGRpOFzSgyV5gXr1ZdNXPkUsL6ZN4GkZuhxIZJ6WWf28r/NKOC2btOg8jgzHXHtcoblpaRG5KAhOnRU1zv47lEnLjmhkihslqeHB1tbYsnqPByPhpjauADzLgiLLRqr4BjhCMEucffUf0a7ChbLvDDGzJgD4mjZ+VlVZrAC2UFee9SEgEWfR7iHw2TQIhAxWGNh14DDk52DFG8dYdpWWMuyX7Q9JyvvQegqUQLE8JeyQRF9SEvL47d/vQwn1NS62u//AznY3EzgRVgJjBfLVZFY9Uu56IUPsSGhKJin3MMk3GY1QdAhal0EQTxpmgiskNGc8LSV750eB35v+DMGOl/TKOJ4YQLH9FQtjABaDAmDhIw10t/IQ0VQxvSyhVTx2fLhBMPGa8jq3PuTIVgLYhbIKTu9873FL6yW5GMT0Lq4EAzvTnIV8U47EaIjnK6VxXYtrQg/zgdoHHhDZgoG2QhHQX/Kbu1/IBCG4uer20F8MwCfdmnfuT+pQTHduKI7ES3IRsTkonJ7O8ga8u4NO7NJrOI99EQcgxFdeFiQnwWnzrFyrnbEkZj+Y4p9UU1q0JA2TFrFSn/VCTXfiB7pfILUSw39b9a+f1oCkylgb7P7tjHN/4jMzY0XaSzZO2pegXcvTQKoQ0Qn3+PHeicmnM7hWrmIfBYRJOb0yZgnOiPBsrE383wMvI+k=当然如果你使用的是Hexo版本&gt;=5的话 你还可以使用hexo的代码注入API方便的注入代码, 直接在网站的根目录下面创建一个scripts文件夹 这个文件夹中的js会自动运行 你只需要在文件夹当中创建js文件然后再js文件当中运行 hexo注入代码的API就可以了,由于inside注入代码的方式已经比较爽了,对于hexo提供的代码注入方式我这里就不再赘述\n0x40 SEO\n很多大佬的个人网站 之所以搞成静态的 其实根本原因就是搜索引擎对静态的站点比较友好,这类站点容易做SEO,设置keyword description 之类的东西, 在hexo的配置文件当中可以进行配置我就不多说了, 这里我主要讲一下 如何去向搜索引擎提交网站的sitemap文件,以及加快搜索引擎索引站点的方法.\n向搜索引擎提交 sitemap的文件的前提是 首先你要有sitemap文件, 那么sitemap文件哪里来呢? 其实可以使用hexo的插件去生成这个sitemap文件,具体步骤如下:\n\n安装相关的插件 npm install hexo-generator-sitemap --save\n然后可以在 hexo的配置文件当中 添加下面的配置\n\n123456sitemap:  path: sitemap.xml  // 生成的sitemap文件存放的位置  template: ./sitemap_template.xml  //生成sitemap文件所使用的模板所使用的位置  rel: false  // 是否将 rel-sitemap 添加到网站的 header当中  tags: true // 是否将tag页面放到sitemap当中  categories: true  //是否将categories 页面放到sitemap当中\n模板我们可以使用插件的默认模板就行了 把默认模板复制下来 保存到网站根目录当中保存成为 sitemap_template.xml就行了\n默认模板地址\n3. 最后执行 hexo g 的时候就能在public 目录下面生成 sitemap.xml了, 这个就是我们需要提交给搜索引擎的重要文件\n由于sitemap文件就存放在网站的根目录下面 所以地址是确定的,我们只要把这个文件的地址提交给搜索引擎,搜索引擎就会每隔一段时间来抓取我们的sitemap文件,来看看网站是否更新了新的内容了\n那么我们如何提交sitemap文件呢?\n提交sitemap文件的一个重要前提 就是验证网站的所有权, 验证网站所有权的方法有很多中,常见为下面几种:\n\n使用DNS的解析记录进行验证(最为简单方便)\n使用HTML的 Meta标记进行验证\n使用一个特殊的验证文件放在网站的某个目录进行验证\n\n下面我讲一下 针对于google bing 和baidu 我是如何快速的验证网站的所有权:\n\ngoogle网站所有权验证方式最为简单, 只需要在域名管理处添加 一条TXT的DNS解析记录就行了\nbing的网站所有权验证方式 也可以通过添加DNS解析记录的方式来完成不过bing需要添加的是CNAME的记录\nbaidu的网站所有权验证方式 同样可以使用添加DNS解析记录的方式  和bing一样添加CNAME记录即可\n\nGoogle网站所有权验证和提交Sitemap的地址: 点击地处打开\nBing网站所有权验证和提交Sitemap的地址: 点击地处打开\nBaidu网站所有权验证和提交Sitemap的地址: 点击地处打开\n提交完成sitemap之后 搜索引擎的爬虫 就会定期的去爬取你的站点的sitemap文件,来确保更新对你网站的收录,这个过程bing是最快的,其次是google,最后是baidu, 这种方式确实很安逸 等着被收录就行了, 就是效率实在太低了, 就算是最快的bing当你的网站更新了之后,它也需要几天的时间才会过来爬取你的站点,因为现在互联网上面的各种 乱七八遭的网站实在是太多了, 各大搜索引擎的爬虫实在是太忙了,一个新站点的权重实在是太小了,他们爬取和更新其他重要的网站时间还不够呢, 谁没事天天到你八百年不更新一篇的小博客来转悠啊,人家的时间成本是很高的,所以我们要变被动为主动, 主动的向搜索引擎提交我们更新的文章的连接,那我们要怎么做呢?\n主动更新搜索引擎收录的方式有两种:\n\n手动向搜索引擎提交连接\n使用搜索引擎提供的API去提交连接\n\n手动提交链接的方式实际上是比较适合更新周期比较长的个人博客的, 但是最为中华人民共和国的新时代青年,我不可能采用这样的方式(主要是太懒的🤣),所以我果断选择使用搜索引擎API去提交链接, 当然网上有现成的轮子可以用,也是我做此选择的主要原因:\n\n先安装插件 npm install --save hexo-submit-urls-to-search-engine\n然后 在hexo的配置文件当中添加下面的配置:\n\n1234567891011121314151617181920hexo_submit_urls_to_search_engine:  submit_condition: count #链接被提交的条件，可选值：count | period 现仅支持count  count: 10 # 提交最新的10个链接  period: 900 # 提交修改时间在 900 秒内的链接  google: 0 # 是否向Google提交,可选值:(0:否,1:是)&#123;google提交链接的API操作比较麻烦,我这里就屏蔽了向google提交链接&#125;  bing: 1 # 是否向bing提交,可选值:(0:否,1:是)  baidu: 1 # 是否向baidu提交,可选值:(0:否,1:是)    txt_path: submit_urls.txt ## 文本文档名， 需要推送的链接会保存在此文本文档里    baidu_host: https://lipanpanx.com ## 在百度站长平台中注册的域名  baidu_token: xxxxxx ## 请注意这是您向baidu提交网站链接的API的秘钥， 所以请不要把它直接发布在公众仓库里!  bing_host: https://lipanpanx.com ## 在bing站长平台中注册的域名  bing_token: xxxxxx ## 请注意这是您向bing提交网站链接的API的秘钥,所以请不要把它直接发布在公众仓库里!  google_host: https://lipanpanx.com ## 在google站长平台中注册的域名  google_key_file: Project.json #存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!  google_proxy: 0 # 向谷歌提交网址所使用的系统 http 代理，填 0 不使用\n\n然后再hexo配置文件的deploy字段下面添加下面三条内容:\n\n1234deploy:  - type: cjh_google_url_submitter  - type: cjh_bing_url_submitter  - type: cjh_baidu_url_submitter\n\n然后执行 hexo g &amp;&amp; hexo d 就能够调用相应的API去向搜索引擎提交你的网页链接给搜索引擎收录了\n\n","plink":"http://blog.lipanpanx.com/post/2021/202101/搭建Hexo博客/"},{"title":"JS的for...in和for...of","date":"2020-10-30T08:29:08.000Z","date_formatted":{"ll":"2020年10月30日","L":"2020/10/30","MM-DD":"10-30"},"updated":"2022-02-01T01:24:26.640Z","content":"for…in 和 for…of的区别和联系\nfor…in和 for…of的区别和联系 似懂非懂的 今天正好有时间把这个东西搞清楚写篇文章纪念一下:\n首先看一个例子 这个例子来自于Difference between for…of and for…in:\n12345678910111213141516171819202122232425262728Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;;const iterable = [3, 5, 7];iterable.foo = &#x27;hello&#x27;;for (const i in iterable) &#123;  console.log(i); // 输出结果: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;    // 首先for...in 会迭代一个可迭代对象所有的 enumerable properties(可枚举属性)   // 因为 继承和原型链的存在 导致 iterable 会从 Object和Array当中继承 objCustom和arrCustom, 这两个东西会被迭代  // 除此之外 数组索引也是可枚举属性 也会被迭代  // 可能有人会问 为什么不会迭代数组的值?  : 因为数组的值 是值 而不是属性, for...in 仅仅用来迭代属性 &#125;for (const i in iterable) &#123;  if (iterable.hasOwnProperty(i)) &#123;    console.log(i); // 输出结果: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;    // 这里通过 hasOwnProperty() 做出判断仅仅对自己的属性进行迭代 不会继承的属性进行迭代  &#125;&#125;for (const i of iterable) &#123;  console.log(i); // 输出结果: 3, 5, 7  // for...of 对可迭代对象的值 进行迭代  而不会可迭代对象的属性 进行迭代 &#125;\n不建议用for…in操作数组\n在上面的例子当中我们可以看到 for…in 可以用来迭代数组中的属性, 但是不仅仅是自己的属性,继承的属性也会被一起迭代, 因为迭代的顺序取决于实现方式,其实for…in的实现方式并不能保证 数组的属性按照某个特定的顺序进行迭代, 如果操作的顺序非常重要的话建议使用Array.prototype.forEach() or for...of. 更详细内容参考:Array iteration and for…in\nfor…in到底用来干嘛呢?\n大部分的 情况下我们使用数组保存我们的数据, 如果for…in 不用来操作数组, 那么这个语句存在的意义又是什么呢?\n其实for…in 用来进行debug还是非常方便的, 毕竟可以输出所有属性, 还有就是针对键值对数据, 如果你想判定某个键值对的键是某个特定的值 那就可以使用for…in 进行很方便的检查. 更详细的内容参考:Why Use for…in?\n如何判定可枚举属性和可迭代对象?\n我们知道 for…in 对对象的可枚举属性进行迭代 而 for…of 对可迭代对象的值进行迭代, 关于可枚举属性和可迭代对象 其实mdn中有相关的文档进行介绍 具体参考下面的链接:\nEnumerability and ownership of properties\nIterables\n","plink":"http://blog.lipanpanx.com/post/2020/202010/JS的for-in和for-of/"},{"title":"Javascript IIFE(Immediately Invoked Function Expression)","date":"2020-10-20T15:38:35.000Z","date_formatted":{"ll":"2020年10月20日","L":"2020/10/20","MM-DD":"10-20"},"updated":"2022-02-01T01:24:26.640Z","content":"IIFE\nJS 里面有个非常有趣的概念 IIFE(Immediately Invoked Function Expression) 这个东西直译过来就是立即调用函数表达式 也被称作 自执行匿名函数(Self-Executing Anonymous Function )\n他的语法格式如下:\n1234(function () &#123;  statements;&#125;)();// function 无名字同时外部括号不能省略\n这玩意 和 Python中立即执行的意境神似:\n12&gt;&gt;&gt; *range(4),# (0,1,2,3)\n下面讲下 IIFE 的三个应用场景:\n1, 避免污染全局名称空间\n因为我们的应用程序可以包含来自不同源文件的许多函数和全局变量，所以限制全局变量的数量非常重要。如果我们有一些不需要再次使用的初始化代码，我们可以使用 IIFE 模式。因为我们不会再次重用代码，所以在这种情况下使用 IIFE 比使用函数声明或函数表达式要好。\n2, 设计模式当中会用到 IIFE,比如模块模式\n1234567891011121314151617181920212223242526272829const makeWithdraw = balance =&gt; (function(copyBalance) &#123;  let balance = copyBalance; // This variable is private  let doBadThings = function() &#123;    console.log(&quot;I will do bad things with your money&quot;);  &#125;;  doBadThings();  return &#123;    withdraw: function(amount) &#123;      if (balance &gt;= amount) &#123;        balance -= amount;        return balance;      &#125; else &#123;        return &quot;Insufficient money&quot;;      &#125;    &#125;,  &#125;&#125;)(balance);const firstAccount = makeWithdraw(100); // &quot;I will do bad things with your money&quot;console.log(firstAccount.balance); // undefinedconsole.log(firstAccount.withdraw(20)); // 80console.log(firstAccount.withdraw(30)); // 50console.log(firstAccount.doBadThings); // undefined; this method is privateconst secondAccount = makeWithdraw(20); // &quot;I will do bad things with your money&quot;console.log(secondAccount.withdraw(30)); // &quot;Insufficient money&quot;console.log(secondAccount.withdraw(20));  // 0\n3, 在不支持 es6 语法的 for 循环中使用 IIFE\n在 ES6 中引入 let 和 const 语句以及块作用域之前，我们可以在一些旧代码中看到下面对 IIFE 的使用。假设我们想要创建两个按钮分别是 Button 0 和 Button 1 被点击的时候我们希望执行alert并分别输出0和1, 下面的代码是无法达到我们的目的的, 因为var定义的变量i位于全局作用域,所以最后我们执行alert的时候输出的总是2:\n123456789for (var i = 0; i &lt; 2; i++) &#123;  const button = document.createElement(&quot;button&quot;);  button.innerText = &quot;Button &quot; + i;  button.onclick = function () &#123;    alert(i);  &#125;;  document.body.appendChild(button);&#125;console.log(i); // 2\n因为在ES6之前不支持let, 而var语句仅支持在全局作用域和函数作用域内定义变量,所以针对上述问题我们可以使用IIFE来解决, 此时 onclick的值不再是一个简单的函数,而是一个立即执行匿名函数, 这个函数返回另外一个函数,被返回的函数在自己的函数作用域内部存储了立即执行匿名函数传递给它的i值, 确保了触发按钮点击事件的时候alert打印的值是正确的.\n1234567891011for (var i = 0; i &lt; 2; i++) &#123;  const button = document.createElement(&quot;button&quot;);  button.innerText = &quot;Button &quot; + i;  button.onclick = (function (copyOfI) &#123;    return function () &#123;      alert(copyOfI);    &#125;;  &#125;)(i);  document.body.appendChild(button);&#125;console.log(i); // 2\n当然如果使用ES6语法我们可以轻松解决上述问题:\n123456789for (let i = 0; i &lt; 2; i++) &#123;  const button = document.createElement(&quot;button&quot;);  button.innerText = &quot;Button &quot; + i;  button.onclick = function () &#123;    alert(i);  &#125;;  document.body.appendChild(button);&#125;console.log(i); // Uncaught ReferenceError: i is not defined.\n","plink":"http://blog.lipanpanx.com/post/2020/202010/Javascript-IIFE/"},{"title":"JS function default parameters and rest parameters","date":"2020-10-20T09:38:19.000Z","date_formatted":{"ll":"2020年10月20日","L":"2020/10/20","MM-DD":"10-20"},"updated":"2022-02-01T01:24:26.640Z","content":"xxx\n","plink":"http://blog.lipanpanx.com/post/2020/202010/JS-function-default-parameters-and-rest-parameters/"},{"title":"CSS伪类 :root","date":"2020-09-30T17:33:42.000Z","date_formatted":{"ll":"2020年9月30日","L":"2020/09/30","MM-DD":"09-30"},"updated":"2022-02-01T01:24:26.640Z","content":"关于伪类 :root 表示的元素 有些人搞不清楚 有说html的 有说body的\n其实 W3C的文档中说的比较明确了\nselectors level 3 中的说明:\nThe :root pseudo-class represents an element that is the root of the document. In HTML 4, this is always the HTML element.\nselectors level 4 中的说明:\nThe :root pseudo-class represents an element that is the root of the document.\nFor example, in a DOM document, the :root pseudo-class matches the root element of the Document object. In HTML, this would be the html element (unless scripting has been used to modify the document).\n所以一般情况下 :root 表示的就是html元素\n如果还是不信 可以使用下面CSS验证:\n123456:root &#123;    border: 10px solid blue;&#125;body &#123;    border: 10px solid purple;&#125;\n如果:root表示 body 就会被下面的 样式覆盖 如果表示html 2个样式共存\n","plink":"http://blog.lipanpanx.com/post/2020/202009/CSS伪类-root/"},{"title":"CSS中的各种单位","date":"2020-09-21T10:25:06.000Z","date_formatted":{"ll":"2020年9月21日","L":"2020/09/21","MM-DD":"09-21"},"updated":"2022-02-01T01:24:26.640Z","content":"","plink":"http://blog.lipanpanx.com/post/2020/202009/CSS中的各种单位/"},{"title":"CSS3 HTML5 多端可用性检查工具","date":"2020-09-18T08:35:31.000Z","date_formatted":{"ll":"2020年9月18日","L":"2020/09/18","MM-DD":"09-18"},"updated":"2022-02-01T01:24:26.640Z","content":"非常漂亮的CSS3可用性在线检查工具 CSS3TEST\n工具地址: CSS3TEST\n开源地址: LeaVerou/css3test\n在你的浏览器上打开 上面这个地址 等到内容完全加载完成之后,你就能看到当前浏览器对CSS3各种标准的兼容情况了,这个在线工具在测试完毕之后会首先给出你浏览器的所有测试用例的通过率,然后会用显色 精细的显示 当前浏览器对某个特定CSS属性的兼容西 从绿色到红色, 绿色表示兼容性良好红色表示不兼容, 而且这个网站 在相关的CSS属性旁边显示 当前属性相关的 W3C 规范文档的地址, 有些属性还会显示相关 W3C dev 工作草稿的地址和MDN 相关教程的提示,简直不要太贴心\n\n但是需要注意的是 这个测试工具 仅仅检查 浏览器是否能够识别某个CSS3特性,关于浏览器是否正确的实现了这个特性并不会去检查(如果检查浏览器是否正确实现感觉一定需要专业的测试人员去测试,估计是无法实现全自动化检查的)\n\n这个项目的发起者是一个大美女(Lea Verou), 她本人的颜值 真的感觉和这个测试网站的颜值一样高,  她在MIT CSAIL 研究web编程, 她还是 W3C TAG(Technical Architecture Group)的成员, CSS WG的特邀专家, CSS规范的制定者之一, PrismJS的作者, 她还拥有 麻省理工学院的计算机科学硕士学位和雅典经贸大学的计算机科学学士学位 同时她还是一家公司的创始人, 真TMD 女神仙.\nHTML5可用性在线检查工具  HTML5TEST\n工具地址: HTML5TEST\n这个工具和 CSS3TEST 使用方法是一样的直接打开上面的链接 然后等待网站加载完成就行了, 这是一个依托于 open device lab的项目, open device lab是一个开放性的实验室, 这个实验室可以为人们免费提供 可用的计算设备, 依托于open device lab的设备, 这个网站提供了丰富的多端浏览器对HTML5的兼容性数据.\n这个网站 不仅会测试W3C发布的官方HTML5规范的兼容行  还会测试 HTML5相关的规范  还有一些 HTML5扩展的实验性特性, WebGL和 已经被抛弃的 WebSQL都会被测试.\n在线工具  caniuse\n工具地址: caniuse\n这个网站我估计很多人都用过或者听说过,这是一个非常不错的网站\n进入到网站的首页之后 直接在顶部的搜索框里面的 输入想要搜索的  CSS属性 或者 HTML标签 就能调出相关数据库当中的 数据供我们查看了, 比如我在搜索框里面输入grid 之后就会返回一系列和CSS grid属性相关的内容,我们截取第一个查看:\n\n上面这张图直接显示出了  CSS Grid Layout(level1) 在各个浏览器的各个版本之下的兼容性 兼容性的好坏可以通过上图当中的方块的颜色看出来, 红色表示不兼容, 橙色表示不完全兼容,绿色表示兼容, 还有一个灰色表示不知道是不是兼容,关于颜色表达的意思在首页底部是有说明的,另外这个颜色还可以通过设置不同的主题而进行更换, 方块上面有个数字就是这一列表示的浏览器的版本号,表示该浏览器的不同版本,但是有些方块上面是用一个段横杠连接的2个数字,其实这个表示 这2个版本之间的所有版本(因为这些版本的的兼容性一致所以压缩显示),当我们把鼠标移动到 方块之上 还可以看到关于当前浏览器版本关于当前属性更加详细的信息.\n然后我们再看下底部一栏 有下面这几个选项卡我依次解释一下:\nNotes: 比如某个属性在相应的浏览器必去加前缀才能使用 或者旧的浏览器必须加垫片才能用 或者必须打开某些flags才能用 或者浏览器对属性的实现和W3C的标注不一致 或者某些浏览器的糟糕实现有bug 这些比较重要的东西都会在这里进行说明\nTest on a real browser: 借助browserstack的在线服务 你可以在真机的指定浏览器上访问已经写好并发布的页面 来测试兼容性\nKnow issues: 相关的bug\nResources: 相关资源 比如规范文档地址 相关github项目地址 相关教程文档地址\nFeedback: 如果你在图表里面发现了什么不对的地方或者有啥问题可以在这里提出点击submit提交给维护团队,或者你可以直接从这里进入到相关的github相关页面提交PR\n除了如上所示的显示单个CSS属性的兼容性之外, caniuse 还支持讲多个相关属性聚合起来 一起显示兼容性的信息,比如上面我们查询了grid相关的CSS属性的兼容性,然后会出来一堆结果,我们讲滚动条滑动到底部,底部会出现2个按钮 show summary 和 show more,点击 show summary就可以聚合显示 grid相关的属性的兼容性了, 但是有个问题就是不会显示全部的grid相关属性 而且也不会像单个属性显示那样把一些细节显示出来,但是显示效果还是不错的,鼠标放在对应的方块上面直接可以显示某个版本的浏览器对多个CSS属性的兼容性,效果如下:\n\ncaniuse的浏览器兼容性数据的来源:\nmdn/browser-compat-data\nFyrd/caniuse\n以公开仓库的形式存在也就以为着可以允许很多的人一起维护,一起确保内容的正确性,目前位置这2个仓库的contributor都超过了700人,只要按照 readme/wiki当中的规则提交PR国内的浏览器的兼容性信息其实也可以实时同步上去的.\n另外这些github 仓库不仅仅为 caniuse 提供数据, 还为很多前端工具提供数据支持 比如:babel-preset-env browserslist\n","plink":"http://blog.lipanpanx.com/post/2020/202009/CSS3-HTML5-多端可用性检查工具/"},{"title":"CSS伪类 child-indexed 伪类 与 typed child-indexed 伪类","date":"2020-09-02T11:16:12.000Z","date_formatted":{"ll":"2020年9月2日","L":"2020/09/02","MM-DD":"09-02"},"updated":"2022-02-01T01:24:26.640Z","content":"参考文档:\nselectors level 4(WD-&gt;WD) Tree-Structural pseudo-classes\nselctors level 3(REC-&gt;REC) Structural pseudo-classes\n这篇文章讲一下 child-indexed伪类选择器 和 typed child-indexed伪类选择器的区别与联系:\n\n\nchild-indexed 伪类\ntyped child-indexed 伪类\n\n\n\n\n:nth-child\n:nth-of-type\n\n\n:nth-last-child\n:nth-last-type\n\n\n:first-child   \n:first-of-type\n\n\n:last-child    \n:last-of-type \n\n\n:only-child    \n:only-of-type \n\n\n我相信正常人都能看得出来左右2栏 是一一对应的关系, 也就是说child-indexed伪类选择器和typed child-indexed伪类选择器选择元素的思想 其实是大同小异的 学会一种另外一种也就会了\n假设我们有一个类名 为 .first 的div, 这个div里面装满了各种html元素 &lt;span&gt; &lt;em&gt; 等等, 添加一些基础样式, 然后我们就用这个 初始环境 来做实验:\n1234567891011&lt;div class=&quot;first&quot;&gt;  &lt;span&gt;Span 1!&lt;/span&gt;  &lt;span&gt;Span 2&lt;/span&gt;  &lt;span&gt;Span 3!&lt;/span&gt;  &lt;span&gt;Span 4&lt;/span&gt;  &lt;span&gt;Span 5!&lt;/span&gt;  &lt;span&gt;Span 6&lt;/span&gt;  &lt;span&gt;Span 7!&lt;/span&gt;  &lt;span&gt; &lt;em&gt; EM 0&lt;/em&gt;&lt;/span&gt;  &lt;em&gt;EM 1&lt;/em&gt;&lt;/div&gt;\n123456span, div  em &#123;  padding: 5px;  border: 1px solid green;  display: inline-block;  margin-bottom: 3px;&#125;\n在没有使用选择器之前 渲染结果如下:\n\n\n:nth-child()\n使用如下选择器增加样式:\n123div.first span:nth-child(2n+1) &#123;  background-color: lime;&#125;\n\n可以看到 按照 1,3,5,7… 这种规则把选中的span 背景变为了 lime\n第9个元素 由于 不是span 所以背景没有发生变化\n此时如果我们在第三个span的前面增加 一个 em 会发生什么呢?\n\n我们可以看到 现在第三个元素 由于不是span 而被 直接跳过  渲染结果为 第1,5,7,9,11…的背景为lime\n这样以来 我们就可以看出 child-indexed 伪类选择器的计数规则是对所有的兄弟元素计数\n然后只操作符合自己选择规则的元素, 对于那些虽然被计数规则命中 但是不符合选择器规则的 元素 不进行任何操作\n:nth-last-child()\n恢复初始环境 增加如下 样式:\n123div.first span:nth-last-child(1) &#123;\tbackground-color: blue;&#125;\n\n结果 最后一个元素变成蓝色了 当我们把1 改成2之后蓝色消失  再把2改成4之后效果如下：\n\n可以看到 :nth-last-child() 采用的是 反序计数的方式\n:first-child 和 :last-child\n从字面意思上就可以看的出来 :first-child 选择第一个元素 :last-child选择最后一个元素\n123456div.first span:first-child&#123;\tbackground-color: red;&#125;div.first span:last-child&#123;\tbackground-color: orange;&#125;\n\n\n这里有个非常重要的注意点:\n在 a 不是 root 元素的前提下  a:first-child 和 * &gt; a:first-child 是等同的(这里表示a是任何元素的第一个child)\n\n:only-child\n这个 :only-child 则只选择那些 没有兄弟元素的元素 在我们的基础环境当中 EM1 它的左侧是一个包含EM0的span 右侧是 span8 毫无疑问它有兄弟元素  而EM0 被 一个span 包裹 且这个span仅有一个子元素 所以当我们添加如下样式的时候:\n123div.first em:only-child&#123;\tbackground-color: cyan;&#125;\n\n我们看到仅仅 EM0被选中了\ntyped child-indexed 伪类选择器\ntyped child-indexed 伪类选择器 和 child-indexed伪类选择器 仅仅有一点区别 这点区别是啥呢?\n其实也很简单 就是 对被选择元素的计数规则不同, child-indexed伪类选择器 采取的策略是依次对所有的元素进行计数, 而typed child-indexed 伪类选择器采取的策略 则是仅仅对相应类型的元素进行计数:\n比如在上面的基础环境当中:\ndiv.first span:nth-child(2n+1) : 会找到.first下的所有的奇数位置上的元素然后再判断是不是span,确实是span之后进行操作,如果不是span则不进行任何操作\ndiv.first span:nth-of-type(2n+1): 首先遍历 .first下的所有span 然后按照先后顺序对span进行排序,之后再去已经排序完成的span队列当中找到 奇数位置上的span  进行操作\n上面我们不是有个增加em的例子:\n\n这里当我们把 nth-child 换成 nth-of-type 之后效果如下:\n\n因为 child-indexed伪类选择器 和 typed child-indexed 伪类选择器 家族的几个伪类选择器的差异是完全相同的我这里就不在对其他的选择器进行举例说明.\n非常需要注意的点\n\n无论是 child-indexed伪类选择器 还是 typed child-indexed 伪类选择器  他们仅仅对兄弟元素进行计数\n\n\n对于 child-indexed伪类选择器 如果某个元素只命中计数规则 而没有命中选择器规则, 则不会进行任何操作 你看不出来任何选择器被应用的迹象\n\n\n在旧的标准当中 :first-child :last-child :only-child 和 :first-of-type :last-of-type :only-of-type 这几个伪类选择器 选中的元素都必须 有一个父元素  但是在 selectors level 4 标准中 被选中的元素的父元素 却不是必须的\n\n\n在 a 不是 root 元素的前提下  a:first-child 和 * &gt; a:first-child 是等同的(这里表示a是任何元素的第一个child), 同理 div:nth-child(x)  等同于 * &gt; div:nth-child(x).\n这里有个非常有趣的例子:\n\n123456789101112131415161718&lt;style&gt;  body div:first-child&#123;      background-color: pink;  &#125;/*在这里 body div:first-child 的效果与 * &gt; div:first-child(div:first-child)的效果是相同的 */&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;\n","plink":"http://blog.lipanpanx.com/post/2020/202009/CSS伪类选选择器nth-child和nth-of-type/"},{"title":"CSS选择器","date":"2020-09-02T10:56:36.000Z","date_formatted":{"ll":"2020年9月2日","L":"2020/09/02","MM-DD":"09-02"},"updated":"2022-02-01T01:24:26.640Z","content":"相关参考文档\n注意 在W3C的标准当中并不存在一种选择器 可以用来选择父元素 父元素的兄弟元素 或者父元素的兄弟元素的子元素\nless scss stylus 这些预处理器 提供了更多的功能 但是不在规范当中\n\n基本选择器\n通用选择器\nns | *  : 匹配 名称空间ns 当中的 所有元素\n* | * : 匹配 所有的 元素\n  | * : 匹配所有没有声明工作空间的 元素\n此外 再简单的选择器当中 其实* 是被省略的  比如 类选择器 .warning 它本应该是  *.warning\n类型选择器\n也叫标签选择器用来选择HTML标签的\nns | h1  : 匹配 名称空间ns 当中的 所有h1元素\n* | h1 : 匹配 所有的h1 元素\n  | h1 : 匹配所有没有声明工作空间的 h1元素\n[类选择器]\n.class_name { style properties }\n根据元素的class属性选择元素  从语法上讲 这个选择器 等同于 属性选择器当中的 [class~=class_name] { style properties }\n[ID选择器]\n#id_value { style properties }\n根据元素的 id属性选择元素 从语法上讲这个选择器 等同于 属性选择器当中的 [id=id_value] { style properties }\n[属性选择器]\n根据元素的某个属性是否存在或者是否等于某个值 来选择元素\n[attr] : 选择存在属性attr的元素\n[attr=value] : 选择存在属性attr 并且attr的值恰好为value 的元素\n[attr~=value] : 选择存在属性attr 并且attr的值一个以空格分割的单词列表 列表当中有个值是value 的元素\n[attr|=value] : 选择存在属性attr 并且attr的值是value 或者以 value- 开始的元素\n[attr^=value] : 选择存在属性attr 并且attr的值是以value作为前缀的元素\n[attr$=value] : 选择存在属性attr 并且attr的值是以value作为后缀的元素\n[attr*=value] : 选择存在属性attr 并且attr的值中value至少出现一次  的元素\n[attr operator value i] : 在右括号之前添加i/I 在对比值的时候 会忽略大小写 (仅仅对 ASCII字符有效)\n[attr operator value s] : 在右括号之前添加s/S 在对比值的时候 大小写敏感 (仅仅对 ASCII字符有效,并且这个标志是实验性质的某些浏览器不支持加入s标志反而会让浏览器不能正常显式 因为很多浏览器默认情况下 是大小写敏感的 所以这就无需支持这个 标志了)\n下面这个例子非常形象的展示了属性选择器的使用场景:\n12345678910111213141516171819202122232425262728293031&lt;style&gt;  a &#123;    color: blue;  &#125;  a[href^=&quot;#&quot;] &#123;    background-color: gold;  &#125;  a[href*=&quot;example&quot;] &#123;    background-color: silver;  &#125;  a[href*=&quot;insensitive&quot;i] &#123;    color: cyan;  &#125;  a[href*=&quot;cAsE&quot;s] &#123;    color: pink;  &#125;  a[href$=&quot;.org&quot;] &#123;    color: red;  &#125;  a[href^=&quot;https&quot;][href$=&quot;.org&quot;] &#123;    color: green;  &#125;&lt;/style&gt;&lt;ul&gt;  &lt;li&gt;&lt;a href=&quot;#internal&quot;&gt;Internal link&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;http://example.com&quot;&gt;Example link&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;#InSensitive&quot;&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;http://example.org&quot;&gt;Example org link&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;https://example.org&quot;&gt;Example https org link&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n虽说很多浏览器在对比value的值的时候默认情况下是大小写敏感的 但是也有例外那就是 处理有序列表的type属性的时候\nHTML规范要求type属性匹配大小写不敏感，因为它主要用于&lt;input&gt;元素，\n所以我们使用 ol[type=“a”] 和 ol[type=“A”] 都能选中 &lt;ol type=&quot;A&quot;&gt;&lt;/ol&gt; 除非我们使用s标志进行区分\n但是并不是所有的浏览器都是支持 s标志的(比如chrome), 所以 这些浏览器当中就不能用属性选择器 去分别选择 &lt;ol type=&quot;A&quot;&gt;&lt;/ol&gt; 和 &lt;ol type=&quot;a&quot;&gt;&lt;/ol&gt; 不过可以用其他的选择器 问题不大\n\n组合选择器\nelement, element, element { style properties }\n组合选择器 也叫做 CSS 选择器列表, 列表中的选择器用逗号分开 括号中的样式对所有选择器选中的元素生效\n1234567h1, h2, h3, h4, h5, h6 &#123; font-family: helvetica; &#125;#main,.content,article &#123;  font-size: 1.1em;&#125;\n组合选择器书写方便, 并且可以减小样式表的大小 但是使用组合选择器还是有一定弊端的,比如下面的情况:\n12345678910h1 &#123; font-family: sans-serif &#125;h2:maybe-unsupported &#123; font-family: sans-serif &#125;h3 &#123; font-family: sans-serif &#125;h1, h2:maybe-unsupported, h3 &#123; font-family: sans-serif &#125;/* 这里看似与上面的样式等同 实则不然 因为一旦h2是不支持的 整条规则都会失效 h1和h3的样式也会丢失 *//* 补救的方式就是使用 :is/:where 伪类 */:is(h1, h2:maybe-unsupported, h3) &#123; font-family: sans-serif &#125;\n\n复合选择器\n[后代选择器]\nformer_element target_element {/* property declarations */}\n如果 former_element 被命中 则 其后代中的所有 target_element都会被选择\n注意: 前后2个选择器之间的空白字符 可以是空格 或者 4个控制字符之一( carriage return, form feed, new line, and tab characters) 或者他们之间相互组合, 此外这两个选择器之间的空白字符中可以包含任何的 CSS注释\n12345678910111213141516171819202122232425&lt;style&gt;  li &#123;    list-style-type: circle;  &#125;  li/*这个li是一个容易被忽视的 former_element */  li &#123;    list-style-type: disc;    border: 1px solid pink;  &#125;&lt;/style&gt;&lt;ul&gt;  &lt;li&gt;Item 1    &lt;ul&gt;      &lt;li&gt;Subitem A&lt;/li&gt;      &lt;li&gt;Subitem B&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;    &lt;li&gt;Item 2    &lt;ul&gt;      &lt;li&gt;Subitem A&lt;/li&gt;      &lt;li&gt;Subitem B&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;\n[直接子代选择器]\nformer_element &gt; target_element { style properties }\n第二个选择器匹配的元素必须是第一个选择器匹配的元素的直接子元素。\n这比后代选择器更严格，后代复合选择器匹配所有由第二个选择器匹配的元素只要他们有共同的祖先元素，而不考虑DOM上的“跳跃”次数。\n1234&lt;div&gt;    &lt;!-- 这里虽然有2个span 但是 仅仅有一个是div的直接子元素 另外一个是这个直接子元素的子元素  --&gt;  &lt;span&gt;Span #1, in the div. &lt;span&gt;Span #2, in the span that&#x27;s in the div.&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;\n[一般兄弟选择器]\nformer_element ~ target_element { style properties }\n对于这个复合选择器而言 former_element 和 target_element 首先是兄弟元素 他们拥有相同的父元素 首先找到former_element 然后former_element 下面 的的 所有 target_element 都会被选择\n123456789101112131415161718192021&lt;style&gt;  p + span &#123;    color: red;  &#125;&lt;/style&gt;&lt;span&gt;This is not red.&lt;/span&gt;&lt;p&gt;Here is a paragraph.&lt;/p&gt;&lt;code&gt;Here is some code.&lt;/code&gt;&lt;span&gt;And here is a red span!&lt;/span&gt;&lt;span&gt;And this is a red span!&lt;/span&gt;&lt;code&gt;More code...&lt;/code&gt;&lt;div&gt; How are you? &lt;/div&gt;&lt;p&gt; Whatever it may be, keep smiling. &lt;/p&gt;&lt;h1&gt; Dream big &lt;/h1&gt;&lt;h2&gt; that&#x27;s all. &lt;/h2&gt;&lt;span&gt;And yet again this is a red span!&lt;/span&gt;\n[相邻兄弟选择器]\nformer_element + target_element { style properties }\n对于这个复合选择器而言 former_element 和 target_element 首先是兄弟元素 他们拥有相同的父元素 首先找到former_element 然后 仅仅对former_element 下面 紧挨着的那个元素做选择(仅仅选择一个)\n123456789101112131415161718&lt;style&gt;  p + span &#123;    color: red;  &#125;&lt;/style&gt;&lt;span&gt;This is not red.&lt;/span&gt;&lt;p&gt;Here is a paragraph.&lt;/p&gt;&lt;span&gt;And here is a red span!&lt;/span&gt;&lt;span&gt;And this is a red span!&lt;/span&gt;&lt;code&gt;More code...&lt;/code&gt;&lt;div&gt; How are you? &lt;/div&gt;&lt;p&gt; Whatever it may be, keep smiling. &lt;/p&gt;&lt;h1&gt; Dream big &lt;/h1&gt;&lt;h2&gt; that&#x27;s all. &lt;/h2&gt;&lt;span&gt;And yet again this is a red span!&lt;/span&gt;\n\n伪类/伪元素 选择器\n[伪类选择器]\nselector:pseudo-class { property: value; }\nCSS伪类是添加到选择器中的关键字，它指定了所选元素的特殊状态。例如:hover可以用来在用户的指针悬停在按钮上时改变按钮的颜色。\n伪类允许您将样式应用到一个元素,不仅和文档树的内容有关,还与外部因素有关系\n例如导航的历史(例如:visited),其内容的状态(表单元素:checked),或鼠标的位置(如:hover,它让您知道鼠标是否在某个元素上)。\n[伪元素选择器]\nselector::pseudo-element { property: value; }\nCSS伪元素是添加到选择器中的一个关键字，它允许你对所选元素的特定部分进行样式设计。例如，::first-line可用于更改段落第一行的字体。\n","plink":"http://blog.lipanpanx.com/post/2020/202009/CSS选择器/"},{"title":"波士顿动力狗SPOT购买指北","date":"2020-07-19T17:34:57.000Z","date_formatted":{"ll":"2020年7月19日","L":"2020/07/19","MM-DD":"07-19"},"updated":"2022-02-01T01:24:26.640Z","content":"波士顿动力狗 SPOT 权威购买指北\n\n\n两周前 油管科技视频播主 Lew Later 发布了一支 波士顿动力狗子的开箱视频,短短两周的时间内这支视频的播放量就达到了367万, 在Lew Later 近期发布的视频中,这支视频的播放量绝对算得上遥遥领先了, 国内媒体也纷纷转发, 大家对这条视频如此的热衷,主要原因还是这次开箱应该是世界上第一台民用版本的波士顿动力狗的开箱视频了.\n\n\n波士顿动力的狗子 总共有3个版本 分别是  探索版, 企业版, 教育版. 其中企业版和教育版本只对有相关资质的企业,高校以及科研机构开放,官方也没有提供线上购买渠道, 而是需要你自己去联系波士顿动力进行沟通购买, 而探索版面向的群体就比较全面了,官网直接提供了在线购买的链接,可以在线付款购买.  本次开箱的版本就是探索版了,因为官方在不久之前开放了探索版的购买入口,这使得  Lew Later 的这次开箱成为可能. 不过我觉得真正促成这次开箱达成的还是油管播主雄厚的财力, 下面的售价大家感受一下:\n\n\n\n标准版的狗子 押金1000美金,折合成人民币就是6998元(你交全款的时候押金会退还), 全款 74500美金 折合成人民币就是  521363元 没有现货只能预定(6-8周内发货)\n\n\n另外官方还给这条狗子配了很多配件,大家感受下把配件整全的价格:\n\n\n\n全部的官方配件配全的价格是 164595美元 折合人民币就是 1151862元, 这个价格可以买 3辆高配版的Tesla model 3,我放张图让大家直观的感受下:\n\n\n\n看完这条狗子令人咋舌的售价之后,我们再来看下这条狗子的各方面参数,看下是否值这个价钱:\n\n\n首先这条狗长1.1m,宽0.5m,站立高度0.84m, 坐下的高度是0.191m,净重量32.5kg, 如果带上一块电池的话就是36.4kg,(电池重4.2kg),从这些参数来看的话,这条狗子和家里不要钱的狗子在个子大小和重量方面几乎差不多,不过续航时间远不如家里不要钱的狗子, 这条狗子标配的单电池容量是650Wh, 不带负载的平均运行时间是1.5个小时,如果狗子待机不动,这个电池也仅能支撑3个小时,更加坑的是电池充满电需要2个小时, 充电2小时运行1.5小时,确实给人一种不划算的感觉, 不过好在这块电池 支持交流100-240V 50-60Hz的电源进行充电,直接可以在国内使用, 电池输出的是35-58.6V的直流电,最大输出电流7.2A,可以在0-40度的温度之间正常输出. 狗子的连接方式也很现代化, 支持 WIFI 2.4Ghz b/g/n的无线网络,同时也支持千兆以太网进行连接,同时这条狗子的防水等级是IP54,可以在-20-45度的环境下快活的奔跑, 虽然防水, 续航 和工作温度方面的参数都远不如家里不要钱的狗子, 但是波士顿动力的狗子的眼睛是真的多, 全身配备了5组RGBD相机, 前侧2条, 左右侧各一条, 屁股上面一条, 水平可视范围是360度,传感器的水平探测范围是4m, 可以感受大于2lux的光, 从而确保这条狗子能够看清楚身体周围的任何障碍物并与之保持距离, 避免发生不必要的摩擦. 狗子买回来是要拿出去溜的, 这条狗子的运动性能如何呢? 最高速度1.6m/s, 可以上下 ±30°的斜坡, 和高度为300mm的台阶, 这个运动能力, 在现在的机器人世界绝对可以说是一骑绝尘了, 而且这条狗子可以连接其他的高精度的传感器模块,来支持更高精度的视觉范围和更加灵活的运动能力, 狗子的背部有  850 mm (L) x 240 mm (W) x 270m m (H)大的区域可以用来放东西, 可以直接把官方的扩展模块放到这里, 这条狗子的最大负重是14kg, 用来装官方的那些配件是足够了, 而且狗子身上还有两个DB25的接口, 可以用来传输数据和供电, 支持35-58.8V的直流电输出, 每个接口的输出功率是150W, 可以允许你通过硬件接口去控制狗子也可以通过官方提供的软件接口用Python来控制狗子, 而且官网还为这条狗子配备了一个7寸的安卓控制器,分辨率是1920x1200, 大小是:143.6 mm(H)x274 mm(W)x53 mm(H) 是不是感觉很棒, 这条狗子绝对比家里不要钱的狗子听话多了. 我放几张图让大家感受下这条狗子出色的运动能力:\n\n\n\n\n\n\n\n怎么样看完上面的参数描述是不是已经急着要下单了? 是不是像我一样已经开始纠结用微信付款还是用支付宝付款了呢?  经过长达24小时的思想斗争之后我决定用微信付款, 是的我决定用微信付款, 为什么? 因为我的支付分没有pony高, 这让我很不爽. 拿出手机打开微信扫一扫, 颤抖的左手拿着手机,颤抖的右手滑动鼠标,点击购物车里的checkout, 进入checkout页面之后我着实松了一口气, 因为官方既不支持微信也不支持支付宝,但是比较坑的是它只卖给美国人, 收获地址不允许选择除了美国地区以外的范围, 我怒了, 可以不让我买, 但是你不允许我的小伙伴买你是几个意思?\n\n\n\n于是我连夜联系波士顿动力的客服, 最后得到的答复是 除美国以外的地区都不卖只能租, 但是有个好消息是波士顿动力有一套流程是可以让你从一个长期的租赁者变成一个购买者的, 比如说你租个5-10年, 后面这个狗子可能就是你的了.具体情况还要自己去联系波士顿动力的客服. 国内的用户想要租赁这条狗子的话,可以自己去官网联系客服, 也可以在公众号早睡蟒 后台回复跬蟒加我微信,我帮你沟通一波.\n\n\n最后看下官方的探索版狗子标准套装的发货清单:\n\n\n1条狗子\n2个狗子电池\n1个狗子电池充电器\n1个狗子的遥控器还有遥控器的充电器\n1个装狗子的大箱子\n1个装狗子电池,遥控器的小箱子\n1个双目视觉标定板\nPython客户端开发包\n软件更新许可\n后续的支持服务许可\n\n\n\n国内用户租赁狗子联系连接:\nhttps://www.bostondynamics.com/spot-sales\n\n","plink":"http://blog.lipanpanx.com/post/2020/202007/波士顿动力狗SPOT购买指北/"},{"title":"Python设计模式-单例模式","date":"2020-07-03T17:48:01.000Z","date_formatted":{"ll":"2020年7月3日","L":"2020/07/03","MM-DD":"07-03"},"updated":"2022-02-01T01:24:26.640Z","content":"什么是单例模式?\n\n单例模式是一种写程序的方式,用单例模式设计的类,无论你去实例化多少次,得到的都是同一个实例,一般我们设计的类每次实例化都会生成不同的实例,但是单例模式就是反其道而行之,就像下面这样:\n\n\n\n上图中的ClassA和ClassB 都是采用的 单例设计模式,而ClassC没有采用单例设计模式\n\n\n我们可以清晰的看到 ClassA的两个不同的实例在内存中的地址是相同的,也就是说两次实例化得到的对象是同一个对象,ClassB和ClassA也是一样的,因为都采用了单例设计模式, 而ClassC因为没有采用单例设计模式所以他的两个实例对象指向不同的内存地址,也就是说两次实例化得到的是两个不同的对象.\n\n为什么需要单例模式?\n\n要弄清楚为什么需要单例模式, 首先需要知道单例模式提供了哪些优秀的特性?\n\n单例模式提供的最为优秀的特性就是:单例模式可以允许你在程序的任何地方访问某个特定的对象\n\n通过单例设计模式, 你可以在不定义全局变量的情况下,在程序的任何地方访问你所指定的对象,单例模式所提供的功能和全局变量是一样的, 但是通过单例模式设计, 你就可以在无需牺牲代码可读性和安全性的前提下完成和全局变量完全一样的功能. 单例模式吸收了全局变量的优点摒弃了全局变量的缺点,是替代可恶全局变量不二的选择.\n\n在上面的例子中我们可以看到无论实例化多少次ClassA得到的都是同一个对象, 如果这个类处于一个比较大的工程中,在这个工程中的任何位置实例化ClassA得到的都是同一个对象,这不就是全局变量吗, 但是和全局变量不同的是通过单例模式产生对象的代码更加的易读,而且这种面向对象的编程方式可以确保ClassA所产生的对象只能被对象自身的方法所操作, 这样就更加的安全, 而且你可以通过获取实例的方法对返回对象的行为进行更多的限制.\n\n为什么需要单例模式? 本质上是因为人们需要全局变量,需要一个更加好用更加安全的全局变量, 单例模式的出现解决了全局变量的现有问题, 所以人们才需要单例模式\n\n单例模式和全局变量的区别?\n\n单例模式像极了全局变量, 但是单例模式毕竟不是实现全局变量, 除了上述所说的异同点之外, 通过单例模式产生的对象和全局变量还有一个明显的区别就是全局变量一旦定义就绝对不会再发生改变, 但是单例模式虽然说每次返回的都是一个固定的对象, 但这个固定的对象还是可以通过单例类自身的一些方法去更改的,所以单例模式产生的对象和全局变量比起来只能说是相对固定的.\n\n单例模式如何实现?\n\n任何一门语言要想实现单例模式,可能都有很多的实现方法,但是实现思路大同小异,肯定都是在第一次生成实例的时候就直接把实例给存储到某个地方,然后在下一次实例化的时候直接返回这个事先被存储起来的实例,而不是重新去实例化返回一个新的实例.\n\n基于装饰器的实现\n\nPython实现单例模式一个比较优雅的实现方式就是通过装饰器去实现,如下所示:\n\n12345678910111213141516171819202122232425262728def singleton(cls):    instances = &#123;&#125;    def getinstance(*args,**kwargs):        if cls not in instances:            instances[cls] = cls(*args,**kwargs)        return instances[cls]    return getinstance@singletonclass ClassA:    pass@singletonclass ClassB:    passclass ClassC:    passaa=ClassA()aaa=ClassA()bb=ClassB()bbb=ClassB()cc=ClassC()ccc=ClassC()\n\n上面的例子我们可以看到singleton是一个装饰器函数, 通过闭包的原理让其内部的 instances 变量的生命周期和全局变量等同,然后把被装饰的类第一次实例化生成的对象直接存储在instances中,在取对象的时候直接从在instances字典中找到事先存储好的对象返回,就是通过这样的方式实现单例的.\n\n\n单例模式的实现方式还有很多种: 比如通过类属性实现, 通过元类实现等多种方式, 甚至每一种实现可能都有自己特定的应用场景, 但是我觉得通过装饰器实现最为优雅, 本着少就是多的原则, 其他的实现方式我就不再赘述, 如果对其他的实现方式感兴趣可以加我微信(备注好公司岗位)交流沟通.\n\n","plink":"http://blog.lipanpanx.com/post/2020/202006/Python设计模式-单例模式/"},{"title":"Python海象算子(赋值表达式)","date":"2020-06-21T11:29:58.000Z","date_formatted":{"ll":"2020年6月21日","L":"2020/06/21","MM-DD":"06-21"},"updated":"2022-02-01T01:24:26.640Z","content":"python 3.8 更新文档里面第一个 feature就是海象算子, 这个在python社区闹得沸沸扬扬的操作符到底好用吗? 今天这篇文章我就来试一试:\n首先需要讲下海象算子 因为长得样子像海象所以才叫海象算子 其专业名称叫做赋值表达式(Assignment expressions) 是不是感觉和python的赋值语句(assignment statement)很像, 其实二者是相互冲突的, 在设计时为了简化用户的选择, 添加了一个确保二者不能同时生效的规则, 通俗点来说就是 能 直接 用赋值表达式的地方就不能 直接 用赋值语句 反之亦然.\n为了让文章更加容易理解 下文中一律使用 赋值表达式 来表示 海象算子\n赋值表达式简化操作场景\n123if (n := len(a)) &gt; 10:    print(f&quot;列表a中元素个数是 &#123;n&#125;&quot;)# 这里使用赋值表达式 避免了重复使用len 计算长度\n123discount = 0.0if (mo := re.search(r&#x27;(\\d+)% discount&#x27;, advertisement)):    discount = float(mo.group(1)) / 100.0\n12while (block := f.read(256)) != &#x27;&#x27;:    process(block)\n不允许直接使用赋值表达式的场景\n为了避免歧义和用户混淆 在一些场景下不得使用赋值表达式或者说此时使用赋值表达式需要进行特殊处理:\n123# 不带括号的 赋值表达式 禁止出现在 表达式语句的 top level y := f(x)  # INVALID(y := f(x))  # Valid, though not recommended\n1234# 赋值语句的右侧 可以是一个表达式 但这个表达式的top level不能出现不带括号的赋值表达式 y0 = 2+3y0 = y1 := f(x)  # INVALIDy0 = (y1 := f(x))  # Valid, though discouraged\n1234# 赋值表达式不能直接作为函数的关键字参数foo(x = y := f(x))  # INVALIDfoo(x=(y := f(x)))  # Valid, though probably confusing# 包含此规则是为了禁止过度混乱的代码，并且因为解析关键字参数已经够复杂了。\n12345# 赋值表达式不能直接作为函数参数的默认值def foo(answer = p := 42):  # INVALID    ...def foo(answer=(p := 42)):  # Valid, though not great style    ...\n12345# 赋值表达式 不能直接作为 函数参数的提示 def foo(answer: p := 42 = 5):  # INVALID    ...def foo(answer: (p := 42) = 5):  # Valid, but probably never useful    ...\n12345# 赋值表达式不能直接在lambda函数当中出现(lambda: x := 1) # INVALIDlambda: (x := 1) # Valid, but unlikely to be useful(x := lambda: 1) # Validlambda line: (m := re.match(pattern, line)) and m.group(1) # Valid\n123456# 赋值表达式在f-string中也不能直接出现 因为会被当成格式控制字符&gt;&gt;&gt; f&#x27;&#123;(x:=10)&#125;&#x27;  # Valid, uses assignment expression&#x27;10&#x27;&gt;&gt;&gt; x = 10&gt;&gt;&gt; f&#x27;&#123;x:=10&#125;&#x27;    # Valid, passes &#x27;=10&#x27; to formatter&#x27;        10&#x27;\n赋值表达式和赋值语句的区别\n由于:= 是一个表达式, 所以它可以被用在 使用赋值语句不合法的上下文当中 包括lambda函数 和 推导式当中.\n但是 与之相反的是 赋值表达式 不支持 一些能被赋值语句所使用的高级特性.\n123456789101112131415161718192021222324252627# 赋值语句的连续赋值 不能被赋值表达式直接支持x = y = z = 0  # Equivalent: (z := (y := (x := 0)))# 如下语不能通过赋值表达式实现a[i] = xself.rest = []# 赋值语句和赋值表达式和逗号相比优先级不同x = 1, 2  # Sets x to (1, 2)(x := 1, 2)  # Sets x to 1# 打包和解包可以在赋值语句直接使用 但是赋值表达式不能直接使用loc = x, y  # Use (loc := (x, y))info = name, phone, *rest  # Use (info := (name, phone, *rest))# 如下语句 无法通过赋表达式实现px, py, pz = positionname, phone, email, *other_info = contact# 赋值语句可以使用的内联类型提示 赋值表达式就不支持# 当然这里可以使用 &quot;p: Optional[int]&quot; 单独声明类型p: Optional[int] = None # 赋值表达式不支持增强型的赋值操作total += tax  # Equivalent: (total := total + tax)\n总结\n使用赋值表达式的时候带上括号准没错\n","plink":"http://blog.lipanpanx.com/post/2020/202006/Python海象算子/"},{"title":"Github仓库如何选择开源许可证","date":"2020-06-15T17:35:57.000Z","date_formatted":{"ll":"2020年6月15日","L":"2020/06/15","MM-DD":"06-15"},"updated":"2022-02-01T01:24:26.640Z","content":"选择开源证书\n\n当我们点了Github个人主页右上角的那个那个加号之后,如上所示可以看到创建新仓库的选项, 点击 `New repository` , 就会进入到创建新仓库的页面,进入到这个页面之后可以看到右下角的下拉框可以为自己的项目选择开源许可证:\n\n截至到2020/06/13日,Github在创建仓库允许选择的开源许可证如下所示:\n\n如上图所示可以Github支持的开源许可证还是很多的  Apache, MIT, BSD, CC0, EPL, AGPL, GPL, LGPL, MPL都支持,\n这样一来大大方便了我们的选择,但是有时候选择多了未必是好事情,面对开源许可证,每个人可能心中都存在过这样的疑问:\n\n\n为什么要使用开源许可证? 我完全不用开源许可证好像也没啥问题啊\n就算我打算用开源许可证,Github上面这么多,完全不知道选择那个呀? 根本不知道他们之间有啥区别?\nGithub上面的开源许可证都不是我想要的,我有了解到一个非常棒的证书,但是Github创建仓库的时候还没得选怎么办?\n\n\n为什么需要开源许可证?\n要弄懂为什么要使用开源许可证,我觉得应该首先弄懂不使用开源许可证会怎样?\n不使用开源许可证对于开发者有何影响?\n\n首先在没有开源许可证的情况下你对你的项目是独占版权的,这样就会造成一个问题就是别人使用你的项目比较困难, 然后就会导致没人愿意去使用你的项目,还有个问题就是 如果多人参与你的项目的开发,因为每个人都成为了这个项目的版权持有者, 你自己在没有得到团队中所有成员授权的情况下,\n对项目的随意使用其实也是违法的,如果你想要很好的维护项目的其他贡献者的版权许可,那你不得不去和你的项目贡献者之间签订一个贡献者协议,\n想想都是一个很头疼的事情.\n\n\n其次还有个问题,就是当你把你的代码发布到Github的公共仓库的时候, 也就意味着你接受了Github公共仓库的一些服务条款,由于这些条款的存在\n很多人可以去查看和复制你的项目仓库, 在一些特殊的情况下,部分人对于你的项目的使用可能不需要你的许可和授权.\n\n不使用开源许可证对于项目的使用者有何影响?\n\n如果你发现了一个软件,而这个软件没有开源许可证,那么也就意味着你没有得到作者的授权,尽管在Github上面你能够查看和复制代码,但是严格意义上你不能出于任何目的去使用,修改,和分享这个软件, 你说蛋疼不蛋疼.\n\n\n此时作为一个项目的使用者你所能做的就是:\n\n和项目的开发者沟通去加上开源许可证\n不去使用这个没有开源许可证的项目,即使你觉得这个项目不错\n和开发者进行私人协商,获取开发者的授权\n\n\n\n总结: 为什么要使用开源许可证, 因为不用的话,会给开发者和使用者带来很多的麻烦事情,\n用开源许可证是为了避免日后在项目的使用过程中一些不必要的麻烦\n\nGithub的开源许可证如何选择,他们之间有何区别?\n这个世界上有太多的开源许可证,甚至Github的开源许可证就有很多,我相信大多数人都没有时间和精力去认证的去了解每一个开源许可证,那怎么办呢?\n所以我这里把最主要的几个开源许可证的地址和允许的权力列了出来,大家首先做个粗判断, 简单判断一下自己可能会用到那个开源许可证,然后再去认真的研究,\n如果真的对开源许可证非常感兴趣, 也可以先全研究几个被广为使用的开源许可证(比如 GPLv3和MIT许可证), 跟着潮流走总不会有啥大问题.\n常见的软件开源许可证(开放程度由高到低)\n\nGNU  AGPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial useDistribution Modification Patent use Private use\nDisclose source License and copyright notice Network use is distribution Same license State changes\nLiability Warranty\n\n\n\n\nGNU  GPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license State changes\nLiability Warranty\n\n\n\n\nGNU  LGPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license State changes\nLiability Warranty\n\n\n\n\nMozilla Public License 2.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license (file)\nLiability Trademark use Warranty\n\n\n\n\nApache License 2.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice State changes\nLiability Trademark use Warranty\n\n\n\n\nMIT License\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice \nLiability Warranty\n\n\n\n\nBoost Software License 1.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice \nLiability Warranty\n\n\n\n\nThe Unlicense\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\n\nLiability Warranty\n\n\n\n常见的非软件开源许可证\n\nCC0-1.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\n\nLiability Patent use Trademark use Warranty\n\n\n\n\nCC-BY-4.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\nLicense and copyright notice  State changes\nLiability Patent use Trademark use Warranty\n\n\n\n\nCC-BY-SA-4.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\nLicense and copyright notice  State changesSame license\nLiability Patent use Trademark use Warranty\n\n\n\n如何看懂上面的图表\nPermissions :就是开源许可证允许做的事情\nCondition: 就是要在特定的情况下才允许做的事情\nLimitations: 就是开源许可证不允许去做的事情\n软件开源许可证如何选择?\n我们需要一张乌克兰老铁(Paul Bagwell)画的图来帮助我们进行理解和选择 :\n\n\n由上图可以看到目前主流的开源证书主要分为两派:\nGPL系列 和 MPL 站一派  (我简称他们A派)\nBSD系列, MIT 和 Apache 站一派  (我简称他们B派)\n两派之间的主要区别就是你在原有的开源软件上做了更改之后是否允许其所使用开源证书发生变化:\nA派的观点就是你更改开源项目之后所使用的开源证书必须和原有开源项目保持一致或者相兼容, 其实就是一个始于开源 忠于开源的思想,让大家一直开源\nB派的观点就是原有的开源项目,如果你更改了部分代码的话那你也可以更改开源证书,这样以来对于开源项目而言,就更加的容易被商业化,\n而GPLv3和MIT 这两个开源证书简直就是A派和B派的两个极端, 也是目前最受欢迎的两个证书,具体怎么选择大家可以看图行事,当然更加详细的协议内容还是建议大家根据我发的协议链接找到协议原文,去仔细阅读协议原文进行了解\n\n非软件开源许可证如何选择?\n数据集 视频  所使用的开源许可证\n\nCC0-1.0, CC-BY-4.0, 和 CC-BY-SA-4.0  这三种开源许可证就经常被用在数据集和视频 等非软件的项目上面,\n有一点需要注意的就是 CC-BY-4.0 和 CC-BY-SA-4.0 这两种许可证是不建议给软件项目用的\nCC-BY-4.0 和 CC-BY-SA-4.0非常的相似,后者比前者有一项要求就是,如果你对开源项目进行了更改,\n那么更改后的版本所使用的开源协议必须和原有协议相同或者想兼容,\n这里和软件开源证书的两派的思想是相同的\n\n文档所使用的开源许可证\n\n一般情况下开源软件中所附带的开源的文档和 开源软件本身持有相同的开源许可证,\n当然你也可以针对开源软件和其对应的开源文档使用两套不同的开源许可证,\n但是你一定要指出文档中的 源代码示例 所使用的许可证是什么类型的\n\n字体使用的开源许可证\n\n针对开源字体常用的许可证就是 SIL Open Font License 1.1 ,\n这个许可证可以允许别人自由的去使用它,同时保留自己的版权\n\n混合工程使用的许可证\n\n如果你的 项目是个非常大的混合工程,包含 软件, 文档, 数据集,视频,字体等内容, 那你就需要为自己的项目准备多个许可证,\n但是你需要做一个说明,用来说明你的工程的各个部分分别使用怎样的许可证 .\n\n如果Github上面的所有许可证都不能满足我的要求怎么办?\n开源许可证本质上就是一个名字为LICENSE或者LICENSE.txt的文本文件\n如果你将要使用的开源许可证不可以在Github上建立仓库的时候进行选择,那么你可以这么做:\n\n\n在选择开源许可证的时候随便选择一个,然后把自动生成的LICENSE中的文件更改为你所需要的内容\n\n\n\n\n直接不选择开源许可证,在自己的项目文件夹中自己去创建 LICENSE/LICENSE.txt文件 然后把自己所使用的开源许可证的协议内容粘贴进去\n\n\n","plink":"http://blog.lipanpanx.com/post/2020/202006/Github开源证书选择/"},{"title":"学习PythonPEP的书写和提交流程","date":"2020-06-07T17:45:40.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"updated":"2022-02-01T01:24:26.640Z","content":"\n如果你为Python写了一篇PEP,这篇PEP成功的被Python指导委员会接受了,\n那么以后你在吹牛皮的时候你就可以说我主导了Python语言某个特性的设计工作.\n\n我就问你主导Python语言特性设计牛不牛皮,今天我就写一篇文章告诉大家如何去为Python设计一篇PEP,并且整个PEP从一个想法到Python语言去实现它的这一套流程:\n\n假设你已经是一个Python高手了,在使用Python给过程中你觉得Python语言在某方面还不够完善,你有一个不错的想法可以去改善Python这方面的不足,你打算把你的想法加入到Python语言里面,所以你打算写一篇PEP,为Python的发展献言建策,那首先需要做什么呢?\n\n\n首先你要确保你的想法是个新的想法是个比较大的想法,是一个由必要去建立一个PEP的想法,也许你发现了Python的一些小问题,但是这些小问题如果提交一个小补丁就可以解决了,那就没必要提PEP\n当你确定自己的想法很牛B之后,你也不是马上就要提PEP,你首先要做的事情是引发社区的讨论,看看其他人怎么看,然后自己去实现一下这个想法看是否是可行的,并且发帖到 python-list@python.org mailing list或者到 python-ideas@python.org mailing list 进行进一步的确定,看看大家对你的想法是否认同,如果你能让大多数人都认同,那你就有戏,在你发帖之前最好准备一份高质量的PEP草稿,这样的话才会更容易的被接受\n总之就是先讨论,得到大家的认可,避免后期不必要的撕逼,然受自己也要做好准备,最好有个简单的实现,然后还有个高质量的PEP草稿\n\n写PEP你不得不知道的几个Python社区角色\n\nPEP champion :  PEP拥护者 也就是PEP的发起人,也就是跟大家说我有个非常XXX的想法的人\n\n\nPEP author:  PEP作者 就是写PEP的人,PEP从一个想法到一篇PEP草稿,再到一篇拥有官方PEP编号的PEP文档,到后面PEP审核通过,PEP复审出现改动,PEP被接受这个过程中维护PEP文档的人就是PEP的作者,大部分PEP作者就是PEP拥护者本人\n\n\nPEP reviewer: 这个角色不是单指某一个人,一个PEP从想法到实现需要经过很多此review, 每一次参与review的人都可以被称作 PEP reviewer\n\n\nPEP editor: PEP编辑者 就是对PEP进行初步审核的人,审核通过的PEP进入到github上面的PEP仓库的master分支,进行下一轮的评审\n\n\nPython Core Developers: Python核心开发人员 就是开发Cpython解释器的那群人,都是大佬,都是大佬\n\n\nPython’s Steering Council: Python指导委员会 大佬中的大佬,从Python核心开发人员中选择出来的指导Python语言开发工作的一群人,对于PEP是否接受有着最终发言权\n\nPEP的工作流程是这样的:\n\nPEP champion 先有一个高质量的idear(经过讨论分析和理性验证)\n你去github上面去fork PEP仓库\n在仓库中创建一个 pep-9999.rst的文件去把你的PEP草稿粘贴进去\n确定你的PEP的类型,PEP的状态设为草稿,PEP头部按照模板写一波\n把你的pep-9999.rst push到PEP仓库\n然后PEP editors 会去审核你的提交\n如果审核通过,这个本来是草稿的PEP会拿到一个正规的PEP编号,如果没有审核通过那PEP editors 会打回去让 PEP author 去修改\n如果PEP审核通过拿到了PEP编号 PEP editor 会把这个新提交的PEP合并到PEP仓库的 master 分支\n如果你的PEP的类型是Standards Track类,那你提交的PEP还会被发送给Python-dev list 成员进行再次review, 确保你的新PEP没有坑\n有些听起很不错的PEP在实现的时候其实是非常蛋疼的,没做的时候想的挺好,真正去实现的时候才知道是否靠谱,最好的情况时你在提交PEP的时候你手里就已经有一个这个PEP的原型实现了,所以如果你的PEP类型是Standards Track类型那你就不仅需要准备设计文档,你还需要准备一个参考实现,以此来避免一些不切实际的想法\n\n当然凡事都有例外,有些Python的核心开发者是不会走这个流程的因为他们本身的权限比较大,他们有直接push内容到PEP仓库的权限,所以有时候他们会直接给自己的PEP分配一个PEP编号push进入PEP仓库的master分支,当然这并不意味着这个PEP就被接受了,他只是绕过了PEP editor的审批而已,PEP被接受和PEP通过审批是完全两码事儿,只有通过Python指导委员会的同意,PEP计划实现,才能叫做PEP被接受.\n如果我写的PEP无法审核通过被拒怎么办?\nPEP被拒绝是很正常的事情,不要灰心,只要能够坚信自己的PEP是真正对Python有用的东西,真正好的idear,修改一下继续上就行了,但是被拒肯定是有原因的,最主要的原因就是下面几条:\n\n该特性已经存在了\n技术上不合理\nPython不需要去实现这样的特性,也就是说伪需求\n无法进行后向兼容\n不符合Python的设计哲学(Python设计哲学可以在Python交互解释器中输入import this获取)其实在PEP的审批阶段可以拿着自己的PEP idear去咨询Python指导委员会,因为PEP最终会不会被接受其实是由Python指导委员会所决定的,所以如果真的想要自己的PEP被接受,做好提前的沟通还是非常有必要的\n奥对了还有一个蛋疼的要求,就是你的PEP草稿必须带着至少一名Python核心开发人员一起写,或者有一个Python核心开发人员指导你写,或者有一个经过Python指导委员会批准的非Python核心开发人员一起写,反正就是需要有一个能够被Python指导委员会所信任的人参与了你的PEP设计,如果没能满足这个条件 PEP editor有权直接驳回你的PEP草稿\n\nPEP的复审和决定机制\n一篇PEP是否最终被接受并且决定去实现是需要经过层层复审的,反正要经过很麻烦了一个流程,下面有个Python官方画的简单流程图:\n\n但是实际情况比较复杂,有时候不会按照这个流程图来,但是这个流程图给人们提供了一个比较清晰的PEP工作流的概览\nPEP格式和模板\n这年头写啥文档没个模板真不行,PEP也是文档,所以模板搞起来:\n\n首先PEP是UTF-8编码的rst文件,首先你需要去指导rst文件的格式,如果rst的语法格式你已经会了,那你就可以阅读官方的PEP 12--Sample reStructuredText PEP Template,没错PEP12是介绍rst格式PEP模板的PEP(有点绕),为什么要用rst格式?官方给出的解释是 容易转成html进行在线发布和阅读\n每一篇PEP必须有一个标准的PEP头部,如下所示,带* 号是可写可不写的,不带* 号的是必须要写的,记住写PEP头的时候,头的各个字段的顺序,必须按照下图的内容去写,先后顺序不能乱\n\n\n写道这里就讲的差不多了,但是其实PEP的书写还有很多的内容比如:\n\n\n如何判断PEP是不是一个成功的PEP\nPEP提交之后发现内容有bug怎么解决\nPEP所有权以及所有权转移问题\nPEP editor的详细职责和工作流\n等等问题,我就不写了,写不动了…\n\n\n想写PEP的可以先根据上面流程走一波,\n然后等到遇到问题的时候再去查资料吧.\n","plink":"http://blog.lipanpanx.com/post/2020/202007/学习PythonPEP的书写和提交流程/"},{"title":"关于我","date":"2021-10-27T07:36:22.000Z","date_formatted":{"ll":"2021年10月27日","L":"2021/10/27","MM-DD":"10-27"},"updated":"2022-02-01T01:24:26.644Z","content":"屌丝程序员一枚\n","plink":"http://blog.lipanpanx.com/about/"}]