[{"title":"Hexo+Inside+Github+(NetlifyCMS+Vercel+Cloudflare)构建全球可高速访问的静态站点","date":"2021-11-16T07:27:20.000Z","date_formatted":{"ll":"2021年11月16日","L":"2021/11/16","MM-DD":"11-16"},"updated":"2021-12-11T01:00:08.681Z","content":"0x10 前情提要\n我的博客一直以来都是静态的站点,静态的站点优点还是很多的,很多地方提供免费的托管服务,访问速度快,搜索引擎友好,等等. 但是有优点就有缺点,静态站点的缺点也很明显,无法承载过于复杂的功能,就个人博客而言,如果做成动态网站有管理后台的那种的话就可以随时随地写文章更新文章了,想对文章进行更改校对,任何一个有网的地方登陆后台就可以操作其实还是很爽的,所以我决定给我的静态站点添加一个后台管理系统就是netlifyCMS,这个netlifyCMS是netlify公司的产品, 这个东西可以让你方便的在线 管理 书写 发布你的文章,我尝试了一下效果还是不错的.\n\n0x20 在netlify中部署使用netlifyCMS\n0x21 静态站点部署到netlify\n因为 netlifyCMS是netlify公司的展品, 刚开始我不知道我还以为要想使用netlifyCMS就必须把站点放到netlify上面去才行,于是就开始折腾netlify,其实把站点放到netlify上还是比较简单的,我这里简单的讲一下:\n\n首先注册netlify账号 因为它可以使用第三方账号进行注册,我的项目都在githu上我就选择了直接用github账号进行注册\n然后就是选择git仓库创建网站,这里也很简单 按照它的提示一步步来就醒了 总共三步\n\n最后一步这里 你可以选择git仓库的分支, 可以设置安装依赖和运行构建命令的目录, 以及最后保存静态文件部署静态站点的文件夹,当然 这里也可以 设置环境变量 设置serverless 函数的文件夹 不过我们用不着 这两个也就不用管它了.\n\n\n这里有个非常蛋疼的点 就是这里可以选择一个目录 作为你安装依赖和运行构建命令的目录,但是如果我的项目当中 包含了一个子项目 需要多处安装依赖,然后需要多处运行构建命令呢? 我不知道针对套娃项目 如何在netlify中部署 至少我暂时没有看到设置的地方. 这一点我觉得vercel就做到很好,在vercel当中你可以自己去设置安装依赖和构建项目的命令,这样的话对于需要多处安装依赖的项目你直接可以把命令写在packge.json的scripts当中 然后提交给vercel一个运行script的命令就行了 比如你的script设置成为&quot;vercel_install&quot;: &quot;npm install &amp;&amp; cd themes/inside &amp;&amp; npm install&quot;,然后把 npm run vercel_install 提交给vercel就行了.\n\n\n最后选择 deploy site,就能把你的网站部署到netlify上面了,是不是很简单\n\n0x22 netlify当中使用netlifyCMS\n1, 首先进入到你的站点 然后点击 site setting进入到你的网站的设置页面,就可以看到一条长长的网站设置菜单\n\n\n2, 我们看到网站的设置页面有很多的选项可以设置,我们首先打开身份验证服务,选择identity然后点击enable identity即可\n\n开通身份验证服务之后 identity菜单会增加很多的可配置项, 在registration当中我们可以配置为仅仅我们邀请的注册用户才能访问netlifyCMS,在Services当中我们可以配置打开Git Gateway服务,这样一来netlifyCMS就有权读写我们的仓库了.\n\n3, 既然后端的验证服务有了我们就需要前端的身份验证页面,前端的验证页面也很简单\n对于hexo框架而言 首先在项目根目录的 /source文件夹下面创建admin文件夹 然后里面放上两个文件index.html 和 config.yml,其中index.html是前端验证页面的入口,config.yml是 netlifyCMS的配置文件,netlifyCMS可以根据这个配置文件来确定以怎样的方式去读取和操作你的文章\n我们直接在index.html 中添加下面的代码\n12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Content Manager&lt;/title&gt;    &lt;script src=&quot;https://identity.netlify.com/v1/netlify-identity-widget.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- Include the script that builds the page and powers Netlify CMS --&gt;    &lt;script src=&quot;https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n这段代码就是加载两个js文件,一个用来渲染CMS的页面一个用来进行身份验证\n因为我们最终需要 通过 lipanpanx.com/admin/ 去访问到CMS, 所以admin文件夹最终会被放到hexo所生成的网站的根目录当中,为了避免hexo对admin文件夹进行过多的操作,我们在hexo的配置文件的 skip_render字段当中添加- admin/**,确保hexo不对admin文件夹当中的内容进行渲染.\n4, 当我们完成前端验证页面入口的添加之后, 把站点部署到 netlify上面然后我们访问自己的站点后面加上/admin/也就是 xxx.com/admin/,就能通过netlify账户进行登陆了,但是这个netlify用户必须是自己邀请的用户(刚才在identity-&gt;registration哪里设置了仅邀请的用户才可以登陆),邀请用户其实也是非常简单的,只需要找到网站实例设置下的 identity页面 点击invite users按钮输入邮箱地址就行了.\n\n5, 登陆账户之后就能看到后台管理的页面了,但是目前的后台管理系统空空如也,需要合理的设置/source/admin/config.yml文件,才能够让自己的后台管理系统正常的工作:\n我在 netlifyCMS的官方文档当中找到了 官方的demo 和 官方demo的配置文件,这两个东西对于想要自己写配置文件的同学是非常重要的参考. 想要进一步学习如何配置netlifyCMS的同学可以看看下面的内容:\n关于 netlifyCMS的配置文件/source/admin/config.yml中各个配置项应该如何配置, 官方文档中的 configuring your site 章节进行了详细的讲解,这一章节又分为两个小节,其中 configuration options小节中包含了所有我们常用的配置, beta features小节的大部分功能一般用不到,但是也有一小部分是非常有用的. 我这里主要讲解一下 configuring your site小节当中的内容:\nconfig.yml 文件当中有12个根配置项,这12个根配置项目当中又有3个配置项是必须要有的,分别是: backend media_folder collections, config.yml文件当中至少要包含这三个配置,其他的配置项是可有可无的,这里我先给出一个配置的example,然后再结合代码注释讲解一下这几个配置的作用:\n12345678910111213141516171819202122232425backend: # 这个backend实际上就是个中间商它允许你的netlifyCMS和提供内容存储服务的第三方进行通信 这里按照netlifyCMS的文档要求设置即可 如果使用自定义的backend 按照backend要求配置即可  name: git-gateway # netlifyCMS的一个开源项目 允许你在netlifyCMS当中操作git仓库, 默认使用 netlify identity服务进行合法用户的认证  branch: master # 指定被操作的git仓库的分支 # local_backend: true  #解除这个注释运行npx netlify-cms-proxy-server 然后再运行hexo s 就能本地调试netlifyCMS media_folder: &#x27;source/images&#x27;  # netlifyCMS提供了上传文件的功能,可以把本地的文件上传到网站的根目录当中这个选项可以控制上传文件的路径# public_folder: &#x27;/images&#x27;  # 这里控制 网页中引用上传资源时候的路径# publish_mode: editorial_workflow  # 这里控制是否使用netlifyCMS 提供的工作流collections:  # collections下面可以有多个collection 每个collection都必须有一个name 且这个name不能够重复  - name: &quot;posts&quot;  # 必须存在的字段,名字任意 不能重复,这个name并不会显示在netlifyCMS的UI当中    label: &quot;2021&quot;  # 在 netlifyCMS当中collection 显示的名字     folder: &quot;source/_posts/2021&quot; # 你的文章所存储的路径     sortable_fields: [&#x27;date&#x27;]  # 控制那些字段用来给文章排序    create: true  # 是否允许在netlifyCMS中创建新的文章    editor:      preview: true # 在netlifyCMS中写文章和时候是否允许打开预览窗口     fields: # 每篇文章头部的 front-matter 都可以设置与其相对应的widget,在netlifyCMS就可以使用widget设置文章头部的front-matter      - &#123;label: &quot;Title&quot;, name: &quot;title&quot;, widget: &quot;string&quot;&#125;      - &#123;label: &quot;Publish Date&quot;, name: &quot;date&quot;, widget: &quot;datetime&quot;, format: &quot;YYYY-MM-DD HH:mm:ss&quot;, dateFormat: &quot;YYYY-MM-DD&quot;, timeFormat: &quot;HH:mm:ss&quot;, required: false&#125;      - &#123;label: &quot;Updeted Date&quot;, name: &quot;updated&quot;, widget: &quot;datetime&quot;, format: &quot;YYYY-MM-DD HH:mm:ss&quot;, required: false&#125;      - &#123;label: &quot;Tags&quot;, name: &quot;tags&quot;, widget: &quot;list&quot;, required: false&#125;      - &#123;label: &quot;Categories&quot;, name: &quot;categories&quot;, widget: &quot;list&quot;, required: false&#125;      - &#123;label: &quot;Body&quot;, name: &quot;body&quot;, widget: &quot;markdown&quot;, required: false&#125;\n其实 collections 又分为 folder collections 和 file collections 这两者的区别在官方文档的collections types进行了详细的说明,我这里就不在赘述, 因为我需要在一个collection中管理多篇格式相同的文章所以我使用folder collections,关于collection下面的各种widget的应该如何配置 查看官方文档可以得到更加详细的信息.\n这些内容全部做完之后,只要我们更新代码然后提交到github,就能触发netlify去构建我们的项目生成网站的静态文件并进行部署,我们通过netlify提供的临时域名就能够访问我们的站点了, 然后我们通过在域名后面添加 /admin/ 就能够访问netlifyCMS了,在netlifyCMS当中可以随意的添加删除文章.会自动同步到github仓库,如果此时我们还想要在本地写文章的话,在本地写之前可以先和remote仓库进行同步,把remote仓库中的内容拉下来之后可以继续写不会和netlifyCMS有所冲突. 这样看起来一切都挺好的,这篇文章已经可以结束了, 但是经过我的试用我发现把博客放在 netlify的速度奇慢无比, 甚至不如我之前放在 github pages 用cloudflare cdn 加速来的快, 加载一个网页需要 3-4秒钟, 这谁受得了啊, 于是我就开始在网上进行了一番搜索, 终于我找到了一篇神奇的文章, 文章的作者也是苦于netlify的速度非常的慢最后通过把博客部署在vercel上面加快了博客的访问速度,还给出了访问速度的对比结果:点击此处查看. 但是我是需要使用netlifyCMS的呀, 如果单纯的把博客部署在vercel上面对我来说并没有任何的意义, 所以我搜了一下结果发现 netlifyCMS还真的能够在 vercel上面使用,真的是太棒了 这样依赖既能够使用netlifyCMS又能增加博客的访问速度 何乐而不为呢.\n0x30 在Vercel上面部署和使用netlifyCMS\n0x31 netlifyCMS是如何运作的?\n要想在vercel上面使用netlifyCMS,就要搞清楚这东西是如何运作的,之前我们也提到了在我们访问xxx.com/admin/的时候 /source/admin/index.html会被加载,这个hmtl文件中的内容 就是引入两个JS文件,一个负责页面的渲染,一个负责用户认证, 所以netlifyCMS的最核心的功能其实就是这两个, 页面渲染靠前端的JS能够完成,而用户认证一般情况下需要靠后端配合来完成,那么netlifyCMS是如何在无后端的情况下实现的呢? 其实netlifyCMS之所以能够完成用户认证其实是使用了第三方的认证服务,一般情况下我们可以使用serverless函数和第三方的认证服务进行对接,对于serverless函数的指定是在 /source/admin/config.yml文件当中backend字段进行配置的,其实netlifyCMS的文档中也说的非常清楚了:A backend is JavaScript code that allows Netlify CMS to communicate with a service that stores content - typically a Git host,当我们在netlify中使用netlifyCMS的时候, 经过合适的配置之后netlify中的serverless函数会在用户请求登陆的时候加载然后和netlify的用户认证服务进行通信判断用户的合法性, 所以在vercel中使用netlifyCMS我们也可以使用serverless函数去 和第三方的认证服务去通信(比如github的oauth)进行用户合法性的认证. 那么接下来的问题就是 如何实现这些serverless函数并且在vercel当中进行调用呢,这其实是一个头疼的问题,不过好在我们有万能的github.\n其实netlifyCMS是一个开源的东西: github仓库地址,对于如何实现自己的的backend,虽然在netlifyCMS的官方文档中没有进行说明,不过在这个开源仓库当中的package文件夹当中 还是给出了大量可供参考的代码的,不过只读代码还是有点苦涩的.还好在国外有大佬已经实现了可以在vercel上部署的使用GitHub oauth 认证服务的demo了: 仓库地址, 简直太令人感动了.\n0x32 在Vercel中部署使用netlifyCMS\n把国外大佬的仓库clone到本地,对于还没有创建hexo项目的用户可以直接在这里仓库里面创建hexo项目,直接用就完了\n对于已经创建hexo项目的用户只需要 把demo当中的 /api 和 /lib 两个文件夹和 vercel.json 拷贝到字节的hexo项目的根目录,然后找到package.json文件当中的3个依赖合并到自己hexo项目的package.json文件当中去就行了.\n完成上面的操作之后 再去配置 /source/admin/config.yml文件当中的backend字段:\n123456backend:  name: github  repo: lipanpan-hub/xsite      # github仓库地址  branch: master                # 选择仓库分支  base_url: https://xsite-sage.vercel.app/  # 这个可以先留空等到vercel部署完成之后得到链接 再填写# config.yml 文件的其他配置 照旧填写 \n然后把你的项目部署到vercel上面 得到临时域名 把这个域名填写到backend-&gt;base_url处\n然后 打开 github的 develop setting 点击 oauth apps 再点击 new oauth app 进入下面的页面:\n\n这张表单有三个必填项: 第一个application name 随便填写, 第二个hompage URL填写为刚到得到的 vercel临时域名,第三个authorization callback URL填写为刚才的临时域名后面再添加/callback:vercel临时域名/callback 然后点击register application成功注册程序之后,拿到clinet ID 和 client secret, 其中client secret 需要你点击 generate a new clinet secret 按钮去生成.\n拿到 client ID 和 client secret 之后 进入vercel 你的网站项目 然后再项目主页点击 settings-&gt;enviroment variables 添加两个环境变量 分别是:OAUTH_GITHUB_CLIENT_ID 和 OAUTH_GITHUB_CLIENT_SECRET, 这两个环境变量的值就是刚才得到的client ID 和 client secret.\n然后在vercel上重新部署你的网站项目就可以了.重新部署完成之后打开vercel提供的临时域名你就可以访问自己的站点了,同时在这个域名后面加入/admin/ 你就能访问文章管理后台页面了 这个页面使用github进行登陆认证.\n然而有些同学会在这里遇到一个奇怪的问题,就是访问/admin/页面的时候会得到一个错误的提示:\n1234Error loading the CMS configurationConfig Errors:Error: Failed to load config.yml (404)Check your config.yml file.\n下面我说一下我的解决方法:\nU2FsdGVkX19OgcM/tF0iGM9KsJf4Obhomn3Yned0li6D/+JSmCqeKpQnIvlgkV6Y5quuttwCrMkTFUDSn3PVQ3UMDKn2hC74Y4CUyz2OrReGmebMXLBHJatAd6vP0W2pfqYrnNJ1Yy9YUYniCTMZZWMStDCOjo45A2nDLQohq2mOiqglUk+4RTDgPo+59kqhZ4WNYy7j7+cxprUZI+E+Cg+T55JEs4wbZsEQHfWB4A56WyhfLNY6kCM3aLYETWxfBzrlbAyH1+rdYaxs3+pcdMjzcIH0KUYbTsraiUyX8oNuPPstKU7zINd5V0O6rL/3OJJ7STtmPOWwviQ0dv71btoNckmoknnhtL/Ts3u0ATaERlWiDrflKVjQjWf3c6VveeP451sXWE+mN2GMQjlQbQW3eqHJJR68Kg9XqbTZDtqHyBpx9mnaM7Be6ENJ0g3assPqi0o1qxz2SJG3mRUnyo99ibLx5ECtZiPbKJvSv34LyIYEYh4GYlQ8fK2V5+lIWEyaUIWX2f+Vr5vG5ycr+zqtTzoSoNbnqyLvoEc+weXC6OdMkV+CVqrilfmBGLI/L9NuTg68CJp6zy05n47nrQVW84jrHHJl3Hjp9YFJPV3jwzqYLUj3IqGIomePBsBloI7ysR/La5wEUtzfEHqFM+LGVzITgmetBHQw4dDAQxX+86ssNeECB99w8FcoCEgf750xupc5XLpRb3CZbQHzMfgrBCU27579QnUN55lyZeb1HT+HOYtaLofJ8XcmmV5zNCVUZjKC7hiJL69xe5WPs2TgH9lQkvSfsYdhGVZuMcLohZZZ6WRIrIYmdolJwavwZBdlB2wzz96FfoPMwj3585dbktXw7/MKcdUcyNmbq6Q6Z7eq/JO/cvBKL7Pz0fb025fR6sE4aVs94LCwpzj1oLq0CDQMySZVd1LB+FIjXpz737ayYVjf8VL+YhipoNizcrNgtCxfXrUYgqmE7voqDW9A1iiORwieXXLU16WCVXeDsAieNkUZudLpBxLE14s7t/l+E0QyeSNTQytlK+cvDCUP7sOMbcdxvEFADcf1itFYRT9WBzZI2IAUwQYlJNUR8oDZTiMaRJo1oha6W4dcxbLZ0baLn4tw6kmXqMG0FmKW+tc5ZDE2jE6yW1GqJKMHc8aO98G99UPTQnIhga1ewtmlk/E43eYeB6m4+Ri3IMH8Mp61Ifme6W9xtKluvl0lF1lJt3wLI+w9qkvCWaFn2Hu8BbMJsBkG2LlKndURiFYk+n7diXwPwZCC95ZlMxnJdcbRy4oT8IdlaEAxC7FSAdzBINd5fqZ2lQTntsHWFgoubpO3urBRbJwX9EHlOiyKTVUeCrPZTuJMRiIImUEnPDwAQiU9UafuqkAAa7cRW4E=自定义域名\n当我们的 在vercel上成功的部署项目之后,访问速度确实加快了,而且新添加的netlifyCMS也确实挺好用,但是访问的时候使用的是vercel的临时域名,这个域名非常的长太难记忆了而且都是乱码组成的根本拿不出手啊, 所以绑定一个专业的域名还是非常有必要的, 对于刚申请的域名直接把nameserver设置为vercel的nameserver然后绑定就能用了,但是我并不想要这么干,我只想把自己的域名放在cloudflare上面进行管理,然后配合vercel使用,原因有下面几个:\n\n首先我所有的域名都是放在cloudflare上面进行管理的 我不想要搞的东一个西一个很乱\n然后更改nameserver需要时间 我不想等\n之前vercel出现过在大陆访问不了的情况,对于这种情况如果以后再出现,就可以通过cloudflare代理访问,站点仍然可以正常部署在vercel\ncloudflare 提供的各种网站安全 网站加速的功能 想用随时可以用\n\n打开 vercel docs 在顶部导航栏的 support 中我们可以找到一篇文章How do I use a Cloudflare domain with Vercel? 这篇文章详细的介绍了如何将 cloudfalre和 vercel配合使用进行自定义域名.\n由于目前国内访问vercel的速度还是比较快的,所以我这里就讲一下不使用cloudflare代理的情况下如何为vercel项目绑定自定义域名:\n\n在上图当中我在project settings 当中为项目绑定了两个地址 lipanpanx.com 和 blog.lipanpanx.com 要想要这两个地址生效,只需要在 cloudflare的dns设置当中 添加2条cname记录指向cname.vercel-dns.com,并且proxy status 设置为 dns only 如下图所示:\n\n操作完cloudflare之后 回到vercel项目的project setting-&gt;domains 点击 add按钮 添加 lipanpanx.com 和 blog.lipanpanx.com就行了.\n","thumbnail":"https://search.pstatic.net/common/?src=https://i.imgur.com/USr2l3A.jpg","plink":"http://blog.lipanpanx.com/post/2021/202111/为博客添加内容管理系统/"},{"title":"netlify-cli安装E404错误(找不到依赖项)解决","date":"2021-11-09T10:46:46.000Z","date_formatted":{"ll":"2021年11月9日","L":"2021/11/09","MM-DD":"11-09"},"updated":"2021-12-11T01:00:08.681Z","content":"今天打算安装 netlify-cli\n于是打开 terminal 运行了一下\n1npm install netlify-cli -g \n结果 上来就是一顿错误\n1234567891011npm ERR! code E404npm ERR! 404 Not Found - GET https://oss.npmmirror.com/netlify/-/netlify-8.0.4.tgznpm ERR! 404npm ERR! 404  &#x27;netlify@https://registry.npm.taobao.org/netlify/-/netlify-8.0.4.tgz&#x27; is not in this registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     C:\\Users\\lipanpan\\AppData\\Local\\npm-cache\\_logs\\2021-11-09T02_43_45_128Z-debug.log\n报错信息显示 无法在registry 当中找到 netlify-8.0.4.tgz\n12345678lipanpan&gt; npm view netlify versions[ ...省略若干  &#x27;6.1.10&#x27;,       &#x27;6.1.11&#x27;,       &#x27;6.1.13&#x27;,       &#x27;6.1.14&#x27;,       &#x27;6.1.15&#x27;,  &#x27;6.1.16&#x27;,       &#x27;6.1.17&#x27;,       &#x27;6.1.18&#x27;,       &#x27;6.1.19&#x27;,       &#x27;6.1.20&#x27;,  &#x27;6.1.21&#x27;,       &#x27;6.1.22&#x27;,       &#x27;6.1.23&#x27;,       &#x27;6.1.24&#x27;,       &#x27;6.1.25&#x27;,  &#x27;6.1.26&#x27;,       &#x27;6.1.27&#x27;,       &#x27;6.1.28&#x27;,       &#x27;6.1.29&#x27;,       &#x27;7.0.0&#x27;,  &#x27;7.0.1&#x27;,        &#x27;8.0.0&#x27;,        &#x27;8.0.1&#x27;,        &#x27;8.0.2&#x27;,        &#x27;8.0.3&#x27;]\n我看了下确实没这个版本 最高版本就是8.0.3 但是这个包的最新版本(8.0.4)6天前已经在npm上面发布了\n\n因为我使用的是 淘宝的 npm镜像来加速安装\n12lipanpan&gt; npm config get registryhttps://registry.npm.taobao.org/\n所以导致安装失败的原因看起来 好像是淘宝npm镜像没有同步更新\n我打开了淘宝镜像的网站(https://npmmirror.com/) 然后发现 register 地址不知何时从 https://registry.npm.taobao.org/ 变成了 https://registry.npmmirror.com/ 然后我通过域名解析查询 发现这两个域名指向相同的A地址.所以应该仅仅是变了一下域名.\n淘宝npm镜像的说明是 如果第一次安装失败 它会在后台自动同步 在后续安装的时候确保成功\n我连续尝试了好几次都是安装失败  看来这个说明并不靠谱\n然后 还有个 手动同步npm包的操作 就是手动执行  $ cnpm sync xxxx 但是我没安装cnpm, 着实让我感觉到蛋疼\n最后我选择换回 官方的 registery地址\n123lipanpan&gt; npm config set registry https://registry.npmjs.orglipanpan&gt; npm config get registryhttps://registry.npmjs.org/\n通过官方的reigstry 是可以看到最新版本的 netlify(8.0.4)包的\n1234567lipanpan&gt; npm view netlify versions[ ...省略若干  &#x27;6.1.21&#x27;,       &#x27;6.1.22&#x27;,       &#x27;6.1.23&#x27;,       &#x27;6.1.24&#x27;,       &#x27;6.1.25&#x27;,  &#x27;6.1.26&#x27;,       &#x27;6.1.27&#x27;,       &#x27;6.1.28&#x27;,       &#x27;6.1.29&#x27;,       &#x27;7.0.0&#x27;,  &#x27;7.0.1&#x27;,        &#x27;8.0.0&#x27;,        &#x27;8.0.1&#x27;,        &#x27;8.0.2&#x27;,        &#x27;8.0.3&#x27;,  &#x27;8.0.4&#x27;]\n然后安装 netlify-cli 一次性成功\n12345lipanpan&gt; npm install netlify-cli -g ...lipanpan&gt; netlify versionnetlify-cli/6.14.18 win32-x64 node-v16.13.0lipanpan&gt;\n","plink":"http://blog.lipanpanx.com/post/2021/202111/netlify-cli安装教程/"},{"title":"关闭vscode烦人的Github登陆弹窗","date":"2021-11-07T08:34:08.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"updated":"2021-12-11T01:00:08.681Z","content":"\n这两天不知道怎么了每次我打开vscode就会有烦人的github登陆弹窗弹出来,即使不登陆也不影响向github的remote仓库提交代码,但是这个弹窗真的让人好心烦\n\n\n\n弹窗就是上面这个样子\n查了不少资料 最终我在stack overflow 上找到了一个比较有说服力的说法:\n\n首先当在你的电脑上安装git的时候 也会顺带的安装上git凭据管理器, 而且git允许有多个git凭据管理器,\n\n\n然后就是git还允许多级配置分别为 local配置 global配置 system配置  这三个配置都会生效 最后形成一个 effective配置\n因为三个配置都会生效  git 调用凭据管理器的时候 是按照顺序去寻找的 最先去 system配置当中寻找相应的凭据管理器.\n如果你的 system配置当中凭据管理器的相关设置是credential.helper=manager 他就会去调用这个manager, 但是这个manager当中很可能就没有我们需要的凭据 这个时候git就会去下一级配置中去寻找其他的凭据管理器, 最后在下级的配置文件中 使用的是store管理器,最后认证通过 正常提交代码, 但是manager的调用请求已经发出了 所以manager是肯定会被弹出的\n\n\n听起来 上面的说法头头是道, 我也确实在system配置当中找到了 credential.helper=manager 但是我没在local的配置当中找到credential.helper=store 但是我还是选择了相信,按照作者的说法 折腾了半天 就是不行 好坑爹 心好累\n\n最后我无意间 看到github cli的文档中有一篇 缓存凭据的文章 Caching your GitHub credentials in Git\n我就照着这篇文章搞了一下 虽然到最后还是失败了 但是github cli给了我一个重要的提示\n就是我的personal token权限太低 因为我只给了personal token访问repo的权限\n\n要进行在git当中缓存github的凭据我就需要再生成一个至少包括三个权限的凭据\n\nrepo\nread:org\nworkflow\n\n最后我在github上面生成了一个新的包含这三个权限的personal token,然后在命令行中运行 gh auth login 按照cli的提示一步步操作, 就能够顺利的将github的凭据缓存到了git\n\n然后我再打开 vscode 就不会出现烦人的弹窗了\n真妙呀\n","plink":"http://blog.lipanpanx.com/post/2021/202111/关闭vscode烦人的Github登陆弹窗/"},{"title":"checkboxland尝鲜","date":"2021-10-30T09:59:16.000Z","date_formatted":{"ll":"2021年10月30日","L":"2021/10/30","MM-DD":"10-30"},"updated":"2021-12-11T01:00:08.681Z","content":"checkboxland显示汉字的方法\n\n0x10 checkboxland\n前两天 在 github trending 上看到一个开源项目\ncheckboxland 这个项目是用 checkbox 去组成像素点可以在网页上表达图像的这么个工具 github地址:\nhttps://github.com/bryanbraun/checkboxland\n我感觉这个小东西 真的挺有意思\n用checkbox 不仅仅可以放图片 放动画 玩贪吃蛇\n甚至可以在网页上面用checkbox播放电影(就很离谱)\n所以我就抽空玩了一下 本来 想想用这个写一句话放在站点上 做滚动广告牌 类似于这样:\n\n但是一个很明显的事情 就是这个项目是一个比较新的项目,支持中文是不可能支持中文的, 但是我实在是手痒, 最后想想决定自己去做几个汉字的小字库\n由于我想要显示的内容是 李攀攀全宇宙最帅 所以我打算先做我的名字\n0x20 汉字取模\n做这种点阵的汉字字模 我还是有点经验的的\n首先 我找到了一个在线的取模工具 我是取模工具\n这个工具可以说是非常棒了, 把你需要取模的 汉字输进去 他会返回一串 16进制的数字串.\n比如我的姓氏 李, 我选择的字体是16x16的宋体, 我按照 从左到右从上到下 横向8点左高位的方式取模\n最后得到的字符串是:\n120x01,0x00,0x01,0x08,0x7F,0xFC,0x01,0x00,0x05,0x40,0x09,0x30,0x31,0x0E,0xC1,0x04,0x0F,0xE0,0x00,0x40,0x01,0x88,0x7F,0xFC,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00\n然后再通过js 把这些16进制的数字串中的每一个数字转换成为 8位的二进制字符就行了\n123456789101112131415161718192021function binary(num, Bits) &#123;  var resArry = [];  var xresArry = [];  i = 0;  for (; num &gt; 0;) &#123;    resArry.push(num % 2);    num = parseInt(num / 2);    i++;  &#125;  for (j = i - 1; j &gt;= 0; j--)    xresArry.push(resArry[j]);  if (Bits &lt; xresArry.length) &#123;    console.log(&quot;位数小于二进制位数&quot;)  &#125;  if (Bits) &#123;    for (var r = xresArry.length; r &lt; Bits; r++) &#123;      xresArry.unshift(0);    &#125;  &#125;  return xresArry.join().replace(/,/g, &#x27;&#x27;);&#125;\n每2个8位为一组拼接成为 16x16 的二进制矩阵, 然后就能在 checkboxland 里面进行显示了\n比如 李 和 攀 的矩阵就是:\n12345678910111213141516171819202122232425262728293031323334[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0],[1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],[1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0],[0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],[0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0],[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0],[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n0x30 checkbox显示汉字\n最后我决定先把我的名字搞上去 直接把这个二进制的矩阵传给 checkboxland的实例就能显示出来了\n显示效果是这样的:\n\n不过还有个蛋疼的问题 就是 作者说checkbox的数量最好不要超过1500个 不然就会遇到性能问题\n这…\n我显示这三个汉字 就用掉了八百多个checkbox\n这玩意的最终的使用场景可能也就是显示字了, 汉字这个东西实在比较耗费盒子😂\n但是我感觉 网友还是能玩出花来的 这东西有意思\n","thumbnail":"https://search.pstatic.net/common/?src=https://i.imgur.com/paR4JdB.png","plink":"http://blog.lipanpanx.com/post/2021/202110/checkboxland尝鲜/"},{"title":"utools插件重载问题","date":"2021-10-27T07:47:05.000Z","date_formatted":{"ll":"2021年10月27日","L":"2021/10/27","MM-DD":"10-27"},"updated":"2021-12-11T01:00:08.681Z","content":"utools插件开发 中 plugin.json 中的配置无法生效问题\n\n0x10 需求\n最近两天打算找个不限制流量, 不限制容量的 图床, 之前 我一直用阿里云的OSS, 太鸡儿贵了\n因为我看到国外的不少图床 都是免费的 并且不限制容量不限流量, 我太心动了\n所以我打算把我国内的图床 换成国外的图床 然后在国内访问\n想法有了之后 我就开始动手折腾了,把所有的图片上传到国外的图床, 然后通过代理服务器访问就好了\n这就需要转链, 把原本图片的链接 转换成为 通过代理服务器访问的链接,所以我就需要搞个 utools工具  来帮助我方便的转链\n0x20 开搞\n这么久没有玩 utools也从1.x 升级到 2.x 了\n不过插件的开发方式还是大同小异\n开发过程挺顺利 不过中途遇到了几个坑, 我再这里记录一下\n0x21 utools加载插件的方式变了\nutools 1.x 可以直接加载插件 但是2.x 明显行不通\n2.x 如果你想要加载插件 你就需要首先下载一个 开发者工具 插件 这是一个开发utools插件的 插件, 如下图:\n\n0x22 utools插件重载\n本次插件开发当中遇到的一个最为蛋疼的问题就是插件重载的问题\nutools 识别不同插件是通过 一个plugin.json的文件\n这个文件里面可以定义  在什么时候什么条件下去唤醒 utools\n我在里面写了个通过正则表达式去匹配链接的方式去唤醒我的插件\n也就是说当我把国外的图床上图片的链接粘贴到utools的时候,utools会用我写好的正则表达式去尝试匹配这个链接,如果匹配成功  则utools 会调用我的插件 对 这个链接进行转链\n但是中途发现一个问题 就是链接 怎么都无法匹配成功\n我一度怀疑是我的正则表达式有问题导致无法成功匹配\n最后调试来调试去 发现 我无论怎么改正则表达式 就是无法匹配, 我才开始怀疑utools\n\n我已经 图中① 处的开关打开了\n按理说每次我插件UI进入隐藏状态之后 插件就会完全退出 等我再次进入插件 插件的代码都会重载\n本来我以为所有的插件代码都会自动重载\n但是 其实 实际情况并不是我想想的那样 如果你改动的是插件的逻辑代码 当你打开 图中①处的开关时候,插件确实会重载 但是如果你改动的是plugin.json 当中的内容, plugin.json 是不会被自动重载的, utools开发工具的自动重载 仅仅重载你插件的逻辑代码 不会重载你的 plugin.json文件, 这个文件 属于你的插件的配置文件\n好鸡儿蛋疼, 每次更改plugin.json 都需要 手动去重载 这个文件, 就是手动去按图中② 处的更新按钮\n0x23 js正则表达式的坑\n还有个比较坑的问题就是js的 正则表达式的坑:\n1&quot;text string&quot;.match(/exp/flags)\n我们使用 正则表达式的时候 一般会使用 不同的flag\njs 的正则表达式 也有各种flag  有  g  i m u y s 等各种flag\n但是在使用 match 函数的 时候 如果你的正则表达式使用的flag中有 g 这个flag\n则match 函数返回的匹配数据当中 不包含正则表达式匹配到的group数据\nmdn 中的原文是这样的:\n12If the g flag is used, all results matching the complete regular expression will be returned, but capturing groups will not.if the g flag is not used, only the first complete match and its related capturing groups are returned. In this case, the returned item will have additional properties as described below.\n一旦你的正则表达式使用了这个g flag,\n则match 函数返回的就不是详细的匹配数据,而仅仅是一个匹配结果,这样的话不是很方便做细致的调试\n","plink":"http://blog.lipanpanx.com/post/2021/202110/utools插件重载/"},{"title":"VueRouter的路径匹配引擎介绍","date":"2021-03-08T16:45:53.000Z","date_formatted":{"ll":"2021年3月8日","L":"2021/03/08","MM-DD":"03-08"},"updated":"2021-12-11T01:00:08.681Z","content":"今天闲的蛋疼 打算讲讲 VueRouter的路径匹配引擎\n这玩意是 github的一个开源项目 github 仓库地址\n\n","plink":"http://blog.lipanpanx.com/post/2021/202103/VueRouter路径匹配引擎/"},{"title":"VueRouter基本使用","date":"2021-03-05T18:35:48.000Z","date_formatted":{"ll":"2021年3月5日","L":"2021/03/05","MM-DD":"03-05"},"updated":"2021-12-11T01:00:08.681Z","content":"VueRouter基本使用步骤\n\n导入Vue Router (VueRoute.js的导入语句要放在Vue.js导入语句的下面)\n写好需要被路由的组件 并且成功注册组件\n使用new VueRouter(&#123;&#125;)创建路由对象的实例,并且在路由对象的routes选项当中添加路由规则\n将路由对象挂载到Vue实例中\n&lt;router-view&gt;&lt;router-view&gt;在页面当中占坑,被路径匹配到的组件会被渲染到这个坑位当中.\n&lt;router-link&gt;&lt;/router-link&gt;会被渲染成为导航链接, 导航到指定组件.\n\nVueRouter的下载和引入\nVueRouter 3.x github仓库地址\nVueRouter 4.x github仓库地址\nVueRouter 3.x 英文文档\nVueRouter 4.x 英文文档\nVueRouter 3.x 中文文档\nVueRouter 4.x 中文文档\n在项目当中使用VueRouter的方式有很多种,我讲一下最简单的一种:\n到github仓库的release页面下载相应的版本然后找到dist目录找到对应的源文件复制到自己的工作目录然后在自己的项目当中引用即可,需要注意的是在引入 vue-router.js之前需要先引入 vue.js\n组件准备\n在创建VueRouter实例之前需要创建好需要的组件,如果在创建VurRouter实例之后创建组件会导致创建VueRouter实例的时候无法找到路由规则相关的组件而报错,如果是局部组件还需要在对应的Vue实例当中注册组件.\nVueRouter实例的创建\n我写了一个快速创建VueRouter实例的vscode snippet:\n123456789101112&quot;newVueRouter&quot;:&#123;    &quot;prefix&quot;: &quot;newVueRouter&quot;,    &quot;body&quot;: [        &quot;const router = new VueRouter(&#123;&quot;,        &quot;    routes:[&quot;,        &quot;        $0&quot;,        &quot;    ],&quot;,        &quot;    linkActiveClass:&#x27;actived-link&#x27;,&quot;,        &quot;&#125;);&quot;,    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n这个snippet 不仅仅可以快速的创建VueRouter实例 并且已经指定好了默认的linkActiveClass的名字, 这个所谓的linkActiveClass就是当组件被选中的时候这个组件上会被添加一个类名, 我们可以通过这个类名控制当前被选中组件的的一些样式之类的. 然后你还可以在创建完成 VueRouter实例之后直接在 routes 当中填写路由规则,简直不要太方便.\n&lt;router-view&gt;和&lt;router-link&gt;\n&lt;router-view&gt; 也是一个组件 这个组件被用来渲染成为路径匹配到的组件.\n比如路径 http://127.0.0.1:5500/5565_test/5576_VueRouter.html#/User/44 如果你在VueRouter的路由规则当中添加了一套匹配User的规则 &#123;path: '/User/:id', component: User,&#125; 那么这条路径就会被匹配, User组件就会被渲染到页面的指定位置, 这个位置是由&lt;router-view&gt;决定, 这个东西和插槽非常的像.\n就像插槽有匿名插槽和具名插槽之分 &lt;router-view&gt; 也分有名字和无名子的&lt;router-view&gt;, 名字通过name属性去定义&lt;router-view name='xxx'&gt;&lt;/router-view&gt;同时 name属性也是 &lt;router-view&gt;组件唯一的自带属性. 通过为&lt;router-view&gt;添加name属性我们就可以在网页中添加名字各异的多个&lt;router-view&gt;了,然后配合路由规则就可以把不同名字的&lt;router-view&gt;渲染成为不同的组件.\n&lt;router-view&gt; 还有个比较棒的特性就是嵌套, 当我们把页面当中的某个&lt;router-view&gt;渲染成某个组件之后,这个组件当中仍然可以存在新的&lt;router-view&gt;,这个新的&lt;router-view&gt;可以渲染为当前组件的子组件.\n\n我们可以直接把组件写在页面当中,也可以用&lt;router-view&gt;显示组件,然后通过路径地址导航到我们的组件, 我们可以直接在浏览器的网址栏当中输入这个地址,我们也可以网页当中添加链接或者按钮导航到这个地址, 这个时候就需要使用 &lt;router-link&gt;了. 相关文档\n&lt;router-link&gt; 同样是一个组件, 这个组件在页面当中导航用的,通过 to 属性指定目标地址,在页面当中默认渲染成带有正确链接的 &lt;a&gt; 标签. &lt;router-link&gt; 除了to属性之外还有很多的属性可以设置:相关文档地址\n&lt;router-link&gt;的首要任务当然是导航, 但是在导航的时候它也可以提供query参数和 params参数\n12&lt;router-link to=&quot;/one?name=lnj&amp;age=33&quot; tag=&quot;button&quot;&gt;导航到路径/one &lt;/router-link&gt;&lt;router-link to=&quot;/two/zs/66&quot; tag=&quot;button&quot;&gt;导航到路径/two/zs/66 &lt;/router-link&gt;\n路径当中提供的参数 会被存储到$route当中 我们可以在被匹配到的组件内通过  拿到相关的数据. 更多关于$route的文档\n\n添加各种形式的组件路由规则\n&lt;router-view&gt; 可以被渲染成为组件,&lt;router-link&gt;可以被渲染成为链接导航到指定的组件, 而VueRouter的路由规则就是这二者之间的桥梁, 路由规则规定了什么样的链接导航到什么样的组件.\n在我们创建VueRouter实例的时候,有很多可选的构建选项:见文档,而这些构建选项当中的routes选项就是我们指定路由规则的地方, routes选项的值是一个数组,这个数组当中存放着 &lt;RouteConfig&gt;类型的路由规则.\n&lt;RouteConfig&gt;的类型定义如下:\n12345678910111213141516interface RouteConfig = &#123;  path: string,     //相对路径  component?: Component,    //和路径对应的组件  name?: string,    // 命名路由  components?: &#123; [name: string]: Component &#125;, // 命名视图组件  redirect?: string | Location | Function,  //重定向路由  props?: boolean | Object | Function,      //解耦  alias?: string | Array&lt;string&gt;,           //路由别名  children?: Array&lt;RouteConfig&gt;,            //嵌套路由  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void,  meta?: any,  // 2.6.0+  caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false)  pathToRegexpOptions?: Object // 编译正则的选项&#125;\n对于各种形式的路由为了方便理解 下面有一些简单的例子:\n一般路由\n1234567const router = new VueRouter(&#123;    routes: [        &#123;path:&#x27;/one&#x27;,component:one,&#125;,        &#123;path:&#x27;/two&#x27;,component:two,&#125;,    ],&#125;);// 只需要填写路径和对应的组件,访问路径就能显示对应的组件\n动态路由\n123456const router = new VueRouter(&#123;    routes: [        &#123; path: &#x27;/User/:id&#x27;, component: User, &#125;,    ],&#125;);// 通过动态路径参数, 可以允许不同的用户都能够匹配到 /User/:id 然后都使用User组件 \n命名路由\n12345678const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/user/:userId&#x27;, name: &#x27;user&#x27;, component: User &#125;    // 通过 name字段可以为路由添加名字 然后我们可以通过这个名字来使用这个路由    // &lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;    // 上面这个 &lt;router-link&gt; 默认情况下会被渲染成为&lt;a&gt; 链接 指向  /user/123     ]&#125;)\n重定向路由\n123456789101112131415161718192021222324const router = new VueRouter(&#123;    routes: [      &#123;path:&#x27;/&#x27;,redirect:&#x27;/one&#x27;&#125;  // 访问根地址 的时候URL重定向到 /one 然后显示one组件       &#123;path:&#x27;/one&#x27;,component:one,&#125;,      &#123;path:&#x27;/two&#x27;,component:two,&#125;,    ],&#125;);const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/foo&#x27;,name:&#x27;foo&#x27;,component:foo&#125;    &#123; path: &#x27;/a&#x27;, redirect: &#123; name: &#x27;foo&#x27; &#125;&#125;     // 重定向的目标也可以是一个命名的路由,     // 当你访问/a的时候  URL会被重定向到/foo 然后显示foo组件    // 当你访问/foo的时候 正常显示   ]&#125;)const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, redirect: to =&gt; &#123;      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    &#125;&#125;  ]&#125;)\n路由别名\n123456789const router = new VueRouter(&#123;  routes: [    &#123; path: &#x27;/a&#x27;, component: A, alias: &#x27;/b&#x27; &#125;    // 为路径/a 创建别名 /b,     // 就是说当你访问/a的时候 正常显示    // 当你访问/b的时候 URL会保持不变 但是路由会匹配到 /a相关的路由  ]&#125;)// 重定向的时候URL发生改变然后按照新URL匹配路由  路由别名URL不会发生变化按照相关联的别名匹配路由  \n嵌套路由\n1234567891011121314const router = new VueRouter(&#123;    routes: [      &#123;        path: &#x27;/User/:id&#x27;, component: User,        // 访问 /User/:id 显示User组件 并且User组件当中会显示它的子组件         children: [          // 访问 /User/:id/UserProfile 会在User组件当中 显示User的子组件 UserProfile           &#123; path: &#x27;UserProfile&#x27;, component: User.components.UserProfile, &#125;,          &#123; path: &#x27;UserPosts&#x27;, component: User.components.UserPosts, &#125;,          // 访问 /User/:id/UserPosts 会在User组件当中显示 User的子组件UserPosts        ],      &#125;,    ],&#125;);\n命名视图相关的路由\n12345678910111213141516const router = new VueRouter(&#123;    routes: [        &#123;            path: &#x27;/xxx&#x27;,            components: &#123;                default: test,                first: one,                second: two,            &#125;,            //某个目录/xxx 下一共三个 &lt;router-view&gt;            // 第一个没有name属性 显示为 test组件            // 第二个 name为 first 显示组件one            // 第三个 name为 second 显示组件two         &#125;,    ],&#125;);\n","plink":"http://blog.lipanpanx.com/post/2021/202103/VueRouter基本使用/"},{"title":"Vue生命周期钩子","date":"2021-03-05T11:03:32.000Z","date_formatted":{"ll":"2021年3月5日","L":"2021/03/05","MM-DD":"03-05"},"updated":"2021-12-11T01:00:08.681Z","content":"Vue生命周期钩子是Vue开发者为Vue使用者预留的接口,使用这些接口我们能够在Vue生命周期的各个阶段做一些灵活的数据控制,来达到一些不可告人的目的.\n生命周期钩子的使用\n在我们创建Vue实例的时候,需要提供一个对象,这个对象包括创建Vue实例的各种Options, Vue生命周期钩子是这些Options的一部分, 他们的值都是函数,当Vue实例到达某个生命周期后,就会尝试去调用这些生命周期对应的钩子函数. 对于Vue2.x而言目前已知的钩子函数包括下面11个:\n12345678910111213141516&lt;script&gt;    let vue = new Vue(&#123;        el: &#x27;#app&#x27;,        beforeCreate() &#123; &#125;,        created() &#123; &#125;,        beforeMount() &#123; &#125;,        mounted() &#123; &#125;,        beforeUpdate() &#123; &#125;,        updated() &#123; &#125;,        activated() &#123; &#125;,        deactivated() &#123; &#125;,        beforeDestroy() &#123; &#125;,        destroyed() &#123; &#125;,        errorCaptured() &#123; &#125;,    &#125;);&lt;/script&gt;\nbeforeCreate\n\n在调用beforeCreate的时候, 仅仅表示Vue实例刚刚被创建出来, 此时此刻还没有初始化好Vue实例中的数据和方法, 所以此时此刻还不能访问Vue实例中保存的数据和方法\n\ncreated\n\n在调用created的时候, 是我们最早能够访问Vue实例中保存的数据和方法的地方\n\nbeforeMount\n\n在调用beforeMount的时候, 表示Vue已经编译好了最终模板, 但是还没有将最终的模板渲染到界面上\n\nmounted\n\n在调用mounted的时候, 表示Vue已经完成了模板的渲染, 表示我们已经可以拿到界面上渲染之后的内容了\n\nbeforeUpdate\n\n在调用beforeUpdate的时候, 表示Vue实例中保存的数据被修改了\n注意点: 只有保存的数据被修改了才会调用beforeUpdate, 否则不会调用\n注意点: 在调用beforeUpdate的时候, 数据已经更新了, 但是界面还没有更新\n\nupdated\n\n在调用updated的时候, 表示Vue实例中保存的数据被修改了, 并且界面也同步了修改的数据了\n也就是说: 数据和界面都同步更新之后就会调用updated\n\nactivated\n\nkeep-alive 缓存的组件激活时会调用activated\n\ndeactivated\n\nkeep-alive 缓存的组件停用时会调用deactivated\n\nbeforeDestroy\n\n在调用beforeDestroy的时候, 表示当前组件即将被销毁了\n注意点: 只要组件不被销毁, 那么beforeDestroy就不会调用,beforeDestroy函数是我们最后能够访问到组件数据和方法的函数\n\ndestroyed\n\n在调用destroyed的时候, 表示当前组件已经被销毁了\n注意点: 只要组件不被销毁, 那么destroyed就不会调用, 不要在这个生命周期方法中再去操作组件中数据和方法\n\nerrorCaptured\n\n捕获一个来自子孙组件的错误时会调用errorCaptured\n\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vue生命周期/"},{"title":"Vuex基本使用","date":"2021-03-04T18:36:59.000Z","date_formatted":{"ll":"2021年3月4日","L":"2021/03/04","MM-DD":"03-04"},"updated":"2021-12-11T01:00:08.681Z","content":"0x10 Vue子组件之间数据传递\n在vue当中 同一个父组件下的子组件之间进行数据传递是非常蛋疼的,子组件之间并不能够直接传递数据,想要传递数据就需要首先将一方的数据通过函数传递给父组件, 然后在父组件中再把这个数据传递给另一方,如果组件的层级比较深,这样的操作可以说是非常麻烦了.\n0x20 Vuex的基本使用\nvuex官方github仓库地址    // vuex的3.x版本和4.x版本是在同一个仓库当中release的\nvuex 3.x 英文文档地址\nvuex 3.x 中文文档地址\nvuex 4.x 英文文档地址\nvuex 4.x 中文文档地址\n要想使用vuex 首先下载和引入vuex, 在官方github的release页面可以下载对应版本的vuex,下载好压缩包并解压之后,打开dist目录就能找到我们需要的vuex.js,把这个vuex.js引入到我们的项目当中就行了,不过需要注意的是 在引入vuex.js之前一定要先引入vue.js.\n上面我也说到了, vue的子组件之间传递数据还是非常蛋疼的,显然 vuex就是来解决这个问题的,那么如何使用vuex在子组件之间传递数据呢,其实也非常的简单:\n首先通过new Vuex.Store(&#123;&#125;)创建一个Store实例 并传递一个包含所需options的对象,这个对象中有个state字段里面包含了需要在子组件当中传递的数据,比如:\n12345const store = new Vuex.Store(&#123;    state: &#123;        count:0    &#125;,&#125;)\n然后我们把实例 store 挂在到父组件当中的store字段\n最后就能够在子组件当中操作count了,操作的方式也非常简单 直接通过this.$store.state.count就能操作这个count的值了\n但是这样直接操作的方式还是存在问题的,如果多个组件都去操作这个变量的时候,如果这个变量的值出现了问题你很难去判定到底是哪个组件的错误操作导致的,所以对于store.state当中的数据的公共操作可以提取出来,在创建Store实例时提供给 mutations 选项.具体代码如下:\n12345678910111213const store = new Vuex.Store(&#123;    state: &#123;        count:0    &#125;,    mutations: &#123;        add(state)&#123;            state.count++;        &#125;,        sub(state)&#123;            state.count--;        &#125;    &#125;,&#125;)\n在上述代码当中我们可以看到,在mutations当中我们低通了对count进行自增和自减的函数,我们想要在子组件中调用这个函数的时候只需要通过this.$store.commit(&quot;函数名字&quot;) 就行了,当然我们在调用函数的时候还可以传递参数,这个参数就是mutation的载荷(payload) this.$store.commit(&quot;函数名字&quot;,payload) 这个payload参数可以就是一般的参数也可以是一个对象,当然我们在mutation的对应函数里面接收这个payload就能正常使用了.\n除了使用this.$store.commit(&quot;函数名字&quot;) 的方式调用mutations当中的函数外还可以通过下面的方式调用:\n1234567891011this.$store.commit(&#123;    type:&quot;函数名字&quot;,    xxx:xxx,&#125;),------------------------------------------------------------------//  当commit接收到是一个对象的时候,mutation中对应的函数操作保持不变mutations: &#123;  函数名字 (state, payload) &#123;    state.count += payload.xxx  &#125;&#125;\n另外store也是支持计算属性的,这个计算属性和computed是差不多的,在创建Store实例的时候在提供的对象当中提供getters选项,这个getters选项当中的函数的返回值会被缓存起来,且只有当它的依赖值发生了改变才会被重新计算。\n1234567891011const store = new Vuex.Store(&#123;    state: &#123;        msg:&quot;lipanpanx.com&quot;,    &#125;,    getters: &#123;        test(state) &#123;            console.log(&quot;调用getter当中的test函数&quot;);            return state.msg+&quot;真不错&quot;;        &#125;    &#125;,&#125;)\n在getters当中提供了计算属性之后,访问这个属性也非常的简单,首先将store绑定到组件是必须的,然后在组件当中使用this.$store.getters.test 就能访问你的计算属性了\n当然如果你也可以让getters中的函数返回另外一个方法,这样以来就方便传参, 但是你返回的这另一个方法会被缓存起来, 方法毕竟不是一个固定的值,所以这个方法每次都会被重新调用来获取结果:\n123456789101112131415161718const store = new Vuex.Store(&#123;    state: &#123;        msg: &quot;lipanpanx.com&quot;,        xlist: [&quot;x&quot;,&quot;xx&quot;,&quot;xxx&quot;,&quot;xxxx&quot;],    &#125;,    getters: &#123;        test(state) &#123;            console.log(&quot;调用getter当中的test函数&quot;);            return state.msg + &quot;真不错&quot;;        &#125;,        testf(state)&#123;            return (id) =&gt; &#123;                console.log(&quot;这个方法每次都会被重新调用&quot;);                return state.xlist[id]            &#125;        &#125;    &#125;,&#125;)\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vuex基本使用/"},{"title":"Vue2组件化","date":"2021-03-03T10:56:47.000Z","date_formatted":{"ll":"2021年3月3日","L":"2021/03/03","MM-DD":"03-03"},"updated":"2021-12-11T01:00:08.681Z","content":"组件化的意义\n自定义组件\n自定义一个组件方法有很多,但是背后的创建逻辑却大同小异,有三个核心要素是必须的:\n1&gt;组件构造(传递给构造器的组件模板只能有一个根元素)\n2&gt;组件注册\n3&gt;组件使用\n基于上面的三个核心要素诞生了好多创建组件的方式,下面我简单介绍一下我使用vscode snippets创建组件的过程:\n创建全局组件\n1234567891011&quot;Vue.component&quot;: &#123;    &quot;prefix&quot;: &quot;Vue.component&quot;,    &quot;body&quot;: [        &quot;Vue.component(&#x27;$&#123;1:组件名称&#125;&#x27;, &#123;&quot;,        &quot;    template:&#x27;#$&#123;1:组件模板id&#125;&#x27;, //$&#123;0:&lt;template id=&#x27;$&#123;1:组件模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:组件根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,components:&#123;&#125;,&quot;,        &quot;&#125;);&quot;,    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n全局组件注册需要用到Vue.component(id,[definition])函数,我们可以向这个函数提供 组件名称和组件对象来 注册组件\n当我们传递组件对象的时候 Vue.component()会自动帮助我们使用Vue.extend()构造组件\n上面的这段代码能够帮助用户迅速的注册一个全局组件,在用户输入组件名称之后,snippets会根据输入的名称自动生成用于构造组件的组件对象和组件模板(第5行注释就是模板),然后用户只需要剪切模板到合适的位置就行了, 注册组件和组件模板 都搞定之后  用户只需要在合适的位置使用 &lt;组件名&gt;&lt;/组件名&gt; 就能使用组件啦\n创建局部组件\n1234567891011&quot;const-component&quot;:&#123;    &quot;prefix&quot;: &quot;const-component&quot;,    &quot;body&quot;: [        &quot;const $&#123;1:组件引用名&#125;=&#123;&quot;,        &quot;    template:&#x27;#$&#123;1:组件模板id&#125;&#x27;,&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,components:&#123;&#125;,&quot;,        &quot;&#125;; //$&#123;0:&lt;template id=&#x27;$&#123;1:组件模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:模板根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n这段创建局部组件的snippets和上面的 创建全局组件的snippets基本大同小异, 只是局部组件的注册和全局组件的注册有所不同\n局部组件 需要在vue实例的 components字段当中传递组件对象的引用或者直接传递组件对象 代码如下:\n12345678910111213141516let vue = new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;&#125;,    methods: &#123;&#125;,    computed: &#123;&#125;,    watch: &#123;&#125;,    filters: &#123;&#125;,    components: &#123;        &quot;组件名称&quot;:组件引用名        &#x27;组件名称&#x27;:&#123;            template:&#x27;#组件模板id&#x27;,            data:function()&#123;return&#123;&#125;&#125;,            methods:&#123;&#125;,props:[],components:&#123;&#125;,        &#125;,     &#125;,&#125;);\n如果直接在vue实例的components字段当中使用直接传递组件对象的方式 去注册局部组件 可以使用下面的snippets:\n1234567891011&quot;sub-component&quot;:&#123;    &quot;prefix&quot;: &quot;sub-component&quot;,    &quot;body&quot;: [        &quot;&#x27;$&#123;1:组件名称&#125;&#x27;:&#123;&quot;,        &quot;    template:&#x27;#$&#123;1:模板id&#125;&#x27;,&quot;,        &quot;    data:function()&#123;return&#123;&#125;&#125;,&quot;,        &quot;    methods:&#123;&#125;,props:[],components:&#123;&#125;,&quot;,        &quot;&#125;, //$&#123;0:&lt;template id=&#x27;$&#123;1:模板id&#125;&#x27;&gt; &lt;div class=&#x27;$&#123;1:模板根元素类名&#125;&#x27;&gt; &lt;div&gt;我是组件$&#123;1:组件名称&#125;&lt;/div&gt;&lt;/div&gt; &lt;/template&gt;&#125;&quot;    ],    &quot;scope&quot;: &quot;javascript&quot;,&#125;,\n局部组件之所以叫局部组件,那就是他的使用范围是被限定的,如果某个Vue实例注册了局部组件,那么这个局部组件就只能在这个实例中使用,全局组件则可以在多个Vue实例当中共用\n自定义组件中的data和methods\n从上方自定义组件的snippets我们也可以看出来 自定义组件时候也可以传递 data 和 methods属性\n因为在自定义组件的模板中 我们也会使用到自定义的函数 也会使用自定义的数据 所以就像Vue实例一样我们也需要这两个属性\n123456&lt;template id=&#x27;test&#x27;&gt;    &lt;div class=&#x27;test&#x27;&gt;        &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;按钮&lt;/button&gt;        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;\n在创建Vue实例所使用 对象 当中 data 和 methods 属性的值都是 一个对象\n自定义组件的 methods属性和 Vue实例创建时候提供的methods属性使用方式几乎相同 都是一个包含若干函数的对象\n但是 自定义组件当中的 data属性却是一个函数 这个和Vue实例创建的时候提供的data属性是完全不同的\n1234567891011Vue.component(&#x27;test&#x27;, &#123;    template: &#x27;#test&#x27;, //    data: function () &#123; return &#123;        msg:&quot;hehe&quot;,    &#125; &#125;,    methods: &#123;        clickHandler(x)&#123;            console.log(x);        &#125;    &#125;, components: &#123;&#125;,&#125;);\n为什么创建自定义组件所传递的组件对象当中的 data属性是一个函数呢,其实原因也很简单,假如我们有一个组件X, 这个组件X我们可能在网页当中使用很多次, 这就是组件的复用, 但是组件复用的前提是每个组件是不完全相同的, 即使都是组件X,每个组件应该显示不同的数据, 如何确保每个组件显示的数据是不同的呢, 这就需要 每个组件和自己的数据绑定而不是和公用的数据绑定, 所以自定义组件的data属性就是一个返回对象的函数, 这个函数会针对每个组件X返回一个对象, 这个对象会和每个组件X进行绑定, 这样以来每个组件X就会有自己独享的数据对象了.\n组件切换与动态组件\n有时候我们需要在不同的组件之间进行切换, 对于一般的组件切换我们可以使用 v-if来实现,v-if虽然也不错 但是官方提供了更加有趣的方案 那就是动态组件, 而且 通过 &lt;keep-alive&gt; 标签 我们可以实现保存组件切换前后的状态\n假设我们有两个组件 分别是 组件aaa 和组件bbb  如果想要通过动态组件实现2个组件之间的切换就比较简单\n123456&lt;div id=&#x27;app&#x27;&gt;    &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;按钮&lt;/button&gt;    &lt;keep-alive&gt;        &lt;component :is=&#x27;componentx&#x27;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;/div&gt;\n如上 我们为&lt;component&gt;标签的is属性绑定一个变量 componentx, 用这个变量我们久能控制需要被显示的组件是哪个组件\n然后 通过按钮的点击事件就可以去改变 变量 componentx的值 也就可以切换当前显示的组件了,而且由于&lt;component&gt;标签是被放在 &lt;keep-alive&gt;标签里面的所以组件切换前后 组件的状态能够被很好的保存, 假如组件aaa中有个checkbox是check的状态, 那么切换到组件bbb再切换回组件aaa 这个checkbox依然会保持check的状态\n父子组件\n组件和Vue实例一样都能使用components属性,也就是说每个组件都能通过components属性定义自己的局部组件,也就是每个组将都能有自己的子组件\n就像上文中的局部组件只能在相应的Vue实例当中使用一样  子组件也是只能在父组件当中使用\n如果我们定义了一个父组件father, 并且在father组件对象当中的components属性中又定义了一个组件son, 那么 &lt;son&gt;&lt;\\/son&gt; 就只能在father组件的模板当中使用\n父子组件这样的父子关系,让他们之间的数据交换比其他组件之间更加容易 更加灵活\n子组件使用父组件的数据\n子组件使用父组件中数据的2个步骤:\n1&gt; prop是你可以在组件上注册的一些自定义attribute,我们在创建子组件的时候通过提供props来声明我们的子组件定义了那些prop, 也就是 我们创建子组件的时候想要注册的一些自定义 attribute 写道 props当中去,如下son组件当中声明了2个自定义的 attribute 分别是 xxx和yyy .\n1234567891011121314151617components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;            age:28,            name:&quot;lipanpan&quot;        &#125; &#125;,        methods: &#123;&#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;&#125;, props: [&quot;xxx&quot;,&quot;yyy&quot;], components: &#123;&#125;,            &#125;,        &#125;,    &#125;,&#125;,\n2&gt; 然后我们在父组件的模板当中使用子组件的时候 就可以将自己的数据绑定到子组件的属性上面,由于刚才我们为子组件定义了2个属性 xxx和yyy, 我们将父组件的 age 和name 绑定到这2个属性上,然后我们在子组件的模板当中 使用自己的属性就相当于使用父组件的数据.\n1234567891011121314&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son :xxx=&quot;age&quot; :yyy=&quot;name&quot;&gt;在父组件当中使用子组件&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;div&gt;来自父组件的数据xxx:&#123;&#123;xxx&#125;&#125;&lt;/div&gt;        &lt;div&gt;来自父组件的数据yyy:&#123;&#123;yyy&#125;&#125;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n子组件使用父组件的方法\n子组件使用父组件当中方法的2个步骤:\n1&gt; 首先在父组件中通过v-on 绑定事件监听器\n123456&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son @father-func=&#x27;fatherSay&#x27;&gt;在父组件当中使用子组件&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\n2&gt; 然后在子组件的某个函数当中 通过$emit()触发事件 调用事件处理函数(这里是父组件当中的方法)\n123456&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;button @click.prevent=&#x27;sonFunc($event)&#x27;&gt;按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;\n123456789101112131415161718192021222324components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;&#125; &#125;,        methods: &#123;            fatherSay()&#123;                alert(&quot;我是father组件的方法&quot;);            &#125;        &#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;                    sonFunc()&#123;                        this.$emit(&quot;father-func&quot;)                        // 使用 $emit 触发事件                         // 传递给$emit的方法名字是一个字符串                    &#125;                &#125;, props: [], components: &#123;&#125;,            &#125;,         &#125;,    &#125;, &#125;,\n子组件将数据传递给父组件\n子组件传递数据给父组件可以通过 调用父组件的方法来实现\n12345678910111213141516171819202122232425components: &#123;    &#x27;father&#x27;: &#123;        template: &#x27;#father&#x27;,        data: function () &#123; return &#123;            input_msg:undefined,        &#125; &#125;,        methods: &#123;            fatherSay(data)&#123;                console.log(&quot;我是father组件的方法&quot;);                this.input_msg=data            &#125;        &#125;, props: [],         components: &#123;            &#x27;son&#x27;: &#123;                template: &#x27;#son&#x27;,                data: function () &#123; return &#123;&#125; &#125;,                methods: &#123;                    sonFunc()&#123;                        this.$emit(&quot;father-func&quot;,Math.random())                    &#125;                &#125;, props: [], components: &#123;&#125;,            &#125;, //        &#125;,    &#125;, //&#125;,\n由上面的代码可以看到 子组件在传递数据给父组件的时候,只需要在使用vm.$emit(&quot;xxx&quot;,[...args])调用父组件的方法的时候把需要传递的数据当作参数传递过去就行了,然后在父组件的方法中接收和使用子组件当中传递过来的参数\n多级组件数据传递\n由上文我们可以知道 子组件可以使用父组件的数据, 子组件可以调用父组件的方法并且将数据传递给父组件, 但是如果组件的层级比较多, 比如子组件使用爷爷组件的数据和方法应该如何做: 这里只是简单介绍一种相对容易理解但是挺麻烦的做法那就是一层层的传递, 儿子组件想要使用爷爷组件的数据和方法首先把想要使用的数据和方法从爷爷组件传递给父组件,然后再从父组件传递给儿子组件就行了.\n组件中的命名注意点\n组件名子的命名\n\n注册组建的时候如果组件的名字使用了驼峰命名法, 那么html中使用组件的时候需要使用短横线命名法去使用这个组件. 例如: 注册时: myFather -&gt; 使用时: &lt;my-father&gt;&lt;/my-father&gt;\n\n12345Vue.component(&#x27;myFather&#x27;, &#123;    template: &#x27;#myFather&#x27;, //    data: function () &#123; return &#123;&#125; &#125;,    methods: &#123;&#125;, components: &#123;&#125;,&#125;);\n1234567891011&lt;body&gt;    &lt;div id=&#x27;app&#x27;&gt;        &lt;!-- &lt;myFather&gt;&lt;/myFather&gt; 注册组件的时候使用驼峰命名 使用组件的时候不能使用驼峰命名 --&gt;         &lt;my-father&gt;&lt;/my-father&gt;    &lt;/div&gt;&lt;/body&gt;&lt;template id=&#x27;myFather&#x27;&gt;    &lt;div class=&#x27;myFather&#x27;&gt;        &lt;div&gt;我是组件myFather&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n组件传入变量命名\n\n父组件传递数据给子组件的时候, 传入的变量名如果使用短横线命名方式,子组件得到的变量会被转换称为驼峰命名方式的变量. 例如: 传递时: parent-name=“name” -&gt; 接收时: props: [“parentName”]\n\n123456789101112131415&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;!-- &lt;son :parentName=&#x27;names&#x27;&gt;&lt;/son&gt; 父组件中使用驼峰命名法传递给子组件的变量名会被全部转换成为小写--&gt;        &lt;son :parent-name=&#x27;names&#x27;&gt;&lt;/son&gt;         &lt;!-- 使用短横线命名法传递给子组件的变量名 会被转换成为驼峰命名法 --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;div&gt;来自父组件的数据:&#123;&#123;parentName&#125;&#125;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;\n12345678910111213Vue.component(&#x27;father&#x27;, &#123;    template: &#x27;#father&#x27;, //    data: function () &#123; return &#123;        names:[&quot;zhangsan&quot;,&quot;lisi&quot;]    &#125; &#125;,    methods: &#123;&#125;, components: &#123;        &#x27;son&#x27;: &#123;            template: &#x27;#son&#x27;,            data: function () &#123; return &#123;&#125; &#125;,            methods: &#123;&#125;, props: [&quot;parentName&quot;], components: &#123;&#125;,        &#125;, //    &#125;,&#125;);\n组件传入的方法命名\n\n父组件将自己的方法传递给子组件的时候, 传入的方法名字如果使用驼峰命名法, 这个传入的方法名会被转换成为全部小写的形式,因为html属性是大小写不敏感的, 所以我们用v-on绑定的事件名称即使有大写字母也会全部被转换成为小写.\n例如: 传递时: @parent-say=“say” -&gt; 触发时: this.$emit(“parent-say”);\n\n12345678910111213&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son @fatherFunc=&#x27;say&#x27;&gt;&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;button @click.prevent=&#x27;clickHandler($event)&#x27;&gt;触发器按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;\n12345678910111213141516171819202122Vue.component(&#x27;father&#x27;, &#123;    template: &#x27;#father&#x27;,    data: function () &#123; return &#123;        names:[&quot;zhangsan&quot;,&quot;lisi&quot;]    &#125; &#125;,    methods: &#123;        say()&#123;            console.log(&quot;我是父组件的方法&quot;);        &#125;    &#125;,     components: &#123;        &#x27;son&#x27;: &#123;            template: &#x27;#son&#x27;,            data: function () &#123; return &#123;&#125; &#125;,            methods: &#123;                clickHandler($event)&#123;                    this.$emit(&quot;fatherfunc&quot;)                &#125;            &#125;, props: [], components: &#123;&#125;,        &#125;,    &#125;,&#125;);\n组件中的插槽是什么?\n默认情况下使用子组件时在子组件中编写的元素是不会被渲染的,如果子组件中有部分内容是使用时才确定的, 那么我们就可以使用插槽. 插槽就是在子组件中放一个&quot;坑&quot;, 以后由父组件来&quot;填&quot;\n123456&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;如果没有插槽 这句话是不会被渲染到页面上的 只会渲染son组件模板当中的内容 &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是匿名插槽?\n匿名插槽是子组件根元素当中的 &lt;slot&gt;可以有默认值&lt;/slot&gt;标签, 这些标签所在的位置就是预留的坑位,当我们在父组件当中使用子组件时如果往子组件的标签对当中写入了内容这些被写入的内容就会把  &lt;slot&gt;&lt;/slot&gt;标签以及其包裹的内容替换掉,如果子组件当中有多出&lt;slot&gt;&lt;/slot&gt;则替换多次\n1234567891011121314&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;我会替换掉slot标签以及被slot标签包裹的内容&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;slot&gt;插槽默认内容 我在网页当中会直接被渲染成字符串&lt;/slot&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot&gt;插槽默认内容 我在网页当中会直接被渲染成字符串&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是具名插槽?\n具名插槽和匿名插槽所差无几,只不过具名插槽的&lt;slot&gt;标签 有个name属性,这个属性就是插槽的名字, 在父组件中向子组件标签对中插入内容时候 可以通过slot=name属性控制插入到对应 name的插槽当中去\n12345678910111213141516171819&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;div slot=&quot;one&quot;&gt;往插槽名字为one的插槽中插入内容1&lt;/div&gt;            &lt;div slot=&quot;two&quot;&gt;往插槽名字为two的插槽当中插入内容&lt;/div&gt;            &lt;div slot=&quot;one&quot;&gt;往插槽名字为one的插槽中插入内容2&lt;/div&gt;            &lt;div slot=&quot;two&quot;&gt;往插槽名字为two的插槽当中插入内容&lt;/div&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;slot name=&#x27;one&#x27;&gt;插槽默认内容&lt;/slot&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot name=&#x27;two&#x27;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n什么是作用域插槽?\n作用域插槽就是可以传递数据的插槽 子组件当中的数据通过&lt;slot v-bind:'xxx'='xxx'&gt;&lt;/slot&gt; 的形式传递给父组件,然后父组件通过 &lt;template slot-scope='obj'&gt;&lt;template&gt;的形式来使用子组件当中的数据\n12345678910111213141516171819202122&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot :names=&quot;names&quot; :test=&quot;test&quot;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;template slot-scope=&quot;obj&quot;&gt;                &lt;hr&gt;                &lt;div v-for=&quot;name in obj.names&quot; :key=&quot;name.id&quot;&gt;                    &#123;&#123; name &#125;&#125;                &lt;/div&gt;                &lt;hr&gt;                &#123;&#123;obj&#125;&#125;            &lt;/template&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;\nv-slot指令怎么使用?\nv-slot指令是 Vue2.6 之后引入的指令,v-slot指令 使得在父组件当中书写插入到子组件当中的内容时更加的方便, 我写了2个snippets来快速使用这个指令:\n12345678910111213141516&quot;slot&quot;:&#123;    &quot;prefix&quot;: &quot;slot&quot;,    &quot;body&quot;: [        &quot;&lt;slot $&#123;1:name=&#x27;$&#123;2:slot-name&#125;&#x27;&#125;$&#123;0&#125;&gt;插槽默认内容&lt;/slot&gt;&quot;    ],    &quot;scope&quot;: &quot;html&quot;,&#125;,&quot;vslot&quot;:&#123;    &quot;prefix&quot;: &quot;vslot&quot;,    &quot;body&quot;: [        &quot;&lt;template #$&#123;1:default&#125;=&#x27;obj&#x27;&gt;$&#123;0:需要被插入的内容&#125;&lt;/template&gt;&quot;    ],    &quot;scope&quot;: &quot;html&quot;,&#125;,\n首先就是创建插槽的 slot代码段,这个代码段在子组件当中使用 可以快速创建匿名插槽和具名插槽, 在写完插槽的名字之后 你就可以进行随意的数据绑定把子组件的数据传递给父组件的使用者\n然后就是vslot代码段, 这个代码段在父组件当中使用,  可以快速的创建 带v-slot(#)属性的 template标签, 这个标签对应的默认插槽是匿名插槽(#default), 这个标签同时又一个默认对象obj,这个对象能够接收 子组件的插槽通过v-bind传递过来的数据\n123456789101112131415161718&lt;template id=&#x27;father&#x27;&gt;    &lt;div class=&#x27;father&#x27;&gt;        &lt;div&gt;我是组件father&lt;/div&gt;        &lt;son&gt;            &lt;template #one=&#x27;obj&#x27;&gt;                &#123;&#123;obj&#125;&#125;                 &lt;hr&gt;            &lt;/template&gt;        &lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;template id=&#x27;son&#x27;&gt;    &lt;div class=&#x27;son&#x27;&gt;        &lt;div&gt;我是组件son&lt;/div&gt;        &lt;slot name=&#x27;one&#x27; :names=&quot;names&quot; :test=&quot;test&quot;&gt;插槽默认内容&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;\n","plink":"http://blog.lipanpanx.com/post/2021/202103/Vue2组件化/"},{"title":"ShareX截图自动添加水印","date":"2021-02-16T09:18:01.000Z","date_formatted":{"ll":"2021年2月16日","L":"2021/02/16","MM-DD":"02-16"},"updated":"2021-12-11T01:00:08.681Z","content":"\nsharex 截图之后是可以自动添加水印的  就像上面这样鼠标右键点击桌面底部任务栏中的sharex的小图标 设置即可\n但是这个添加水印效果是需要你实现设置好的  当你有添加水印的效果之后才能使用它\n如何在sharex中添加水印的效果呢?\n下图建议PC端查看 高清大图地址\n\n\n首先在桌面任务栏中的sharex小图标上右击鼠标 打开sharex菜单 然后按照上图步骤操作, 然后按照下图 添加水印效果即可\n\n\nSharex水印常用的配置项:\nSharex能对水印进行的操作还是比较全面的 我翻译一下常用的配置项\n\nText: 水印的内容\nPlacement: 水印的大概位置\nOffset: 水印相对于大概位置的偏移量\nTextFont: 水印的字体\nTextColor: 水印的颜色\n还有 水印阴影 水印渐变 等等各种乱七八遭的设置 感觉没多大用\n\n然后就是设置水印会出现的矛盾点:\n如果你的水印字体设置过大 那么就会出现 有些图片比较小 水印显示不全\n如果你的水印字体设置较小 就会出现 别人看不清的情况\n如果你的水印字体设置的 不大不小 就会出现 影响图片观感 看起来图片怪怪的\n还有就是黑色图片不能很好的显示黑色水印\n白色图片不能很好的显示白色水印\n图片设置水印矛盾点的解决办法:\n一个不错的解决方法 就是在一个预设中设置多个大小不同 颜色不同的水印 用来达到最好的效果:\n\n\n这样的话 无论大图小图 黑图白图 都能搞定\n","plink":"http://blog.lipanpanx.com/post/2021/202102/ShareX截图自动添加水印/"},{"title":"搭建Hexo博客","date":"2021-02-01T17:22:48.000Z","date_formatted":{"ll":"2021年2月1日","L":"2021/02/01","MM-DD":"02-01"},"updated":"2021-12-11T01:00:08.681Z","content":"重新搭个博客, 这里做一下记录\n\n0x10 前情提要\n最近决定重新搞个博客,申请个域名,搞的大气一些\n之前的 xxx.gitee.com 确实有点拿不出手了\n0x20 博客方案\n搭建博客 现在有很多的方案,由于是个人博客,平常就是发一些自己写的技术文,访问速度够快就行\n所以就搞成静态博客就行了,但是静态博客也有很多方案可以选择 hexo hugo vuepress 等等\n最终我还是选择了 hexo, hexo是js写的没有hugo(go语言写的)快,但是hexo相对比较成熟,主题的可选择项又多,而且我知道有比较厉害的博客是用hexo+next实现的, 比如cuiqingcai.com, 而且我之前的博客也是基于Hexo搭建的,不想再折腾其他框架了.至于主题,我选择的是一个非常非常非常小众的主题inside,我感觉不错所以就用了,由于是小众主题我已经做好了踩坑的准备了\n0x30 着手开始搭建\n既然方案都想好了那就开始搭建\n0x31 域名购买\n这个比较简单 阿里云腾讯云都可以买,我在腾讯云上面买下了 lipanpanx.com 年费是61\n直接下单就行了,非常简单,不过如果是第一次买的话, 他会要求你进行实名认证, 你需要填写一个信息模板,然后等待审核,认证成功后才能购买,我的过往经验告诉我在腾讯云买域名要比在阿里云买更快,但是腾讯云的域名数据库貌似要比阿里云更新的慢,有些域名在阿里能搜到在腾讯搜不到\n0x32 域名解析服务\n域名解析我用的 cloudflare, 免备案,免费的全球CDN,DNS刷新速度快,域名保护,代码压缩,还有酸爽的开发者模式,还要啥自行车,闭着眼选\n0x33 代码仓库的架构\n源码仓库结构是大仓库套小仓库的形式,把博客的仓库和主题的仓库分割开来,把主题仓库放到博客的仓库里面,通过submodule 进行管理,这个嵌套的源码仓库是私有的仓库,同时还会有个公共的仓库,用来放置最后生成的静态文件:\n我解释下为啥要这么做:\n首先源码仓库进行套娃的原因是确保主题仓库的稳定性,毕竟主题不是自己维护的,所以稳定性非常的重要,万一那天我喝多了对主题瞎改一通,或者在代码有大量更新的时候不小心删除了某个非常重要的主题文件,结果在提交代码的时候正好眼瞎没看到更改, 全部提交, 后面排错真的是瞅瞎眼,或者是主题的作者对主题做了重要的更新,也能很容易的进行同步,如果你直接把主题代码纳入到你的源码仓库,而不是分而治之,那你在更新主题的时候还需要去删掉之前所有的主题文件,然后重新添加新的主题文件,那样的话主题就完全不受版本控制了,而且你自己的更改也无法保留,这非常的蛋疼, 所以源码仓库中的博客仓库和主题仓库非常两个仓库是非常有必要的\n同时还有个问题就是我使用github pages部署我的静态站点, github pages可以很方便的绑定自己的域名,但是github pages仅仅支持公共仓库,对于私有的仓库github pages不提供服务, 为了保护我的源码仓库,我把源码仓库搞成私有的,然后使用github actions在我每次提交代码的时候自动执行生成静态站点文件的指令, 然后把生成的静态站点文件自动部署到我设置好的公开仓库当中.\n有人会觉得把主题当作仓库clone到项目当中是不合理的,很多主题都提供了npm包,为啥不直接安装主题包呢,把主题仓库clone到自己的源码仓库岂不是很麻烦,确实在绝大多数情况下主题包可以很好的满足人们的需求,但是一些定制化的需求是需要去更改主题源码的,这个时候主题包就无法完成需求了.\n0x34 github绑定多域名的问题\n因为我之前做了一个静态的营销网站quenmaimai.com 这个网站使用的仓库是 lipanpan-hub.github.io 这个仓库是github pages的专用仓库, 我在这个仓库里面放了cname文件, 把quenmaimai.com 绑定到了我的github,这样一来我所有的新项目仓库 如果开通 github pages 就会被定向到 quenmaimai.com/仓库名称 这个地址, 但是我申请了新的域名 lipanpanx.com, 我希望某个特定的仓库可以和 lipanpanx.com 进行绑定,然后其他的仓库仍旧和 quenmaimai.com进行绑定, 这个操作确实有点骚气了, 我找了网上的各路大神发的帖子,一顿操作猛如虎,然后一看二百五,没一个能用的,最后通过google找到一篇国外老铁发的文章, 他遇到的问题和我相同, 给出的解决方案也很清晰,亲测完美解决我的问题, 方案如下:\n\n在你的域名服务商网站 找到你的域名设置DNS的地方 添加5条DNS解析记录\n“A Record” with host “@” and value “185.199.108.153”\n“A Record” with host “@” and value “185.199.109.153”\n“A Record” with host “@” and value “185.199.110.153”\n“A Record” with host “@” and value “185.199.111.153”\n“CNAME Record” with host “www” and value “githubUsername.github.io”\n\n前四条A记录 指向 github的IP地址, 最后一条cname记录指向 github pages 的专用仓库地址 github用户名.github.io\n同时在仓库的GitHub pages设置页面也要进行域名绑定  最后就能成功访问 lipanpanx.com 啦\n0x35 github actions的安全问题\ngithub actions一般是在 github的虚拟机里面执行的(也有在其他地方执行的比如容器,比如自己的主机), 可以执行的操作有非常多, 有时候为了方面我们会用到github官方的一些 actions 或者一些第三方的 actions,无论这些actions本身是否是安全的,一定要确定你使用这些actions的方式是安全的.如果阅读了github actions的官方文档就会发现 GitHub actions的文档几乎在任何地方都会提醒你要确保安全, 因为一些actions会操作仓库,所以会需要你提供 personal token给它, 但是personal token的权限实在是太大, 向我这种私有的源码仓库还好, 有些共有的源码仓库如果你直接把person token 填写到actions里面 就非常的危险, 因为这意味着任何访问到你仓库的人都能拿到你的personal token, 所以可以把把你的personal token搞成变量以变量的形式提供给actions,如下图所示:\n\n在途中3号点位处 点击 添加新的 repo secret 就能添加变量了,添加完成变量就能在actions当中访问了\n比如你添加了一个  PERSONAL_TOKEN 的变量, 那么在actions当中你就能通过$&#123;&#123;secrets.PERSONAL_TOKEN&#125;&#125;去访问\n0x37 主题配置文件\nhexo项目当中 对主题进行配置主要使用下面的几种方式:\n\n直接在网站的配置文件(网站根目录的config.json)当中的 theme_config下面添加主题配置\n在网站根目录中添加 _config.[theme].yml 对主题进行配置\n在/source/_data/[theme].yml 当中进行配置\n在 themes/theme 文件夹下面的 主题源码当中找到 config.yml 进行配置\n\n上面的几种方法各有利弊吧, 但是最终我选择了第二种方法 在网站的根目录下面创建了一个 _config.inside.yml 文件配置主题\n我简单说下不选择其他几种方法的原因:\n\n首先是第一种方法 网站的配置和主题的配置放在 一起, 首先会导致这个配置文件内容过长, 读取速度缓慢,而且文件内容过长的时候可读性就会变差, 你找个配置可能要找半天, 还有就是两个既然都放在一起了 只能一起做版本管理 无法单独做版本管理  这就有点蛋疼了\n然后就是第三种方法, 这种古老的方法 几乎已经被抛弃, 主题的配置文件放到 网站的内容目录里面 感觉怪怪的 现如今已经很少人用了\n最后 就是第四种方法, 这种方法就是相当于去修改主题的源码, 对于一般人来说动源码风险还是比较大的 万一改错了 又不知道怎么改回来 那就相当蛋疼,只能重新clone仓库\n\n然后我说一下选择第二种方法的原因:\n首先 在网站的根目录下面创建新的 _config.[theme].yml 能够很好的把网站配置和主题配置分割开来, 两个配置文件单独的做版本控制,单独做版本控制是比较重要的 如果出现问题就比较容易进行方便的代码回滚,就容易排错, 然后还有最妙的一点 就是在Hexo5中上面的 方法1和方法2 和方法4 中的配置文件是同时生效的, 其中方法1的优先级最高, 方法2的优先级居中, 最后是方法4, 如果我们采用第二种配置方法 首先能够确保 themes/theme文件夹下面有个最基本的准确配置(这个配置是主题的作者写的默认配置),然后我们在上层怎么配置都行 大不了配置错了改改就行了 反正有最可靠的基本配置在 怎么改_config.[theme].yml都不怕.关于多处主题配置是如何协同工作的 hexo 官方文档中有比较详细的说明:点击此处查看\n0x36 Inside主题代码注入\n主题的能力是有限的, 别人花精力写的东西我们直接拿过来白嫖那就肯定不能做到十全十美满足你的所有需求, 这个时候就需要代码注入来满足你的需求.\nU2FsdGVkX192y3OtD3QCUAe+maysSf9W2CEudZjQlm+kpMU0KLV5mDgmPPqhKjLMy9W6wmgNrVfToMOQlVL8Cy/LsUF7cRy8ceQMNTc23SeNS3C8/GpGMMgkOUgM6xcZEnIStr5N1qxghgUzxIYH6SOm4037LITPIYRsEJW3aoV6r1THeYijPWuCZ/TMSgRxRmajSDo9kH3npEnnhzUxPY/rW2QFELWSS4NcPNc2JVVFFk2yIRIU/c4AfmxW17jHwkJJXkGO8xDeFIDI4ukySv17RlYk8Qu1mnPE+kHLGQyEWtg6RLQXxdiCItqjAGjor3ppif38Q0dZfDaH/dHcXtnurnUcc9zY3RjSkP1h7a1Vv1OII1ndjp+Lfz15I0sWQ6H2RDhHc+pyrVOu9xA8uEEhRCkFRpJX5wg+XGiSKNeUyJ4Ajq/RgTmp78yDx/Q7HbrsHFvaNOWwYuDuaUhkNdOYbCrRuC+p87iC7LD3t4l62LKche3U57QnXiq5QiQ38VJAL1+lFEQGV2QncbEpMTvGsiHwz8YGlPus8L+bx83/jwnHSJNSXQx7Pe3lxvYxvugyBeEop36o5VFFG7DZHqRKDSMhGR2KI1KtDY7o3lk/14E6W2l+huLI36nr4vS507XfUJc0SEsxM8aEDs3prbmmhEQ8uxcgzB8tWv4tdQHOSvC6tCtSY6Tbzo6MkX8NjlAGjRrAB316Yc40Z5TWSkvXbNwwjI1psDt8QU9UtRWCID9BdEBfBDVKJNaI/EAYQZQ6Vd7DkcIlzQBu7CliU8cFUERFpaDP6N2w5LK0FKgh9JbfNHKvVvViwMc8AmoCb/nxP9tklOagXCtfFPLoRM0/QlgVvDWHOAT7S2HAdpo0e1zi9wUago7bIXS6d4RF4VrKkk12++6ZjM89KjLx04uD908k8WuAlvNVDqSnyH0gSIbL4CbgeDKomPNQx7Mjl1KDMVRQKzdIdl5Vfy8V2zZmA8pNr57IrC7Bcve2fM6LrNq0rvgQP7y4O8Dz8qj86W/nUCo2V3T1pMBwqx1Q2ma9t41RnTDv+u16YbdunGX8vavD+c05U6Sh7IeXWrZulCT45uNYNxUlwJl8lrYfuJo/mzt3vEZDKEy4BlNLhIbIk8bqKlEiMqDfQnpSrrv2XoxKHBx8pDnWjP39EJiyomKr7rWBV4o5nYDQAVOkFu1Bq654y2fEow1M31sHu1SryH6cTZTMRTBErqwG6RLCbawaQ8kWdZBrdsYuxZQ1I7DqgOSjrLMEeIPvdxUuWJMh57isecCzutQjSr83ZKJ29KTAqMrGWYTGoBEZx2lLO7sUXQN6tvjkJsQYtEmALy3j1uCnSmwt936eOW4to7UMmvPY4hT9zEIh4FClK+dLJ9aqPiuDBUgkeWdH198xxq/JOKMP3pY1/1rbh1bjEn3i6QDXzTGNwqJF4NqazV5OAjEkDqFmYFA59E0V6GJ2wFHqk1hiluQYu/mRbMkZbCVE+84n7zcAfZrqcMV7/0gvf7+5PTd6n1jn7Rlllyd5dnvkoWr/nu9hq4Qp4VmfWWFz5gznTUzW3ASfyEM3xciBa3u51zwo1/304oV72/4i8mBHWMTtxq7uDMERJbqtR6KmBiDYqa+oo9B7kd8A9Ia/7tKuDFz56wkFGviEvyDJMG0Z0R2dH0aCnmeBD+5w4OOezXpyAhsizYGIw15ygSViB2yvUN5xq7ujbh6SsTLLPoLs7FQvDmdKlp1f1W5TfiH6AHmA1lHuPcklECjcfWKg7k0QZSbls260BagIqx/WHQo1hhNR67p0SR8SLgriu8mSwqYGhtahekCWAbDr+Cu4ZzcHIiYRcuhOpFqL7c74QQ1dt+f/M3Jx6hND3AlsoT8MxlmbH2vp25IU4mQUec5zTK2llwG6Ls4K+WYQ41QD/RUub82GdkDKfGDAN5FKIYHRC8Gsu1cHI51ZcQ+OcAsXQedSNduQsG4dts1MARwMQA2BwWslSaFCQ9UvnJ3i2Au4z4V6DMPf4RmcK1EGoUS4VNe9CRcWPgBn20V5wLxsc+tx+O/S3qlCucG0UhJUR24K46LKYzMz1UN0uwG/2v/V9oNa/ymXsVYflnEOD6PSsaD4JtvNgjG9gJotA8ocDnk143jnZ9rLwG1J9VOzDdluQW2AZIatljoW8biHgUzkE2V7x3Y2/f2JxL7NOpmZPAOis9Uy7j7YlRQpP2kcDCx4SjA2mmQe6KJX32fyUnuqUwLY07ZoOizDkdHNlxH/+Mcw0LD5I7AQ+hQqRk+GKUc/MdcqH9IzipcftptMfA5tjYp3eoeueslSSRTad2lfUkgYWuVdl74Rxh3dfVqRYuYcZ1lX92otTijAvnSEo37BG3bcx/esdfnmSII4UB3iihC3tFzbQ/sVIvCD8AFODXiDrZJTVYJt4BXgJT5vzZ9png9v1cGPynzlmQ6nJdzoY4UVy0ncmAbB43ToPQapOQPLqT1yiraaySk/LpDVGYOsx7LqNhJpoAAHQ/hw79eK71HoJnzVgZaZ5yhBHgHXVa+14wIjTtpH8T8vJMk0d8/kfApXU8zsp0aFOZgvc5JG2WB0xtcsLKjBrPn0V2D7iUfVWfUq7BF0GZjti8lf3bQ6fkhiSnzhNXwoCQPyVfcV5PVsxZWjZnal6ZQyhhuZdvqoJJ4h26Ix/4P1F6BQsiHEeLhbv3RUDnQgGaB+9o2J5gRRcEDuxqaW2OSfORahgbyuxM219krSyupHg1EKa6//kq3ij9CZuaCJf+sgSaIRpiONiYJTtZJVhQwzy3tb9LPccLT81e15fWVwKv6+p7+8eGo15gJABvJDpgNOsU4w5T3GU3hgnwGEEtBt9C0JD0tchozNl2tVhYyU0oFViT4og3VQU0EHS08CnH0+v1bb7UVhssqxr+n3Q0rzvri3CXB9NnYpbpRMH96ug8KckVfDx3MUGDMsDLF0jmF8BstrSGJLl7Jcm3qJJnJjFWRTxD2YTKGosC0fFgNSi7ROU3wrXgppzvrtfvIlMhTLVLyosZ3zDYWmEINRLboX06O9IoBXK/qVnm+lwGI2ZoD8TmLiUDndirHDvadCBmHm+6YZYVhG7PQOTwgrYceZB6psJ3zeToXsNHeeQMPKUNgbfSUab9ypqaYmqJLegRhYVT8xdYPHU1XYesqRHJVmI7bnkrBstUU=当然如果你使用的是Hexo版本&gt;=5的话 你还可以使用hexo的代码注入API方便的注入代码, 直接在网站的根目录下面创建一个scripts文件夹 这个文件夹中的js会自动运行 你只需要在文件夹当中创建js文件然后再js文件当中运行 hexo注入代码的API就可以了,由于inside注入代码的方式已经比较爽了,对于hexo提供的代码注入方式我这里就不再赘述\n0x40 SEO\n很多大佬的个人网站 之所以搞成静态的 其实根本原因就是搜索引擎对静态的站点比较友好,这类站点容易做SEO,设置keyword description 之类的东西, 在hexo的配置文件当中可以进行配置我就不多说了, 这里我主要讲一下 如何去向搜索引擎提交网站的sitemap文件,以及加快搜索引擎索引站点的方法.\n向搜索引擎提交 sitemap的文件的前提是 首先你要有sitemap文件, 那么sitemap文件哪里来呢? 其实可以使用hexo的插件去生成这个sitemap文件,具体步骤如下:\n\n安装相关的插件 npm install hexo-generator-sitemap --save\n然后可以在 hexo的配置文件当中 添加下面的配置\n\n123456sitemap:  path: sitemap.xml  // 生成的sitemap文件存放的位置  template: ./sitemap_template.xml  //生成sitemap文件所使用的模板所使用的位置  rel: false  // 是否将 rel-sitemap 添加到网站的 header当中  tags: true // 是否将tag页面放到sitemap当中  categories: true  //是否将categories 页面放到sitemap当中\n模板我们可以使用插件的默认模板就行了 把默认模板复制下来 保存到网站根目录当中保存成为 sitemap_template.xml就行了\n默认模板地址\n3. 最后执行 hexo g 的时候就能在public 目录下面生成 sitemap.xml了, 这个就是我们需要提交给搜索引擎的重要文件\n由于sitemap文件就存放在网站的根目录下面 所以地址是确定的,我们只要把这个文件的地址提交给搜索引擎,搜索引擎就会每隔一段时间来抓取我们的sitemap文件,来看看网站是否更新了新的内容了\n那么我们如何提交sitemap文件呢?\n提交sitemap文件的一个重要前提 就是验证网站的所有权, 验证网站所有权的方法有很多中,常见为下面几种:\n\n使用DNS的解析记录进行验证(最为简单方便)\n使用HTML的 Meta标记进行验证\n使用一个特殊的验证文件放在网站的某个目录进行验证\n\n下面我讲一下 针对于google bing 和baidu 我是如何快速的验证网站的所有权:\n\ngoogle网站所有权验证方式最为简单, 只需要在域名管理处添加 一条TXT的DNS解析记录就行了\nbing的网站所有权验证方式 也可以通过添加DNS解析记录的方式来完成不过bing需要添加的是CNAME的记录\nbaidu的网站所有权验证方式 同样可以使用添加DNS解析记录的方式  和bing一样添加CNAME记录即可\n\nGoogle网站所有权验证和提交Sitemap的地址: 点击地处打开\nBing网站所有权验证和提交Sitemap的地址: 点击地处打开\nBaidu网站所有权验证和提交Sitemap的地址: 点击地处打开\n提交完成sitemap之后 搜索引擎的爬虫 就会定期的去爬取你的站点的sitemap文件,来确保更新对你网站的收录,这个过程bing是最快的,其次是google,最后是baidu, 这种方式确实很安逸 等着被收录就行了, 就是效率实在太低了, 就算是最快的bing当你的网站更新了之后,它也需要几天的时间才会过来爬取你的站点,因为现在互联网上面的各种 乱七八遭的网站实在是太多了, 各大搜索引擎的爬虫实在是太忙了,一个新站点的权重实在是太小了,他们爬取和更新其他重要的网站时间还不够呢, 谁没事天天到你八百年不更新一篇的小博客来转悠啊,人家的时间成本是很高的,所以我们要变被动为主动, 主动的向搜索引擎提交我们更新的文章的连接,那我们要怎么做呢?\n主动更新搜索引擎收录的方式有两种:\n\n手动向搜索引擎提交连接\n使用搜索引擎提供的API去提交连接\n\n手动提交链接的方式实际上是比较适合更新周期比较长的个人博客的, 但是最为中华人民共和国的新时代青年,我不可能采用这样的方式(主要是太懒的🤣),所以我果断选择使用搜索引擎API去提交链接, 当然网上有现成的轮子可以用,也是我做此选择的主要原因:\n\n先安装插件 npm install --save hexo-submit-urls-to-search-engine\n然后 在hexo的配置文件当中添加下面的配置:\n\n1234567891011121314151617181920hexo_submit_urls_to_search_engine:  submit_condition: count #链接被提交的条件，可选值：count | period 现仅支持count  count: 10 # 提交最新的10个链接  period: 900 # 提交修改时间在 900 秒内的链接  google: 0 # 是否向Google提交,可选值:(0:否,1:是)&#123;google提交链接的API操作比较麻烦,我这里就屏蔽了向google提交链接&#125;  bing: 1 # 是否向bing提交,可选值:(0:否,1:是)  baidu: 1 # 是否向baidu提交,可选值:(0:否,1:是)    txt_path: submit_urls.txt ## 文本文档名， 需要推送的链接会保存在此文本文档里    baidu_host: https://lipanpanx.com ## 在百度站长平台中注册的域名  baidu_token: xxxxxx ## 请注意这是您向baidu提交网站链接的API的秘钥， 所以请不要把它直接发布在公众仓库里!  bing_host: https://lipanpanx.com ## 在bing站长平台中注册的域名  bing_token: xxxxxx ## 请注意这是您向bing提交网站链接的API的秘钥,所以请不要把它直接发布在公众仓库里!  google_host: https://lipanpanx.com ## 在google站长平台中注册的域名  google_key_file: Project.json #存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!  google_proxy: 0 # 向谷歌提交网址所使用的系统 http 代理，填 0 不使用\n\n然后再hexo配置文件的deploy字段下面添加下面三条内容:\n\n1234deploy:  - type: cjh_google_url_submitter  - type: cjh_bing_url_submitter  - type: cjh_baidu_url_submitter\n\n然后执行 hexo g &amp;&amp; hexo d 就能够调用相应的API去向搜索引擎提交你的网页链接给搜索引擎收录了\n\n","plink":"http://blog.lipanpanx.com/post/2021/202102/搭建Hexo博客/"},{"title":"JS的for...in和for...of","date":"2021-01-30T08:29:08.000Z","date_formatted":{"ll":"2021年1月30日","L":"2021/01/30","MM-DD":"01-30"},"updated":"2021-12-11T01:00:08.681Z","content":"for…in 和 for…of的区别和联系\nfor…in和 for…of的区别和联系 似懂非懂的 今天正好有时间把这个东西搞清楚写篇文章纪念一下:\n首先看一个例子 这个例子来自于Difference between for…of and for…in:\n12345678910111213141516171819202122232425262728Object.prototype.objCustom = function() &#123;&#125;;Array.prototype.arrCustom = function() &#123;&#125;;const iterable = [3, 5, 7];iterable.foo = &#x27;hello&#x27;;for (const i in iterable) &#123;  console.log(i); // 输出结果: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;    // 首先for...in 会迭代一个可迭代对象所有的 enumerable properties(可枚举属性)   // 因为 继承和原型链的存在 导致 iterable 会从 Object和Array当中继承 objCustom和arrCustom, 这两个东西会被迭代  // 除此之外 数组索引也是可枚举属性 也会被迭代  // 可能有人会问 为什么不会迭代数组的值?  : 因为数组的值 是值 而不是属性, for...in 仅仅用来迭代属性 &#125;for (const i in iterable) &#123;  if (iterable.hasOwnProperty(i)) &#123;    console.log(i); // 输出结果: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;    // 这里通过 hasOwnProperty() 做出判断仅仅对自己的属性进行迭代 不会继承的属性进行迭代  &#125;&#125;for (const i of iterable) &#123;  console.log(i); // 输出结果: 3, 5, 7  // for...of 对可迭代对象的值 进行迭代  而不会可迭代对象的属性 进行迭代 &#125;\n不建议用for…in操作数组\n在上面的例子当中我们可以看到 for…in 可以用来迭代数组中的属性, 但是不仅仅是自己的属性,继承的属性也会被一起迭代, 因为迭代的顺序取决于实现方式,其实for…in的实现方式并不能保证 数组的属性按照某个特定的顺序进行迭代, 如果操作的顺序非常重要的话建议使用Array.prototype.forEach() or for...of. 更详细内容参考:Array iteration and for…in\nfor…in到底用来干嘛呢?\n大部分的 情况下我们使用数组保存我们的数据, 如果for…in 不用来操作数组, 那么这个语句存在的意义又是什么呢?\n其实for…in 用来进行debug还是非常方便的, 毕竟可以输出所有属性, 还有就是针对键值对数据, 如果你想判定某个键值对的键是某个特定的值 那就可以使用for…in 进行很方便的检查. 更详细的内容参考:Why Use for…in?\n如何判定可枚举属性和可迭代对象?\n我们知道 for…in 对对象的可枚举属性进行迭代 而 for…of 对可迭代对象的值进行迭代, 关于可枚举属性和可迭代对象 其实mdn中有相关的文档进行介绍 具体参考下面的链接:\nEnumerability and ownership of properties\nIterables\n","plink":"http://blog.lipanpanx.com/post/2021/202101/JS的for-in和for-of/"},{"title":"CSS box-shadow样式生成器","date":"2021-01-21T11:42:22.000Z","date_formatted":{"ll":"2021年1月21日","L":"2021/01/21","MM-DD":"01-21"},"updated":"2021-12-11T01:00:08.681Z","content":"box-shadow是CSS当中的一个非常棒的特性, 通过这个属性我们设置阴影就很简单了. 根据mdn css doc 中的 box-shadow文档 这个属性可以接收多组值(每组值用逗号隔开),设置多个阴影.\n每一组值表示一个阴影又包含下面的几项(通过这几项我们可以控制阴影的存在形式(inset),偏移量(offset-x/y),模糊半径(blur-radius),扩散半径(spread-radius),和颜色(color)):\n\n最少2个最多4个 &lt;length&gt; 类型的值.(2个值表示offset-x/y,第3个值是blur-radius,第4个值是spread-radius)\n一个可选的 inset 关键字\n一个可选的 &lt;color&gt; 类型的值\n\n虽然css 的box-shadow 已经方便我们进行阴影设计了,我们从上文中可以看出设置阴影的时候需要控制的变量还是挺多的,如果想要设置复杂的阴影调试起来还是很累的,如果又工具能够帮助我们进行CSS 阴影代码调试那就再好不过了.\n\n所以今天介绍两个非常棒的box-shadow样式生成器\n这两个都是在线的工具 使用非常方便\nMDN box-shadow generator\nMDN CSS DOC 当中的工具\nMake a smooth shadow,friend.\n国外热心网友@brumm写的工具\n","plink":"http://blog.lipanpanx.com/post/2021/202101/BoxShadow样式生成器/"},{"title":"CSS visual formatting model","date":"2021-01-06T16:50:02.000Z","date_formatted":{"ll":"2021年1月6日","L":"2021/01/06","MM-DD":"01-06"},"updated":"2021-12-11T01:00:08.681Z","content":"今天准备抽时间仔细学习下CSS 的VFM 感觉这个东西还是非常重要的,CSS 的FC BFC IFC GFC FFC都和VFM有非常大的关系,所以我打算翻译一下 W3C CSS WG发布的Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification(REC-&gt;REC)中的第9章的内容9 Visual formatting model 喜欢最新内容的朋友可以看看 CSS WG关于 CSS Level2(CSS 2.2)的最新草稿Latest editor’s draft, 或者看看CSS WG最新一年度的工作日志CSS Snapshot 2020,下面就是我关于第9章的一些简单翻译:\nintroduction to  visual formatting model(9.1)\n文档树当中的每个元素会在VFM中生成0个或者多个box, 这些box的位置由下面几个东西决定:\n\nbox dimensions and type.\npositioning scheme (normal flow, float, and absolute positioning).\nrelationships between elements in the document tree.\nexternal information (e.g., viewport size, intrinsic dimensions of images, etc.)\n\n在CSS 2中，许多盒子的位置和大小都是根据一个叫被做 containing block 的矩形盒子的边缘来计算的。\n一般来说，生成的盒子充当包含后代盒子的块;我们说一个box 为它的后代建立了 containing block.\n“ a box’s containing block ” 意思是 “盒子所在的包含块”，而不是它生成的那个.\ncontrolling box generation(9.2)\nbox的类型 会影响 box在VFM当中的行为,用display属性可以控制 box 的类型.\n下面描述了可以被CSS2生成的 box 类型:\n\nblock boxes\nanonymous block boxes\ninline boxes\nanonymous inline boxes\nrun-in boxes\n\n\n通过display属性可以控制一个元素是否是block level element,\n一个block level element会生成 一个 principal block level box(包含子代盒子和生成的内容)\nblock level box 是块级格式上下文(BFC)的参与者.\n一般情况下 block level box 也是一个 block container box(除了table box和 replaced element).\nblock container box 要么只包含 block level box 要么只包含inline level box(建立在IFC中)\n但是并不是所有的 block container box 都是block level box: non-replaced inline blocks and non-replaced table cells都是 block container 但是他们不是 block-level box.\n对于那些 同时是block container 的 block level box我们称之为  block box.\n因为大多数的 block level box都是 block container 因此大多数的block level box可以被称为 block box.\nblock level box 和 block container box和 block box 我们可以统称为 block.\n匿名block box 例子:\n1234&lt;DIV&gt;  Some text  &lt;P&gt;More text&lt;/DIV&gt;\n这段代码当中假设 DIV和P的display属性都是block,\nDIV当中同时出现了 inline content(Some text) 和 block content(More text),\n但是DIV是一个 block container box, 如果一个 block container box当中存在一个box level box, VFM就会强制让内部的所有元素变成 block level box, 因为P是block level box 所以 Some text 会被套上一个 匿名的block box 来确保DIV内部所有的box都是block level box.\n当一个 inline box 包含一个 in-flow block level box, 这个inline box 将会被 block level box打破, 这个 inline box 将会被分成2个box, 分别在 block level box的两边. 被打断之前的部分和被打断之后的部分被封装在匿名 block box内. block level box 变成了 这些匿名 block box的兄弟盒子.\n如果这个 inline box 受到相对定位的影响 任何结果的转变也会反映到 inline box所包含的block level box上面.\n123456789101112131415&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;HEAD&gt;  &lt;TITLE&gt;Anonymous text interrupted by a block&lt;/TITLE&gt;  &lt;STYLE&gt;    p    &#123; display: inline &#125;    span &#123; display: block &#125;  &lt;/STYLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;  &lt;P&gt;  This is anonymous text before the SPAN.  &lt;SPAN&gt;This is the content of SPAN.&lt;/SPAN&gt;  This is anonymous text after the SPAN.  &lt;/P&gt;&lt;/BODY&gt;\n上面的内容我们可以看到 P元素包含了 一个匿名文本(C1)然后跟着一个block level element 然后再跟着一段匿名文本(C2), 这块内容的渲染结果就是 首先是BODY这个 block box,这个box包含了一个匿名block box(这个box包含C1),然后跟着SPAN这个block box,然后是另外一个匿名block box(这个box包含着C2).\n匿名box的属性可以继承来自封闭的非匿名盒子,\n对于非继承的属性可以有一个初始值,\n比如 匿名box的字体继承自父盒子 但是它的margin是一个初始值0.\n在导致生成 匿名 block box的 element上设置的属性 让然可以被引用到这个 element的box和内容上面.\n如果你为上面的P元素设置边框, 那么这个边框 围绕着 C1和C2绘制(半开形式).\n\n通过display属性可以控制一个元素是否是 inline level element\ninline level element 生成 inline level box , inline level box 是内联格式上下文(IFC)的参与者\n并不是所有的inline level box 都是 inline box\n对于那些不是inline box的 inline level box可以称之为 atomic inline level box,\n因为 他们 会 作为一个单独的不透明的盒子 参与到IFC当中去.\n任何直接包含 在一个 block container element(而不是被包含在inline element)的文本 必须被当作匿名的 inline element对待.\n看下面这个例子:\n12345&lt;p&gt;  Some   &lt;em&gt;emphasized&lt;/em&gt;   text&lt;/p&gt;\n这个例子当中P生成了一个包含 inline box的 block box.\n毫无疑问 EM是 inline element 它生成了 inline box,\n但是 “Some” 和 “text” 是被 block level element§所生成的匿名inline box包裹\n之所以被叫做匿名 inline box 因为他们没有一个相关联的 inline level element\n一些匿名 inline box 从他们的 block parent box继承了一些允许被继承的属性\n那些不允许被继承的属性 可以有一个初始值\n在上面的例子当中 匿名 inline box的 color继承自P 但是他们的背景确实透明的.\n随后根据White-space属性被折叠的空白内容不会生成任何匿名的inline box。\npostioning schemes(9.3)\n在 CSS2当中一个 box 可以有三种布局方案:\n\nnormal flow\nfloats\nabsolute positioning\n\n在CSS2当中normal flow 包括BFC(block formatting context) 和 IFC(inline formatting context)还有 block level box和 inline level box之间的 relative positioning.\n在float模型当中,首先按照 normal flow 放置box,然后再从flow中取出box尽可能的向左右两边放置, content(一般指父盒子当中的内容)会沿着float box的一边流动.\n在绝对定位模型当中, 会把box从normal flow当中彻底的删除(和其他的兄弟box之间再没有任何的关系和影响), 然后会赋予一个位置,这个位置是相对于 这个box的 containing block的.\nout of flow:  如果一个元素使用了 浮动,绝对定位,或者它是根元素 则这个元素被称为 out of flow\nin flow: 如果一个元素不是 out of flow 那么就是 in flow\nflow of an element A: 这是一个集合 这个集合包含A和A下面的所有子代元素\nCSS中通过 position 和 float 这两个属性控制 使用什么样的位置算法去计算box的位置.\nnormal flow(9.4)\nnormal flow 当中的 box 是属于FC(formatting context)的, 一个box可以属于BFC 也可以属于IFC 但是不能同时属于BFC和IFC,  block level box 会参与BFC,而inline level box 会参与IFC.\nBFC(block formatting context)\n什么情况下会创建BFC?\n\n对于浮动,绝对定位的元素,\n对于那些不是block box的block containers(比如:inline-blocks, table-cells, and table-captions),\n对于那些虽然是block box但是 他的overflow 属性却不是 visible的box(除非这个值已经传播到viewport).\n\n\n对于上面这几种情况,VFM会创建一个BFC 去包裹他们的内容.\n\nBFC内部的布局规则:\n\nBFC内部的Box会 从containing block 的顶部开始 在垂直方向一个接一个地放置.\n在BFC当中 两个兄弟Box在垂直方向的距离由margin决定, 属于同一个BFC的两个相邻Box的margin会发生重叠.\n在BFC当中 每个box的左边缘 会触碰到 containg block的左边缘(对于从右向左的formatting是右边缘),即使这个box使用了浮动, 除非这个box构建了一个新的BFC(这种情况下box可能会因为浮动而变的更窄)\n\n\n关于BFC,其实MDN上有一篇更加详细的文章:Block formatting context 这篇文章中同时讲到 GFC(grid formatting context) 和 FFC(flex formatting context) 他们和 BFC很相似 ,只是flex/grid container 内部不允许出现浮动的子元素. 但是外部的浮动用来抑制margin重叠依然能够正常工作.\n\n\n关于GFC更详细的内容参考W3C相关标准:CSS Grid Layout Module Level 2(CRD-&gt;CR)\n官运FFC更详细的内容同样参W3C的相关标准:CSS Flexible Box Layout Module Level 1(CR-&gt;PR),不过FFC内容不多　标准当中也没详细讲 三言两语就带过了😂\n\nIFC(inline formatting context)\nIFC内部的布局规则:\n\n在IFC当中 box从 containing block的顶部开始一个接着一个水平的排列\nbox之间 水平方向上的 margins borders 和 padding 得到保留\n这些box 能够以各种不同的方式 进行垂直对齐: 他们的顶部或者底部能够被对齐, 或者根据他们当中的文本的 baseline 进行对齐\n\n\n包含这些box 的 长方形区域 在水平方向上形成了 一条line 我们称为  line box.\nline box的宽度 是根据 containing blcok 和是否存在浮动所决定的. 高度 是根据第10.8章中的行高计算规则进行计算得出的.\n\n\nline box 的高度总是能够容纳它所包含的所有box, 然而，它可能比它所包含的最高的box还要高(for example,boxes are aligned so that baselines line up).假设存在一个box B, 当 box B的高度小于包含它的line box 的高度时，line box 中B的垂直对齐方式由vertical-align属性决定. 当几个inline level box无法水平地容纳在单个line box 中时，它们被分布在两个或多个垂直堆叠的line box 中。因此，paragraph 是line box的垂直堆栈。line box 没有垂直分隔(除非在其他地方指定)，并且它们从不重叠。\n\n\n一般来说，line box 的左边缘接触其containing block的左边缘，而右边缘接触其containing block的右边缘。然而,浮动的box 可能位于containing block边缘和 line box 边缘之间。因此，尽管在同一个IFC中的inline box 通常具有相同的宽度(一般就是 containing box的宽度)，但如果由于浮动而减少可用的水平空间，它们的宽度可能会变化。同一IFC中的line box 通常在高度上有所不同(例如，某一行可能包含一个很高图像，而其他的行可能只包含文本)。\n\n\n当一行之中的inline box 的总宽度小于包含它们的line box的宽度时，它们在line box 中的水平分布由 text-align 属性决定。如果 text-align的值是 justify, 则浏览器可能 会 拉伸 inline box内部的 spaces 和 words.(inline-table 和 inline-block box 除外)\n\n\n当一个inline box 超过 line box 的宽度时，它会被分成几个box ，这些box分布在几个line box当中。如果一个内联框不能拆分(eg:如果inline box 包含单个字符，或者特定语言的单词打破规则禁止在内联框内被分开，或者对于内联框受到nowrap或pre空白值的影响的情况),inline box 会溢出 line box.\n\n\n当一个inline box 被拆分时，margins borders and padding 在拆分时不会渲染出来.\n由于 bidirectional text processing ，inline box 也可能在同一个line box 内被分割成好几个 box。\n\n看看下面这个例子:\n1234567&lt;P&gt;  Several   &lt;EM&gt;emphasized words&lt;/EM&gt;   appear  &lt;STRONG&gt;in this&lt;/STRONG&gt;   sentence, dear.&lt;/P&gt;\n在这个例子当中 P元素生成了一个 block box 包含了5个 inline box, 其中三个是匿名的:\n\nAnonymous: “Several”\nEM: “emphasized words”\nAnonymous: “appear”\nSTRONG: “in this”\nAnonymous: “sentence, dear.”\n\n为了格式化段落，浏览器将这五个方框转换为行方框。\n在本例中，为P元素生成的box 为line box 建立了containing block 。如果包含块足够宽，所有的inline box 将适合一个line box:\n1Several emphasized words appear in this sentence, dear.\n如果不是，inline box 将被分割并分布在几个line box 中。前一段可分为以下几段:\n12Several emphasized words appearin this sentence, dear.\n或者下面这样:\n123Several emphasizedwords appear in thissentence, dear.\n在这里 如果我们故意把viewport设置的比较窄, 则可以让原有的EM box 被分成两个EM box(称它们为“split1”和“split2”)。\n虽然 EM box由一个变成2个, 但是如果我们对EM设置了margins, borders, padding, or text decorations,这些属性的效果是不会在split1之后或split2之前展现出来的, 2个分分开的盒子看起来仍然还像是同一个整体. 通过下面这个例子可以更加详细的展示出来:\n123456789101112131415161718&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;HTML&gt;  &lt;HEAD&gt;    &lt;TITLE&gt;Example of inline flow on several lines&lt;/TITLE&gt;    &lt;STYLE type=&quot;text/css&quot;&gt;      EM &#123;        padding: 2px;        margin: 1em;        border-width: medium;        border-style: dashed;        line-height: 2.4em;      &#125;    &lt;/STYLE&gt;  &lt;/HEAD&gt;  &lt;BODY&gt;    &lt;P&gt;Several &lt;EM&gt;emphasized words&lt;/EM&gt; appear here.&lt;/P&gt;  &lt;/BODY&gt;&lt;/HTML&gt;\n在P的宽度有限的情况下 效果如下 EM将会被分割称为2个box:\n\n\nThe margin is inserted before “emphasized” and after “words”.\nThe padding is inserted before, above, and below “emphasized” and after, above, and below “words”.\nA dashed border is rendered on three sides in each case.\n\nfloats(9.5)\n这一章有空再翻译\nabsolute positioning(9.6)\n在绝对定位模型中，一个盒子相对于它的包含块显式地偏移。它完全从正常流中删除(它对后面的兄弟节点没有影响)。绝对定位的盒子为正常流的子代和绝对(但不是固定的)位置的子代建立一个新的包含块。但是，绝对位置元素的内容不会在任何其他框中流动。它们可能掩盖另一个盒子的内容(或本身被掩盖)，这取决于重叠盒子的堆栈级别。\n本规范中的 absolutely positioned element 意味着这个元素的position属性的值为 absolute or fixed .\n固定定位是绝对定位的一个子类. 仅有的不同是 对于固定定位的盒子, containing block 是被viewport 所构建的. 对于 连续媒体 当 文档 滚动的时候 固定定位的盒子不会发生移动. 在这方便 他们类似于固定的背景图像. 对于分页媒体 固定定位的 box 在每一个page上重复. 这对于在每个page的底部放置签名就很有用了. 使用固定定位的盒子 他们大于页面区域的位置将会被裁剪掉. 在初始包含块中不可见的固定位置框的部分将不会打印。\n1234下面这几张内容有空再翻译## relationships between display position and float(9.7)## comparison of normal flow floats and absolute positioning(9.8) ## layered presentation(9.9)\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS-VFM/"},{"title":"CSS实现各种奇形怪状","date":"2021-01-05T17:22:39.000Z","date_formatted":{"ll":"2021年1月5日","L":"2021/01/05","MM-DD":"01-05"},"updated":"2021-12-11T01:00:08.681Z","content":"利用border\n\n可以按F12看下上面这个盒子的源码 样式我写成了嵌入式的:其实原理非常简单就是一个div正方形盒子他的上下左右的border设置的很大等于这个正方形的边长的一半然后颜色设置为不同就行了,然后我们从这样一形状得到三角形就很简单了,把一部分设置成为透明就行了.\n如下可以实现各种由等边三角形组成的形状:\n\n    \n    \n    \n    \n    \n\n\n对于正方形盒子border宽度设置为边长的1/2如上,如果border宽度设置成为边长的1/4如下就可以搞出梯形了:\n\n如果border宽度随意设置就可以搞出各种其他的各种奇怪的形状,简直不堪入目😂:\n\n    \n    \n    \n    \n    \n\n\n如果加上border-radius并且把它的值设置正方形边长的1/2或者1/4就得到了下面两个图形:\n\n\n然后稍加改造 又可以造出鬼畜的形状:\n\n其实通过border-radius可以搞出来的奇形怪状可不少,可以使用mdn的生成工具慢慢调试Border-radius generator\n然后通过把部分border设置为透明或者把border-radius设置的更加离谱一些又可以得到其他的形状:\n\n\n\n利用伪元素\n如果配合伪元素::before和::after 则能够玩出更多的花样来,其实利用伪元素::before和::after无非就是盒子本身弄成一个形状然后这2个伪元素再弄成2个形状,最后三个形状拼接成某个特殊的形状我们以太极为例:\n可以先搞一个盒子搞成分开的半圆如下:\n\n然后再利用::before和::after画两个内外反色的圆环放在左右2处即可:\n\n\n\n\n结果如下图所示:\n\n利用box-shadow\n下面这个月亮其实就是一个圆形盒子的红色阴影\n\n总结\nCSS生成的各种奇奇怪怪的形状其实就是先用css的特性造出来一些基础形状,然后再对这些基础形状再进行旋转变换遮罩拼接形成更加复杂的形状.\n","plink":"http://blog.lipanpanx.com/post/2021/202101/CSS实现各种奇形怪状/"},{"title":"波士顿动力狗SPOT购买指北","date":"2020-07-19T17:34:57.000Z","date_formatted":{"ll":"2020年7月19日","L":"2020/07/19","MM-DD":"07-19"},"updated":"2021-12-11T01:00:08.681Z","content":"波士顿动力狗 SPOT 权威购买指北\n\n\n两周前 油管科技视频播主 Lew Later 发布了一支 波士顿动力狗子的开箱视频,短短两周的时间内这支视频的播放量就达到了367万, 在Lew Later 近期发布的视频中,这支视频的播放量绝对算得上遥遥领先了, 国内媒体也纷纷转发, 大家对这条视频如此的热衷,主要原因还是这次开箱应该是世界上第一台民用版本的波士顿动力狗的开箱视频了.\n\n\n波士顿动力的狗子 总共有3个版本 分别是  探索版, 企业版, 教育版. 其中企业版和教育版本只对有相关资质的企业,高校以及科研机构开放,官方也没有提供线上购买渠道, 而是需要你自己去联系波士顿动力进行沟通购买, 而探索版面向的群体就比较全面了,官网直接提供了在线购买的链接,可以在线付款购买.  本次开箱的版本就是探索版了,因为官方在不久之前开放了探索版的购买入口,这使得  Lew Later 的这次开箱成为可能. 不过我觉得真正促成这次开箱达成的还是油管播主雄厚的财力, 下面的售价大家感受一下:\n\n\n\n标准版的狗子 押金1000美金,折合成人民币就是6998元(你交全款的时候押金会退还), 全款 74500美金 折合成人民币就是  521363元 没有现货只能预定(6-8周内发货)\n\n\n另外官方还给这条狗子配了很多配件,大家感受下把配件整全的价格:\n\n\n\n全部的官方配件配全的价格是 164595美元 折合人民币就是 1151862元, 这个价格可以买 3辆高配版的Tesla model 3,我放张图让大家直观的感受下:\n\n\n\n看完这条狗子令人咋舌的售价之后,我们再来看下这条狗子的各方面参数,看下是否值这个价钱:\n\n\n首先这条狗长1.1m,宽0.5m,站立高度0.84m, 坐下的高度是0.191m,净重量32.5kg, 如果带上一块电池的话就是36.4kg,(电池重4.2kg),从这些参数来看的话,这条狗子和家里不要钱的狗子在个子大小和重量方面几乎差不多,不过续航时间远不如家里不要钱的狗子, 这条狗子标配的单电池容量是650Wh, 不带负载的平均运行时间是1.5个小时,如果狗子待机不动,这个电池也仅能支撑3个小时,更加坑的是电池充满电需要2个小时, 充电2小时运行1.5小时,确实给人一种不划算的感觉, 不过好在这块电池 支持交流100-240V 50-60Hz的电源进行充电,直接可以在国内使用, 电池输出的是35-58.6V的直流电,最大输出电流7.2A,可以在0-40度的温度之间正常输出. 狗子的连接方式也很现代化, 支持 WIFI 2.4Ghz b/g/n的无线网络,同时也支持千兆以太网进行连接,同时这条狗子的防水等级是IP54,可以在-20-45度的环境下快活的奔跑, 虽然防水, 续航 和工作温度方面的参数都远不如家里不要钱的狗子, 但是波士顿动力的狗子的眼睛是真的多, 全身配备了5组RGBD相机, 前侧2条, 左右侧各一条, 屁股上面一条, 水平可视范围是360度,传感器的水平探测范围是4m, 可以感受大于2lux的光, 从而确保这条狗子能够看清楚身体周围的任何障碍物并与之保持距离, 避免发生不必要的摩擦. 狗子买回来是要拿出去溜的, 这条狗子的运动性能如何呢? 最高速度1.6m/s, 可以上下 ±30°的斜坡, 和高度为300mm的台阶, 这个运动能力, 在现在的机器人世界绝对可以说是一骑绝尘了, 而且这条狗子可以连接其他的高精度的传感器模块,来支持更高精度的视觉范围和更加灵活的运动能力, 狗子的背部有  850 mm (L) x 240 mm (W) x 270m m (H)大的区域可以用来放东西, 可以直接把官方的扩展模块放到这里, 这条狗子的最大负重是14kg, 用来装官方的那些配件是足够了, 而且狗子身上还有两个DB25的接口, 可以用来传输数据和供电, 支持35-58.8V的直流电输出, 每个接口的输出功率是150W, 可以允许你通过硬件接口去控制狗子也可以通过官方提供的软件接口用Python来控制狗子, 而且官网还为这条狗子配备了一个7寸的安卓控制器,分辨率是1920x1200, 大小是:143.6 mm(H)x274 mm(W)x53 mm(H) 是不是感觉很棒, 这条狗子绝对比家里不要钱的狗子听话多了. 我放几张图让大家感受下这条狗子出色的运动能力:\n\n\n\n\n\n\n\n怎么样看完上面的参数描述是不是已经急着要下单了? 是不是像我一样已经开始纠结用微信付款还是用支付宝付款了呢?  经过长达24小时的思想斗争之后我决定用微信付款, 是的我决定用微信付款, 为什么? 因为我的支付分没有pony高, 这让我很不爽. 拿出手机打开微信扫一扫, 颤抖的左手拿着手机,颤抖的右手滑动鼠标,点击购物车里的checkout, 进入checkout页面之后我着实松了一口气, 因为官方既不支持微信也不支持支付宝,但是比较坑的是它只卖给美国人, 收获地址不允许选择除了美国地区以外的范围, 我怒了, 可以不让我买, 但是你不允许我的小伙伴买你是几个意思?\n\n\n\n于是我连夜联系波士顿动力的客服, 最后得到的答复是 除美国以外的地区都不卖只能租, 但是有个好消息是波士顿动力有一套流程是可以让你从一个长期的租赁者变成一个购买者的, 比如说你租个5-10年, 后面这个狗子可能就是你的了.具体情况还要自己去联系波士顿动力的客服. 国内的用户想要租赁这条狗子的话,可以自己去官网联系客服, 也可以在公众号早睡蟒 后台回复跬蟒加我微信,我帮你沟通一波.\n\n\n最后看下官方的探索版狗子标准套装的发货清单:\n\n\n1条狗子\n2个狗子电池\n1个狗子电池充电器\n1个狗子的遥控器还有遥控器的充电器\n1个装狗子的大箱子\n1个装狗子电池,遥控器的小箱子\n1个双目视觉标定板\nPython客户端开发包\n软件更新许可\n后续的支持服务许可\n\n\n\n国内用户租赁狗子联系连接:\nhttps://www.bostondynamics.com/spot-sales\n\n","plink":"http://blog.lipanpanx.com/post/2020/波士顿动力狗SPOT购买指北/"},{"title":"Python设计模式-单例模式","date":"2020-07-03T17:48:01.000Z","date_formatted":{"ll":"2020年7月3日","L":"2020/07/03","MM-DD":"07-03"},"updated":"2021-12-11T01:00:08.681Z","content":"什么是单例模式?\n\n单例模式是一种写程序的方式,用单例模式设计的类,无论你去实例化多少次,得到的都是同一个实例,一般我们设计的类每次实例化都会生成不同的实例,但是单例模式就是反其道而行之,就像下面这样:\n\n\n\n上图中的ClassA和ClassB 都是采用的 单例设计模式,而ClassC没有采用单例设计模式\n\n\n我们可以清晰的看到 ClassA的两个不同的实例在内存中的地址是相同的,也就是说两次实例化得到的对象是同一个对象,ClassB和ClassA也是一样的,因为都采用了单例设计模式, 而ClassC因为没有采用单例设计模式所以他的两个实例对象指向不同的内存地址,也就是说两次实例化得到的是两个不同的对象.\n\n为什么需要单例模式?\n\n要弄清楚为什么需要单例模式, 首先需要知道单例模式提供了哪些优秀的特性?\n\n单例模式提供的最为优秀的特性就是:单例模式可以允许你在程序的任何地方访问某个特定的对象\n\n通过单例设计模式, 你可以在不定义全局变量的情况下,在程序的任何地方访问你所指定的对象,单例模式所提供的功能和全局变量是一样的, 但是通过单例模式设计, 你就可以在无需牺牲代码可读性和安全性的前提下完成和全局变量完全一样的功能. 单例模式吸收了全局变量的优点摒弃了全局变量的缺点,是替代可恶全局变量不二的选择.\n\n在上面的例子中我们可以看到无论实例化多少次ClassA得到的都是同一个对象, 如果这个类处于一个比较大的工程中,在这个工程中的任何位置实例化ClassA得到的都是同一个对象,这不就是全局变量吗, 但是和全局变量不同的是通过单例模式产生对象的代码更加的易读,而且这种面向对象的编程方式可以确保ClassA所产生的对象只能被对象自身的方法所操作, 这样就更加的安全, 而且你可以通过获取实例的方法对返回对象的行为进行更多的限制.\n\n为什么需要单例模式? 本质上是因为人们需要全局变量,需要一个更加好用更加安全的全局变量, 单例模式的出现解决了全局变量的现有问题, 所以人们才需要单例模式\n\n单例模式和全局变量的区别?\n\n单例模式像极了全局变量, 但是单例模式毕竟不是实现全局变量, 除了上述所说的异同点之外, 通过单例模式产生的对象和全局变量还有一个明显的区别就是全局变量一旦定义就绝对不会再发生改变, 但是单例模式虽然说每次返回的都是一个固定的对象, 但这个固定的对象还是可以通过单例类自身的一些方法去更改的,所以单例模式产生的对象和全局变量比起来只能说是相对固定的.\n\n单例模式如何实现?\n\n任何一门语言要想实现单例模式,可能都有很多的实现方法,但是实现思路大同小异,肯定都是在第一次生成实例的时候就直接把实例给存储到某个地方,然后在下一次实例化的时候直接返回这个事先被存储起来的实例,而不是重新去实例化返回一个新的实例.\n\n基于装饰器的实现\n\nPython实现单例模式一个比较优雅的实现方式就是通过装饰器去实现,如下所示:\n\n12345678910111213141516171819202122232425262728def singleton(cls):    instances = &#123;&#125;    def getinstance(*args,**kwargs):        if cls not in instances:            instances[cls] = cls(*args,**kwargs)        return instances[cls]    return getinstance@singletonclass ClassA:    pass@singletonclass ClassB:    passclass ClassC:    passaa=ClassA()aaa=ClassA()bb=ClassB()bbb=ClassB()cc=ClassC()ccc=ClassC()\n\n上面的例子我们可以看到singleton是一个装饰器函数, 通过闭包的原理让其内部的 instances 变量的生命周期和全局变量等同,然后把被装饰的类第一次实例化生成的对象直接存储在instances中,在取对象的时候直接从在instances字典中找到事先存储好的对象返回,就是通过这样的方式实现单例的.\n\n\n单例模式的实现方式还有很多种: 比如通过类属性实现, 通过元类实现等多种方式, 甚至每一种实现可能都有自己特定的应用场景, 但是我觉得通过装饰器实现最为优雅, 本着少就是多的原则, 其他的实现方式我就不再赘述, 如果对其他的实现方式感兴趣可以加我微信(备注好公司岗位)交流沟通.\n\n","plink":"http://blog.lipanpanx.com/post/2020/Python设计模式-单例模式/"},{"title":"Github仓库如何选择开源许可证","date":"2020-06-15T17:35:57.000Z","date_formatted":{"ll":"2020年6月15日","L":"2020/06/15","MM-DD":"06-15"},"updated":"2021-12-11T01:00:08.681Z","content":"选择开源证书\n\n当我们点了Github个人主页右上角的那个那个加号之后,如上所示可以看到创建新仓库的选项, 点击 `New repository` , 就会进入到创建新仓库的页面,进入到这个页面之后可以看到右下角的下拉框可以为自己的项目选择开源许可证:\n\n截至到2020/06/13日,Github在创建仓库允许选择的开源许可证如下所示:\n\n如上图所示可以Github支持的开源许可证还是很多的  Apache, MIT, BSD, CC0, EPL, AGPL, GPL, LGPL, MPL都支持,\n这样一来大大方便了我们的选择,但是有时候选择多了未必是好事情,面对开源许可证,每个人可能心中都存在过这样的疑问:\n\n\n为什么要使用开源许可证? 我完全不用开源许可证好像也没啥问题啊\n就算我打算用开源许可证,Github上面这么多,完全不知道选择那个呀? 根本不知道他们之间有啥区别?\nGithub上面的开源许可证都不是我想要的,我有了解到一个非常棒的证书,但是Github创建仓库的时候还没得选怎么办?\n\n\n为什么需要开源许可证?\n要弄懂为什么要使用开源许可证,我觉得应该首先弄懂不使用开源许可证会怎样?\n不使用开源许可证对于开发者有何影响?\n\n首先在没有开源许可证的情况下你对你的项目是独占版权的,这样就会造成一个问题就是别人使用你的项目比较困难, 然后就会导致没人愿意去使用你的项目,还有个问题就是 如果多人参与你的项目的开发,因为每个人都成为了这个项目的版权持有者, 你自己在没有得到团队中所有成员授权的情况下,\n对项目的随意使用其实也是违法的,如果你想要很好的维护项目的其他贡献者的版权许可,那你不得不去和你的项目贡献者之间签订一个贡献者协议,\n想想都是一个很头疼的事情.\n\n\n其次还有个问题,就是当你把你的代码发布到Github的公共仓库的时候, 也就意味着你接受了Github公共仓库的一些服务条款,由于这些条款的存在\n很多人可以去查看和复制你的项目仓库, 在一些特殊的情况下,部分人对于你的项目的使用可能不需要你的许可和授权.\n\n不使用开源许可证对于项目的使用者有何影响?\n\n如果你发现了一个软件,而这个软件没有开源许可证,那么也就意味着你没有得到作者的授权,尽管在Github上面你能够查看和复制代码,但是严格意义上你不能出于任何目的去使用,修改,和分享这个软件, 你说蛋疼不蛋疼.\n\n\n此时作为一个项目的使用者你所能做的就是:\n\n和项目的开发者沟通去加上开源许可证\n不去使用这个没有开源许可证的项目,即使你觉得这个项目不错\n和开发者进行私人协商,获取开发者的授权\n\n\n\n总结: 为什么要使用开源许可证, 因为不用的话,会给开发者和使用者带来很多的麻烦事情,\n用开源许可证是为了避免日后在项目的使用过程中一些不必要的麻烦\n\nGithub的开源许可证如何选择,他们之间有何区别?\n这个世界上有太多的开源许可证,甚至Github的开源许可证就有很多,我相信大多数人都没有时间和精力去认证的去了解每一个开源许可证,那怎么办呢?\n所以我这里把最主要的几个开源许可证的地址和允许的权力列了出来,大家首先做个粗判断, 简单判断一下自己可能会用到那个开源许可证,然后再去认真的研究,\n如果真的对开源许可证非常感兴趣, 也可以先全研究几个被广为使用的开源许可证(比如 GPLv3和MIT许可证), 跟着潮流走总不会有啥大问题.\n常见的软件开源许可证(开放程度由高到低)\n\nGNU  AGPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial useDistribution Modification Patent use Private use\nDisclose source License and copyright notice Network use is distribution Same license State changes\nLiability Warranty\n\n\n\n\nGNU  GPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license State changes\nLiability Warranty\n\n\n\n\nGNU  LGPLv3\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license State changes\nLiability Warranty\n\n\n\n\nMozilla Public License 2.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nDisclose source License and copyright notice Same license (file)\nLiability Trademark use Warranty\n\n\n\n\nApache License 2.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice State changes\nLiability Trademark use Warranty\n\n\n\n\nMIT License\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice \nLiability Warranty\n\n\n\n\nBoost Software License 1.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\nLicense and copyright notice \nLiability Warranty\n\n\n\n\nThe Unlicense\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Patent use Private use\n\nLiability Warranty\n\n\n\n常见的非软件开源许可证\n\nCC0-1.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\n\nLiability Patent use Trademark use Warranty\n\n\n\n\nCC-BY-4.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\nLicense and copyright notice  State changes\nLiability Patent use Trademark use Warranty\n\n\n\n\nCC-BY-SA-4.0\n\n\nPermissions\nConditions\nLimitations\n\n\n\n\nCommercial use Distribution Modification Private use\nLicense and copyright notice  State changesSame license\nLiability Patent use Trademark use Warranty\n\n\n\n如何看懂上面的图表\nPermissions :就是开源许可证允许做的事情\nCondition: 就是要在特定的情况下才允许做的事情\nLimitations: 就是开源许可证不允许去做的事情\n软件开源许可证如何选择?\n我们需要一张乌克兰老铁(Paul Bagwell)画的图来帮助我们进行理解和选择 :\n\n\n由上图可以看到目前主流的开源证书主要分为两派:\nGPL系列 和 MPL 站一派  (我简称他们A派)\nBSD系列, MIT 和 Apache 站一派  (我简称他们B派)\n两派之间的主要区别就是你在原有的开源软件上做了更改之后是否允许其所使用开源证书发生变化:\nA派的观点就是你更改开源项目之后所使用的开源证书必须和原有开源项目保持一致或者相兼容, 其实就是一个始于开源 忠于开源的思想,让大家一直开源\nB派的观点就是原有的开源项目,如果你更改了部分代码的话那你也可以更改开源证书,这样以来对于开源项目而言,就更加的容易被商业化,\n而GPLv3和MIT 这两个开源证书简直就是A派和B派的两个极端, 也是目前最受欢迎的两个证书,具体怎么选择大家可以看图行事,当然更加详细的协议内容还是建议大家根据我发的协议链接找到协议原文,去仔细阅读协议原文进行了解\n\n非软件开源许可证如何选择?\n数据集 视频  所使用的开源许可证\n\nCC0-1.0, CC-BY-4.0, 和 CC-BY-SA-4.0  这三种开源许可证就经常被用在数据集和视频 等非软件的项目上面,\n有一点需要注意的就是 CC-BY-4.0 和 CC-BY-SA-4.0 这两种许可证是不建议给软件项目用的\nCC-BY-4.0 和 CC-BY-SA-4.0非常的相似,后者比前者有一项要求就是,如果你对开源项目进行了更改,\n那么更改后的版本所使用的开源协议必须和原有协议相同或者想兼容,\n这里和软件开源证书的两派的思想是相同的\n\n文档所使用的开源许可证\n\n一般情况下开源软件中所附带的开源的文档和 开源软件本身持有相同的开源许可证,\n当然你也可以针对开源软件和其对应的开源文档使用两套不同的开源许可证,\n但是你一定要指出文档中的 源代码示例 所使用的许可证是什么类型的\n\n字体使用的开源许可证\n\n针对开源字体常用的许可证就是 SIL Open Font License 1.1 ,\n这个许可证可以允许别人自由的去使用它,同时保留自己的版权\n\n混合工程使用的许可证\n\n如果你的 项目是个非常大的混合工程,包含 软件, 文档, 数据集,视频,字体等内容, 那你就需要为自己的项目准备多个许可证,\n但是你需要做一个说明,用来说明你的工程的各个部分分别使用怎样的许可证 .\n\n如果Github上面的所有许可证都不能满足我的要求怎么办?\n开源许可证本质上就是一个名字为LICENSE或者LICENSE.txt的文本文件\n如果你将要使用的开源许可证不可以在Github上建立仓库的时候进行选择,那么你可以这么做:\n\n\n在选择开源许可证的时候随便选择一个,然后把自动生成的LICENSE中的文件更改为你所需要的内容\n\n\n\n\n直接不选择开源许可证,在自己的项目文件夹中自己去创建 LICENSE/LICENSE.txt文件 然后把自己所使用的开源许可证的协议内容粘贴进去\n\n\n","plink":"http://blog.lipanpanx.com/post/2020/Github开源证书选择/"},{"title":"学习PythonPEP的书写和提交流程","date":"2020-06-07T17:45:40.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"updated":"2021-12-11T01:00:08.681Z","content":"\n如果你为Python写了一篇PEP,这篇PEP成功的被Python指导委员会接受了,\n那么以后你在吹牛皮的时候你就可以说我主导了Python语言某个特性的设计工作.\n\n我就问你主导Python语言特性设计牛不牛皮,今天我就写一篇文章告诉大家如何去为Python设计一篇PEP,并且整个PEP从一个想法到Python语言去实现它的这一套流程:\n\n假设你已经是一个Python高手了,在使用Python给过程中你觉得Python语言在某方面还不够完善,你有一个不错的想法可以去改善Python这方面的不足,你打算把你的想法加入到Python语言里面,所以你打算写一篇PEP,为Python的发展献言建策,那首先需要做什么呢?\n\n\n首先你要确保你的想法是个新的想法是个比较大的想法,是一个由必要去建立一个PEP的想法,也许你发现了Python的一些小问题,但是这些小问题如果提交一个小补丁就可以解决了,那就没必要提PEP\n当你确定自己的想法很牛B之后,你也不是马上就要提PEP,你首先要做的事情是引发社区的讨论,看看其他人怎么看,然后自己去实现一下这个想法看是否是可行的,并且发帖到 python-list@python.org mailing list或者到 python-ideas@python.org mailing list 进行进一步的确定,看看大家对你的想法是否认同,如果你能让大多数人都认同,那你就有戏,在你发帖之前最好准备一份高质量的PEP草稿,这样的话才会更容易的被接受\n总之就是先讨论,得到大家的认可,避免后期不必要的撕逼,然受自己也要做好准备,最好有个简单的实现,然后还有个高质量的PEP草稿\n\n写PEP你不得不知道的几个Python社区角色\n\nPEP champion :  PEP拥护者 也就是PEP的发起人,也就是跟大家说我有个非常XXX的想法的人\n\n\nPEP author:  PEP作者 就是写PEP的人,PEP从一个想法到一篇PEP草稿,再到一篇拥有官方PEP编号的PEP文档,到后面PEP审核通过,PEP复审出现改动,PEP被接受这个过程中维护PEP文档的人就是PEP的作者,大部分PEP作者就是PEP拥护者本人\n\n\nPEP reviewer: 这个角色不是单指某一个人,一个PEP从想法到实现需要经过很多此review, 每一次参与review的人都可以被称作 PEP reviewer\n\n\nPEP editor: PEP编辑者 就是对PEP进行初步审核的人,审核通过的PEP进入到github上面的PEP仓库的master分支,进行下一轮的评审\n\n\nPython Core Developers: Python核心开发人员 就是开发Cpython解释器的那群人,都是大佬,都是大佬\n\n\nPython’s Steering Council: Python指导委员会 大佬中的大佬,从Python核心开发人员中选择出来的指导Python语言开发工作的一群人,对于PEP是否接受有着最终发言权\n\nPEP的工作流程是这样的:\n\nPEP champion 先有一个高质量的idear(经过讨论分析和理性验证)\n你去github上面去fork PEP仓库\n在仓库中创建一个 pep-9999.rst的文件去把你的PEP草稿粘贴进去\n确定你的PEP的类型,PEP的状态设为草稿,PEP头部按照模板写一波\n把你的pep-9999.rst push到PEP仓库\n然后PEP editors 会去审核你的提交\n如果审核通过,这个本来是草稿的PEP会拿到一个正规的PEP编号,如果没有审核通过那PEP editors 会打回去让 PEP author 去修改\n如果PEP审核通过拿到了PEP编号 PEP editor 会把这个新提交的PEP合并到PEP仓库的 master 分支\n如果你的PEP的类型是Standards Track类,那你提交的PEP还会被发送给Python-dev list 成员进行再次review, 确保你的新PEP没有坑\n有些听起很不错的PEP在实现的时候其实是非常蛋疼的,没做的时候想的挺好,真正去实现的时候才知道是否靠谱,最好的情况时你在提交PEP的时候你手里就已经有一个这个PEP的原型实现了,所以如果你的PEP类型是Standards Track类型那你就不仅需要准备设计文档,你还需要准备一个参考实现,以此来避免一些不切实际的想法\n\n当然凡事都有例外,有些Python的核心开发者是不会走这个流程的因为他们本身的权限比较大,他们有直接push内容到PEP仓库的权限,所以有时候他们会直接给自己的PEP分配一个PEP编号push进入PEP仓库的master分支,当然这并不意味着这个PEP就被接受了,他只是绕过了PEP editor的审批而已,PEP被接受和PEP通过审批是完全两码事儿,只有通过Python指导委员会的同意,PEP计划实现,才能叫做PEP被接受.\n如果我写的PEP无法审核通过被拒怎么办?\nPEP被拒绝是很正常的事情,不要灰心,只要能够坚信自己的PEP是真正对Python有用的东西,真正好的idear,修改一下继续上就行了,但是被拒肯定是有原因的,最主要的原因就是下面几条:\n\n该特性已经存在了\n技术上不合理\nPython不需要去实现这样的特性,也就是说伪需求\n无法进行后向兼容\n不符合Python的设计哲学(Python设计哲学可以在Python交互解释器中输入import this获取)其实在PEP的审批阶段可以拿着自己的PEP idear去咨询Python指导委员会,因为PEP最终会不会被接受其实是由Python指导委员会所决定的,所以如果真的想要自己的PEP被接受,做好提前的沟通还是非常有必要的\n奥对了还有一个蛋疼的要求,就是你的PEP草稿必须带着至少一名Python核心开发人员一起写,或者有一个Python核心开发人员指导你写,或者有一个经过Python指导委员会批准的非Python核心开发人员一起写,反正就是需要有一个能够被Python指导委员会所信任的人参与了你的PEP设计,如果没能满足这个条件 PEP editor有权直接驳回你的PEP草稿\n\nPEP的复审和决定机制\n一篇PEP是否最终被接受并且决定去实现是需要经过层层复审的,反正要经过很麻烦了一个流程,下面有个Python官方画的简单流程图:\n\n但是实际情况比较复杂,有时候不会按照这个流程图来,但是这个流程图给人们提供了一个比较清晰的PEP工作流的概览\nPEP格式和模板\n这年头写啥文档没个模板真不行,PEP也是文档,所以模板搞起来:\n\n首先PEP是UTF-8编码的rst文件,首先你需要去指导rst文件的格式,如果rst的语法格式你已经会了,那你就可以阅读官方的PEP 12--Sample reStructuredText PEP Template,没错PEP12是介绍rst格式PEP模板的PEP(有点绕),为什么要用rst格式?官方给出的解释是 容易转成html进行在线发布和阅读\n每一篇PEP必须有一个标准的PEP头部,如下所示,带* 号是可写可不写的,不带* 号的是必须要写的,记住写PEP头的时候,头的各个字段的顺序,必须按照下图的内容去写,先后顺序不能乱\n\n\n写道这里就讲的差不多了,但是其实PEP的书写还有很多的内容比如:\n\n\n如何判断PEP是不是一个成功的PEP\nPEP提交之后发现内容有bug怎么解决\nPEP所有权以及所有权转移问题\nPEP editor的详细职责和工作流\n等等问题,我就不写了,写不动了…\n\n\n想写PEP的可以先根据上面流程走一波,\n然后等到遇到问题的时候再去查资料吧.\n","plink":"http://blog.lipanpanx.com/post/2020/学习PythonPEP的书写和提交流程/"},{"title":"关于我","date":"2021-10-27T07:36:22.000Z","date_formatted":{"ll":"2021年10月27日","L":"2021/10/27","MM-DD":"10-27"},"updated":"2021-12-11T01:00:08.681Z","content":"屌丝程序员一枚\n","plink":"http://blog.lipanpanx.com/about/"}]